---
phase: 02.1-setup-testing-framework
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/jest.config.ts
  - apps/api/jest.setup.ts
  - apps/api/src/test-utils/test-websocket.ts
  - apps/web/vitest.config.ts
  - apps/web/vitest.setup.ts
  - apps/web/src/test-utils/render.tsx
  - package.json
autonomous: true

must_haves:
  truths:
    - "Jest runs tests in API application"
    - "Vitest runs tests in web application"
    - "Test commands execute without errors"
    - "Coverage reports are generated"
    - "Test utilities are available for use in test files"
  artifacts:
    - path: "apps/api/jest.config.ts"
      provides: "API Jest configuration with coverage"
      min_lines: 25
    - path: "apps/web/vitest.config.ts"
      provides: "Web Vitest configuration with jsdom environment"
      min_lines: 30
    - path: "apps/web/vitest.setup.ts"
      provides: "Browser API polyfills for Mantine"
      min_lines: 25
    - path: "apps/api/src/test-utils/test-websocket.ts"
      provides: "TestWebSocket helper class"
      exports: ["TestWebSocket"]
    - path: "apps/web/src/test-utils/render.tsx"
      provides: "Custom render with providers"
      exports: ["render"]
  key_links:
    - from: "apps/api/jest.config.ts"
      to: "nx test api"
      via: "Nx auto-detection"
      pattern: "testEnvironment.*node"
    - from: "apps/web/vitest.config.ts"
      to: "apps/web/vitest.setup.ts"
      via: "setupFiles configuration"
      pattern: "setupFiles.*vitest.setup"
    - from: "apps/web/src/test-utils/render.tsx"
      to: "@testing-library/react"
      via: "imports render function"
      pattern: "import.*@testing-library/react"
---

<objective>
Establish comprehensive testing infrastructure with Jest for API and Vitest for web application, including proper configuration, test utilities, and Nx integration.

Purpose: Create foundation for retroactive test coverage and mandate testing for all future work
Output: Configured Jest for API, Vitest for web, test utilities, and working test commands
</objective>

<execution_context>
@/Users/bmcalindin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/bmcalindin/workspace/catan/.planning/PROJECT.md
@/Users/bmcalindin/workspace/catan/.planning/ROADMAP.md
@/Users/bmcalindin/workspace/catan/.planning/STATE.md
@/Users/bmcalindin/workspace/catan/.planning/phases/02.1-setup-testing-framework-with-jest-and-retroactively-add-tests-to-code-going-forward-tests-must-be-written-and-pass-to-be-successful/02.1-RESEARCH.md

# Existing tech stack
@/Users/bmcalindin/workspace/catan/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install testing dependencies and configure Jest for API, Vitest for web</name>
  <files>
    package.json
    apps/api/jest.config.ts
    apps/web/vitest.config.ts
  </files>
  <action>
Install required testing libraries:
```bash
npm install --save-dev jest @types/jest ts-jest @testing-library/react @testing-library/user-event @testing-library/jest-dom @vitest/coverage-v8
```

**API Jest Configuration (apps/api/jest.config.ts):**
Create Jest configuration for Node.js environment:
- Use ts-jest preset for TypeScript support
- testEnvironment: 'node'
- Include src/**/*.spec.ts pattern
- Configure coverage with thresholds: 80% lines/functions, 75% branches
- Exclude src/**/*.spec.ts, src/test-utils/**, src/main.ts from coverage
- Set moduleNameMapper for path aliases if needed

Example structure:
```typescript
export default {
  displayName: 'api',
  preset: '../../jest.preset.js',
  testEnvironment: 'node',
  transform: {
    '^.+\\.[tj]s$': ['ts-jest', { tsconfig: '<rootDir>/tsconfig.spec.json' }],
  },
  moduleFileExtensions: ['ts', 'js', 'html'],
  coverageDirectory: '../../coverage/apps/api',
  testMatch: ['<rootDir>/src/**/*.spec.ts'],
  coveragePathIgnorePatterns: [
    '/node_modules/',
    '\\.spec\\.ts$',
    '/test-utils/',
    'main.ts',
  ],
  coverageThresholds: {
    global: {
      lines: 80,
      functions: 80,
      branches: 75,
      statements: 80,
    },
  },
};
```

**Web Vitest Configuration (apps/web/vitest.config.ts):**
Create configuration following RESEARCH.md Pattern 1:
- Use jsdom environment (for React)
- Include src/**/*.spec.{ts,tsx} pattern
- Configure v8 coverage provider
- Set coverage thresholds: 80% lines/functions, 75% branches
- Exclude test files, test-utils, main.tsx, router.tsx from coverage
- Reference vitest.setup.ts in setupFiles array
- Use nxViteTsPaths and react plugins

**Add Nx test scripts to package.json:**
```json
"test": "nx run-many -t test --all",
"test:api": "nx test api",
"test:web": "nx test web",
"test:coverage": "nx run-many -t test --all --coverage"
```

Why this approach: Jest is the industry standard for Node.js/Express testing with excellent TypeScript support via ts-jest. Vitest is already installed and is the natural choice for Vite-based React apps. Using each framework in its native environment provides best performance and DX.
  </action>
  <verify>
```bash
nx test api --run
nx test web --run
npm run test:coverage
```

All commands should execute without configuration errors (tests may fail since we haven't written them yet).
  </verify>
  <done>
Jest configured for API, Vitest configured for web, npm scripts added, Nx can execute both test targets.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test utilities and helper classes</name>
  <files>
    apps/api/src/test-utils/test-websocket.ts
    apps/web/src/test-utils/render.tsx
    apps/api/jest.setup.ts
  </files>
  <action>
**TestWebSocket helper class (apps/api/src/test-utils/test-websocket.ts):**
Implement following RESEARCH.md Pattern 2 "TestWebSocket Helper Class":
- Extend ws WebSocket class
- Add waitUntil(targetState, timeout) method for waiting until 'open' or 'closed'
- Add waitForMessage<T>(timeout) method that returns Promise<T> of parsed JSON
- Add sendJSON(message) convenience method
- Include timeout protection (default 1000ms) to prevent hanging tests

**Custom render wrapper (apps/web/src/test-utils/render.tsx):**
Implement following RESEARCH.md Pattern 5:
- Import render from @testing-library/react
- Export custom render function that wraps components with QueryClientProvider and MantineProvider
- Create fresh QueryClient with retry: false for tests
- Accept options parameter and spread to testingLibraryRender

**API test setup (apps/api/jest.setup.ts):**
Create minimal setup file (Node environment doesn't need polyfills):
```typescript
// Empty or basic setup - API uses Node environment
// This file can be referenced in jest.config.ts setupFilesAfterEnv if needed
```

Why this approach: TestWebSocket class encapsulates WebSocket test patterns from RESEARCH.md, avoiding race conditions. Custom render ensures all React components have required providers (Mantine, TanStack Query). Setup files loaded before tests via configuration.
  </action>
  <verify>
```bash
# Verify files created
ls apps/api/src/test-utils/test-websocket.ts
ls apps/web/src/test-utils/render.tsx
ls apps/api/jest.setup.ts

# Verify TypeScript compiles
npx tsc --noEmit -p apps/api/tsconfig.app.json
npx nx typecheck @catan/web
```

No TypeScript errors, utilities export expected functions/classes.
  </verify>
  <done>
Test utility classes created and TypeScript validates them.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add browser API polyfills for Mantine</name>
  <files>
    apps/web/vitest.setup.ts
  </files>
  <action>
Create web test setup file following RESEARCH.md "Vitest Setup File for Mantine (Web App)":

**apps/web/vitest.setup.ts:**
```typescript
import { vi } from 'vitest';
import '@testing-library/jest-dom/vitest';

// Mock window.matchMedia (required by Mantine)
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation((query) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
});

// Mock ResizeObserver (required by Mantine)
global.ResizeObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}));

// Mock scrollIntoView (not available in jsdom)
Element.prototype.scrollIntoView = vi.fn();
```

Why these polyfills: Mantine v8 components require window.matchMedia and ResizeObserver which jsdom doesn't implement. Without these, React component tests crash immediately with "matchMedia is not a function" errors. This is documented in Mantine official Vitest guide.
  </action>
  <verify>
```bash
# Verify setup file created
cat apps/web/vitest.setup.ts | grep -E "(matchMedia|ResizeObserver)"

# Verify TypeScript compiles
npx nx typecheck @catan/web
```

Setup file contains polyfills, no TypeScript errors.
  </verify>
  <done>
Mantine polyfills in place, web app tests can render Mantine components without crashes.
  </done>
</task>

</tasks>

<verification>
Run test commands to verify infrastructure:
```bash
nx test api --run
nx test web --run
npm run test:coverage
```

Expected: Commands execute successfully (no tests yet, so 0 tests passing is OK). No configuration errors or missing dependencies.
</verification>

<success_criteria>
1. `nx test api` uses Jest and executes without errors
2. `nx test web` uses Vitest and executes without errors
3. Jest configuration exists for API with coverage thresholds
4. Vitest configuration exists for web with v8 coverage and proper thresholds
5. Test utilities (TestWebSocket, custom render) created and TypeScript-valid
6. Mantine polyfills prevent jsdom crashes in web tests
7. Nx workspace recognizes both test targets
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-setup-testing-framework-with-jest-and-retroactively-add-tests-to-code-going-forward-tests-must-be-written-and-pass-to-be-successful/02.1-01-SUMMARY.md`
</output>
