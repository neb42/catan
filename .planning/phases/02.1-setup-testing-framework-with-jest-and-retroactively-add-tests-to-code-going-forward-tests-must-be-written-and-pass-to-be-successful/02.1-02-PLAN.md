---
phase: 02.1-setup-testing-framework
plan: 02
type: execute
wave: 2
depends_on: ["02.1-01"]
files_modified:
  - apps/api/src/websocket/schemas/client-messages.spec.ts
  - apps/api/src/websocket/schemas/server-messages.spec.ts
  - apps/api/src/websocket/connection-manager.spec.ts
  - apps/api/src/websocket/room-manager.spec.ts
  - apps/api/src/websocket/message-router.spec.ts
  - apps/api/src/websocket/__tests__/websocket-integration.spec.ts
  - apps/api/src/test-utils/test-server.ts
autonomous: true

must_haves:
  truths:
    - "All API WebSocket code has test coverage"
    - "Schema validation tests catch invalid inputs"
    - "Manager unit tests verify business logic"
    - "Integration tests verify real WebSocket connections work"
    - "All tests pass when running nx test api"
  artifacts:
    - path: "apps/api/src/websocket/schemas/client-messages.spec.ts"
      provides: "Zod schema validation tests"
      min_lines: 80
    - path: "apps/api/src/websocket/connection-manager.spec.ts"
      provides: "ConnectionManager unit tests"
      min_lines: 100
    - path: "apps/api/src/websocket/room-manager.spec.ts"
      provides: "RoomManager unit tests"
      min_lines: 100
    - path: "apps/api/src/websocket/__tests__/websocket-integration.spec.ts"
      provides: "WebSocket server integration tests"
      min_lines: 80
  key_links:
    - from: "apps/api/src/websocket/schemas/client-messages.spec.ts"
      to: "apps/api/src/websocket/schemas/client-messages.ts"
      via: "imports and tests schemas"
      pattern: "import.*client-messages"
    - from: "apps/api/src/websocket/__tests__/websocket-integration.spec.ts"
      to: "apps/api/src/test-utils/test-websocket.ts"
      via: "uses TestWebSocket helper"
      pattern: "import.*TestWebSocket"
    - from: "apps/api/src/websocket/connection-manager.spec.ts"
      to: "ws"
      via: "mocks WebSocket with vi.fn()"
      pattern: "vi.fn.*send"
---

<objective>
Add comprehensive test coverage for all API WebSocket infrastructure including schema validation, manager classes, and integration tests.

Purpose: Ensure existing WebSocket code is tested before building additional features
Output: Full test suite for API covering schemas, managers, and integration scenarios
</objective>

<execution_context>
@/Users/bmcalindin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/bmcalindin/workspace/catan/.planning/PROJECT.md
@/Users/bmcalindin/workspace/catan/.planning/ROADMAP.md
@/Users/bmcalindin/workspace/catan/.planning/STATE.md
@/Users/bmcalindin/workspace/catan/.planning/phases/02.1-setup-testing-framework-with-jest-and-retroactively-add-tests-to-code-going-forward-tests-must-be-written-and-pass-to-be-successful/02.1-RESEARCH.md

# Source files to test
@/Users/bmcalindin/workspace/catan/apps/api/src/websocket/schemas/client-messages.ts
@/Users/bmcalindin/workspace/catan/apps/api/src/websocket/schemas/server-messages.ts
@/Users/bmcalindin/workspace/catan/apps/api/src/websocket/connection-manager.ts
@/Users/bmcalindin/workspace/catan/apps/api/src/websocket/room-manager.ts
@/Users/bmcalindin/workspace/catan/apps/api/src/websocket/message-router.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Test Zod message schemas with validation cases</name>
  <files>
    apps/api/src/websocket/schemas/client-messages.spec.ts
    apps/api/src/websocket/schemas/server-messages.spec.ts
  </files>
  <action>
**Client message schema tests (client-messages.spec.ts):**
Follow RESEARCH.md Pattern 4 "Testing Zod Schemas":

Test HandshakeMessageSchema:
- Valid handshake with null clientId (new connection)
- Valid handshake with UUID clientId (reconnection)
- Reject invalid UUID format (not matching UUID regex)
- Reject missing payload

Test SetNicknameMessageSchema:
- Valid nickname (3-30 chars)
- Trim whitespace from nickname (use trim() transform)
- Reject nickname shorter than 3 characters
- Reject nickname longer than 30 characters
- Reject empty/whitespace-only nickname

Test JoinRoomMessageSchema:
- Valid roomId
- Reject empty roomId

Test discriminatedUnion (ClientMessage):
- Parse all valid message types
- Reject unknown message type
- Use safeParse() not parse() for validation tests
- Check result.success and result.error.issues

**Server message schema tests (server-messages.spec.ts):**
Test each server message schema similarly:
- ClientIdMessage (valid UUID)
- NicknameAcceptedMessage
- NicknameRejectedMessage (with reason enum)
- RoomJoinedMessage
- ErrorMessage (with error text)

Test discriminatedUnion (ServerMessage) for all types.

Why this approach: Zod schemas are the contract between client and server. Testing validates both valid inputs (expected to parse) and invalid inputs (expected to fail with specific errors). Use safeParse() in tests to inspect validation failures without throwing.
  </action>
  <verify>
```bash
nx test api --run --testNamePattern="schema"
```

All schema tests pass, invalid inputs are properly rejected.
  </verify>
  <done>
Schema validation tests cover all message types with valid and invalid cases.
  </done>
</task>

<task type="auto">
  <name>Task 2: Test manager classes with mocked dependencies</name>
  <files>
    apps/api/src/websocket/connection-manager.spec.ts
    apps/api/src/websocket/room-manager.spec.ts
    apps/api/src/websocket/message-router.spec.ts
  </files>
  <action>
**ConnectionManager tests (connection-manager.spec.ts):**
Follow RESEARCH.md Pattern 3 "Unit Testing Managers with Mock Dependencies":

Test connection lifecycle:
- addConnection assigns UUID and stores connection
- removeConnection marks as disconnected with grace period
- addConnection within grace period restores client ID (reconnection)
- addConnection after grace period assigns new client ID
- connectionCount returns accurate count
- getConnection retrieves WebSocket by clientId

Test heartbeat with fake timers (RESEARCH.md Pattern 6):
- Use vi.useFakeTimers() in beforeEach
- Advance time by 30 seconds, verify ping called
- Simulate no pong response, advance another 30s, verify terminate called
- Use vi.useRealTimers() in afterEach

Mock WebSocket:
```typescript
const mockWs: Partial<WebSocket> = {
  readyState: WebSocket.OPEN,
  send: vi.fn(),
  on: vi.fn(),
  ping: vi.fn(),
  terminate: vi.fn(),
};
```

**RoomManager tests (room-manager.spec.ts):**
Test room operations:
- createRoom assigns UUID
- joinRoom adds client to room
- leaveRoom removes client from room
- deleteRoom cleans up room data
- getRoomClients returns Set of clientIds
- broadcastToRoom sends to all clients in room (except sender)
- setNickname and getNickname store/retrieve nicknames
- isNicknameTaken checks case-insensitive uniqueness

Mock ConnectionManager dependency:
```typescript
const mockConnectionManager = {
  sendMessage: vi.fn(),
  getConnection: vi.fn(),
};
```

**MessageRouter tests (message-router.spec.ts):**
Test message routing:
- routeMessage parses valid messages and calls handler
- routeMessage sends ERROR for invalid JSON
- routeMessage sends ERROR for schema validation failures
- HANDSHAKE handler assigns clientId (new or restored)
- SET_NICKNAME handler validates and stores nickname
- JOIN_ROOM handler adds client to room
- Handlers use manager dependencies correctly

Mock dependencies (ConnectionManager, RoomManager).

Why this approach: Unit tests isolate business logic from WebSocket infrastructure. Mock WebSocket objects with vi.fn() to verify manager behavior without real network connections. Fake timers make heartbeat tests deterministic and instant.
  </action>
  <verify>
```bash
nx test api --run --testNamePattern="Manager|Router"
```

All manager and router unit tests pass.
  </verify>
  <done>
Manager classes have comprehensive unit test coverage with mocked dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create WebSocket integration tests with real connections</name>
  <files>
    apps/api/src/websocket/__tests__/websocket-integration.spec.ts
    apps/api/src/test-utils/test-server.ts
  </files>
  <action>
**Test server helper (test-server.ts):**
Create helper to start WebSocket server on test port:
```typescript
import { Server } from 'http';
import { createApp } from '../../app';
import { setupWebSocket } from '../index';

export async function startTestServer(port: number): Promise<Server> {
  const app = createApp();
  const server = app.listen(port);
  setupWebSocket(server);

  return new Promise((resolve) => {
    server.once('listening', () => resolve(server));
  });
}
```

**Integration tests (websocket-integration.spec.ts):**
Follow RESEARCH.md Pattern 2 "WebSocket Integration Testing":

Setup/teardown:
- beforeAll: Start server on port 3001
- afterAll: Close server
- afterEach: Close any open client connections

Test scenarios using TestWebSocket helper:
1. Handshake flow:
   - Client connects to ws://localhost:3001
   - Wait for connection with waitUntil('open')
   - Send HANDSHAKE message with null clientId
   - Wait for CLIENT_ID message with waitForMessage()
   - Verify clientId is valid UUID

2. Nickname validation:
   - Complete handshake first
   - Send SET_NICKNAME with valid nickname
   - Wait for NICKNAME_ACCEPTED
   - Verify accepted message received

3. Duplicate nickname rejection:
   - Create two clients, both handshake
   - Client 1 sets nickname "Alice"
   - Client 2 tries nickname "alice" (case-insensitive)
   - Client 2 receives NICKNAME_REJECTED with reason ALREADY_TAKEN

4. Room joining:
   - Complete handshake and nickname
   - Send JOIN_ROOM with roomId "lobby"
   - Wait for ROOM_JOINED message
   - Verify roomId in response

5. Reconnection:
   - Complete handshake, receive clientId
   - Close connection
   - Reconnect with same clientId in HANDSHAKE
   - Verify server accepts reconnection (CLIENT_ID matches)

Why this approach: Integration tests verify the full WebSocket stack works end-to-end. Using real WebSocket connections (not mocks) catches issues like message serialization, connection handling, and race conditions. TestWebSocket helper prevents flaky tests by providing timeout-protected promises.
  </action>
  <verify>
```bash
nx test api --run --testNamePattern="integration"
```

All integration tests pass, WebSocket server handles real connections correctly.
  </verify>
  <done>
Integration test suite verifies complete WebSocket server functionality with real connections.
  </done>
</task>

</tasks>

<verification>
Run full API test suite with coverage:
```bash
nx test api --coverage
```

Expected:
- All tests pass (schemas, managers, integration)
- Coverage meets thresholds (80% lines/functions, 75% branches)
- No WebSocket server port conflicts or hanging connections
</verification>

<success_criteria>
1. All API test files created and tests pass
2. Schema validation tests cover valid and invalid cases
3. Manager unit tests use mocked dependencies
4. Integration tests use real WebSocket connections
5. Coverage thresholds met (80%+ lines/functions)
6. `nx test api` completes successfully
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-setup-testing-framework-with-jest-and-retroactively-add-tests-to-code-going-forward-tests-must-be-written-and-pass-to-be-successful/02.1-02-SUMMARY.md`
</output>
