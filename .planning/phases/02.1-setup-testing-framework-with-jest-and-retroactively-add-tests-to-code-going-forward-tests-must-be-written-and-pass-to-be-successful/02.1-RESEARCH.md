# Phase 2.1: Setup Testing Framework with Jest and Retroactively Add Tests to Code - Research

**Researched:** 2026-01-19
**Domain:** Vitest testing framework for Nx monorepo (Node.js/Express backend, React/Vite frontend)
**Confidence:** HIGH

## Summary

This phase involves setting up comprehensive testing infrastructure using **Vitest** (not Jest) for an Nx monorepo with TypeScript, Express 5.x backend, and React 18 frontend. Vitest is already installed in the project and is the natural choice given the existing Vite/Nx stack.

Key findings:
- **Vitest is already installed** - the project has `vitest@^4.0.0` and `@vitest/ui@^4.0.0` in devDependencies
- Nx has native Vitest support through `@nx/vite/plugin` which auto-detects `vitest.config.ts` files
- WebSocket server testing requires integration test patterns using real WebSocket connections
- React component testing needs polyfills for Mantine v8 (window.matchMedia, ResizeObserver)
- TanStack Router/Query require specific test wrappers and contexts
- v8 coverage provider is recommended (faster, equivalent accuracy to Istanbul as of Vitest 3.2.0+)

**Primary recommendation:** Configure Vitest for both apps/api and apps/web with separate vitest.config.ts files, use integration testing for WebSocket infrastructure, unit testing for business logic (schemas, managers), and React Testing Library with proper polyfills for frontend components.

## Standard Stack

The established libraries/tools for testing this stack:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Vitest | 4.0+ | Test runner | Already installed, Vite-native, Jest-compatible API, fastest runner |
| @vitest/ui | 4.0+ | Visual test UI | Built-in UI for debugging tests |
| @testing-library/react | latest | React component testing | Industry standard for testing React UIs |
| @testing-library/user-event | latest | User interaction simulation | Accurate browser event simulation |
| @testing-library/jest-dom | latest | DOM matchers | Enhanced assertions for DOM elements |
| jsdom | ~22.1.0 | Browser environment | Already installed, required for React tests |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| ws | 8.19.0 | WebSocket testing | Integration tests for WebSocket server (already installed) |
| @vitest/coverage-v8 | 4.0+ | Coverage reporting | Fast, accurate coverage with v8 provider |
| msw | 2.x | API mocking | Optional: mock HTTP endpoints in frontend tests |
| vitest-websocket-mock | latest | WebSocket mocking | Optional: unit tests with mocked WebSockets (limitations with ws library) |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Vitest | Jest | Jest is slower, requires more config, less Vite integration |
| v8 coverage | istanbul | Istanbul is 3x slower but works on non-V8 runtimes |
| Integration WS tests | vitest-websocket-mock | Mock only supports browser API, not full ws library |

**Installation:**
```bash
# Already installed: vitest, @vitest/ui, jsdom
# Add testing libraries
npm install --save-dev @testing-library/react @testing-library/user-event @testing-library/jest-dom @vitest/coverage-v8

# Optional: MSW for API mocking
npm install --save-dev msw@latest
```

## Architecture Patterns

### Recommended Project Structure
```
apps/
├── api/
│   ├── src/
│   │   ├── websocket/
│   │   │   ├── connection-manager.ts
│   │   │   ├── connection-manager.spec.ts       # Unit tests
│   │   │   ├── room-manager.ts
│   │   │   ├── room-manager.spec.ts             # Unit tests
│   │   │   ├── message-router.ts
│   │   │   ├── message-router.spec.ts           # Unit tests
│   │   │   ├── schemas/
│   │   │   │   ├── client-messages.ts
│   │   │   │   └── client-messages.spec.ts      # Schema validation tests
│   │   │   └── __tests__/
│   │   │       └── websocket-integration.spec.ts # Integration tests
│   │   └── test-utils/
│   │       ├── test-websocket.ts                # WebSocket test helpers
│   │       └── mock-websocket.ts                # Mock WebSocket factory
│   ├── vitest.config.ts                         # API-specific config
│   └── vitest.setup.ts                          # API test setup
│
└── web/
    ├── src/
    │   ├── lib/
    │   │   ├── websocket.ts
    │   │   ├── websocket.spec.ts                # Unit tests
    │   │   ├── websocket-context.tsx
    │   │   └── websocket-context.spec.tsx       # Context tests
    │   ├── routes/
    │   │   ├── index.tsx
    │   │   └── index.spec.tsx                   # Route component tests
    │   └── test-utils/
    │       ├── render.tsx                       # Custom render with providers
    │       └── test-router.tsx                  # Router test helpers
    ├── vitest.config.ts                         # Web-specific config
    └── vitest.setup.ts                          # Web test setup (polyfills)
```

### Pattern 1: Nx Vitest Integration
**What:** Nx auto-detects vitest.config.ts files and creates test targets
**When to use:** Every project that needs testing (apps/api and apps/web)
**Example:**
```typescript
// apps/api/vitest.config.ts
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    include: ['src/**/*.spec.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      include: ['src/**/*.ts'],
      exclude: ['src/**/*.spec.ts', 'src/test-utils/**'],
      thresholds: {
        lines: 80,
        functions: 80,
        branches: 75,
        statements: 80,
      },
    },
  },
});
```

**Run tests:**
```bash
nx test api       # Run API tests
nx test web       # Run web tests
nx run-many -t test --all  # Run all tests
```

### Pattern 2: WebSocket Integration Testing
**What:** Test real WebSocket server with client connections using ws library
**When to use:** Testing connection lifecycle, message routing, room management
**Example:**
```typescript
// Source: https://github.com/ITenthusiasm/testing-websockets
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import WebSocket from 'ws';
import { startServer } from './test-utils/test-server';

describe('WebSocket Server Integration', () => {
  let server: Server;
  const port = 3001;
  const url = `ws://localhost:${port}`;

  beforeAll(async () => {
    server = await startServer(port);
  });

  afterAll(() => {
    server.close();
  });

  it('should accept handshake and assign client ID', async () => {
    const client = new WebSocket(url);

    // Wait for connection
    await new Promise((resolve) => {
      client.once('open', resolve);
    });

    // Wait for CLIENT_ID message
    const message = await new Promise((resolve) => {
      client.once('message', (data) => {
        resolve(JSON.parse(data.toString()));
      });

      // Send handshake
      client.send(JSON.stringify({
        type: 'HANDSHAKE',
        payload: { clientId: null }
      }));
    });

    expect(message.type).toBe('CLIENT_ID');
    expect(message.payload.clientId).toMatch(/^[0-9a-f-]{36}$/i);

    client.close();
  });
});
```

### Pattern 3: Unit Testing Managers with Mock Dependencies
**What:** Test business logic classes with mocked WebSocket connections
**When to use:** ConnectionManager, RoomManager isolated unit tests
**Example:**
```typescript
// apps/api/src/websocket/connection-manager.spec.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { ConnectionManager } from './connection-manager';
import { WebSocket } from 'ws';

describe('ConnectionManager', () => {
  let manager: ConnectionManager;
  let mockWs: Partial<WebSocket>;

  beforeEach(() => {
    manager = new ConnectionManager();
    mockWs = {
      readyState: WebSocket.OPEN,
      send: vi.fn(),
      on: vi.fn(),
      ping: vi.fn(),
    };
  });

  it('should assign UUID to new connection', () => {
    const clientId = manager.addConnection(mockWs as WebSocket);

    expect(clientId).toMatch(/^[0-9a-f-]{36}$/i);
    expect(manager.connectionCount).toBe(1);
  });

  it('should restore connection within grace period', () => {
    // Add initial connection
    const clientId = manager.addConnection(mockWs as WebSocket);

    // Simulate disconnect
    manager.removeConnection(clientId);
    expect(manager.connectionCount).toBe(0);

    // Reconnect within grace period
    const mockWs2 = { ...mockWs };
    const restoredId = manager.addConnection(mockWs2 as WebSocket, clientId);

    expect(restoredId).toBe(clientId);
    expect(manager.connectionCount).toBe(1);
  });
});
```

### Pattern 4: Testing Zod Schemas
**What:** Validate schema parsing for both valid and invalid inputs
**When to use:** All Zod schema files (client-messages.ts, server-messages.ts)
**Example:**
```typescript
// Source: https://stevekinney.com/courses/full-stack-typescript/testing-zod-schema
import { describe, it, expect } from 'vitest';
import { HandshakeMessageSchema, SetNicknameMessageSchema } from './client-messages';

describe('Client Message Schemas', () => {
  describe('HandshakeMessageSchema', () => {
    it('should parse valid handshake with null clientId', () => {
      const input = {
        type: 'HANDSHAKE',
        payload: { clientId: null }
      };

      const result = HandshakeMessageSchema.safeParse(input);

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data).toEqual(input);
      }
    });

    it('should parse valid handshake with UUID clientId', () => {
      const input = {
        type: 'HANDSHAKE',
        payload: { clientId: '550e8400-e29b-41d4-a716-446655440000' }
      };

      const result = HandshakeMessageSchema.safeParse(input);
      expect(result.success).toBe(true);
    });

    it('should reject invalid UUID format', () => {
      const input = {
        type: 'HANDSHAKE',
        payload: { clientId: 'not-a-uuid' }
      };

      const result = HandshakeMessageSchema.safeParse(input);

      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues[0].path).toContain('clientId');
      }
    });
  });

  describe('SetNicknameMessageSchema', () => {
    it('should reject nickname shorter than 3 characters', () => {
      const input = {
        type: 'SET_NICKNAME',
        payload: { nickname: 'ab' }
      };

      const result = SetNicknameMessageSchema.safeParse(input);
      expect(result.success).toBe(false);
    });

    it('should trim whitespace from nickname', () => {
      const input = {
        type: 'SET_NICKNAME',
        payload: { nickname: '  player  ' }
      };

      const result = SetNicknameMessageSchema.safeParse(input);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.payload.nickname).toBe('player');
      }
    });
  });
});
```

### Pattern 5: React Component Testing with Mantine + TanStack Router
**What:** Test React components with proper provider wrappers and polyfills
**When to use:** All React component tests (routes, features, components)
**Example:**
```typescript
// Source: https://mantine.dev/guides/vitest/
// apps/web/src/test-utils/render.tsx
import { render as testingLibraryRender } from '@testing-library/react';
import { MantineProvider } from '@mantine/core';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { RouterProvider, createMemoryHistory, createRootRoute, createRouter } from '@tanstack/react-router';

export function render(ui: React.ReactNode, options = {}) {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  });

  return testingLibraryRender(<>{ui}</>, {
    wrapper: ({ children }) => (
      <QueryClientProvider client={queryClient}>
        <MantineProvider>
          {children}
        </MantineProvider>
      </QueryClientProvider>
    ),
    ...options,
  });
}

// Component test example
// apps/web/src/routes/index.spec.tsx
import { describe, it, expect, vi } from 'vitest';
import { screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { render } from '../test-utils/render';
import { LandingPage } from './index';

describe('LandingPage', () => {
  it('should render nickname input form', () => {
    render(<LandingPage />);

    expect(screen.getByRole('textbox', { name: /nickname/i })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /join/i })).toBeInTheDocument();
  });

  it('should validate nickname length', async () => {
    const user = userEvent.setup();
    render(<LandingPage />);

    const input = screen.getByRole('textbox', { name: /nickname/i });
    const button = screen.getByRole('button', { name: /join/i });

    // Too short
    await user.type(input, 'ab');
    await user.click(button);

    await waitFor(() => {
      expect(screen.getByText(/at least 3 characters/i)).toBeInTheDocument();
    });
  });
});
```

### Pattern 6: Testing with Mock Timers
**What:** Control setTimeout/setInterval in tests for deterministic behavior
**When to use:** Testing ConnectionManager heartbeat, ReconnectingWebSocket backoff
**Example:**
```typescript
// Source: https://vitest.dev/guide/mocking/timers
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { ConnectionManager } from './connection-manager';

describe('ConnectionManager Heartbeat', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('should terminate unresponsive connections after 30 seconds', () => {
    const manager = new ConnectionManager();
    const mockWs = {
      readyState: WebSocket.OPEN,
      send: vi.fn(),
      on: vi.fn(),
      ping: vi.fn(),
      terminate: vi.fn(),
    };

    const clientId = manager.addConnection(mockWs as any);

    // Advance time by 30 seconds
    vi.advanceTimersByTime(30000);

    // Connection should be marked as not alive after first ping
    expect(mockWs.ping).toHaveBeenCalledTimes(1);

    // Advance another 30 seconds without pong response
    vi.advanceTimersByTime(30000);

    // Connection should be terminated
    expect(mockWs.terminate).toHaveBeenCalled();
    expect(manager.connectionCount).toBe(0);
  });
});
```

### Anti-Patterns to Avoid
- **Don't test implementation details:** Test behavior, not internal state (e.g., don't test private methods directly)
- **Don't share state between tests:** Each test should be independent with fresh instances
- **Don't use real timers for time-dependent code:** Always use vi.useFakeTimers() for setTimeout/setInterval
- **Don't test React internals:** Avoid testing state variables, use screen queries and user interactions
- **Don't mock everything:** Use integration tests for critical paths (WebSocket connections), unit tests for isolated logic

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| WebSocket testing utilities | Custom promise wrappers for events | TestWebSocket class pattern or integration tests | Event-driven APIs need careful race condition handling, timeout protection |
| React component render wrapper | Inline providers in each test | Custom render() function | Mantine requires MantineProvider, TanStack Query needs QueryClient, reduces boilerplate |
| Timer testing | Real setTimeout with delays | vi.useFakeTimers() | Real timers slow tests, non-deterministic, fake timers are instant and controllable |
| Browser API polyfills | Custom shims | Official polyfills in setup file | window.matchMedia, ResizeObserver required by Mantine, standard polyfills tested by community |
| Coverage reporting | Manual coverage tracking | Vitest v8 coverage provider | Built-in, accurate, fast, integrated with Nx |
| Message validation testing | Manual JSON parsing checks | Zod safeParse() with exhaustive cases | Catches edge cases, type-safe errors, validates schema contracts |

**Key insight:** Testing infrastructure has mature solutions. Custom testing utilities introduce maintenance burden and miss edge cases that production libraries already handle.

## Common Pitfalls

### Pitfall 1: Testing WebSockets with Browser-Only Mocks
**What goes wrong:** Using vitest-websocket-mock with the ws library causes compatibility issues
**Why it happens:** vitest-websocket-mock uses mock-socket which only implements browser WebSocket API, but ws library has Node.js-specific features
**How to avoid:** Use integration tests with real WebSocket connections for ws library testing, reserve mocks for browser client testing
**Warning signs:** Tests fail with "method not found" errors, connection lifecycle doesn't match real behavior

### Pitfall 2: Missing Mantine Polyfills in Tests
**What goes wrong:** Tests fail with "window.matchMedia is not a function" or ResizeObserver errors
**Why it happens:** jsdom doesn't implement these browser APIs but Mantine components require them
**How to avoid:** Create vitest.setup.ts with polyfills for window.matchMedia and ResizeObserver
**Warning signs:** Tests crash immediately when rendering Mantine components, stack trace mentions matchMedia or ResizeObserver

### Pitfall 3: Race Conditions in WebSocket Event Tests
**What goes wrong:** Tests are flaky, sometimes pass/fail, especially under load
**Why it happens:** Registering message handlers after sending messages causes race conditions
**How to avoid:** Always register event listeners before sending messages, use Promise wrappers with { once: true }
**Warning signs:** Tests pass locally but fail in CI, tests fail when run in parallel

### Pitfall 4: Shared State Between Tests
**What goes wrong:** Tests pass in isolation but fail when run together
**Why it happens:** ConnectionManager/RoomManager are singletons or shared across tests
**How to avoid:** Create fresh instances in beforeEach(), cleanup in afterEach()
**Warning signs:** Test order matters, running single test passes but suite fails

### Pitfall 5: Not Cleaning Up Timers and Connections
**What goes wrong:** Tests hang, memory leaks, port conflicts in CI
**Why it happens:** WebSocket connections not closed, timers not cleared, servers not shut down
**How to avoid:** Use afterEach() to cleanup, call manager.cleanup(), server.close(), vi.useRealTimers()
**Warning signs:** Tests timeout, ports already in use, Jest/Vitest doesn't exit cleanly

### Pitfall 6: Testing Implementation Instead of Behavior
**What goes wrong:** Tests break when refactoring even though behavior is correct
**Why it happens:** Tests check internal state, private methods, exact function calls
**How to avoid:** Test public API behavior, user-facing outcomes, avoid testing internal state
**Warning signs:** Refactoring requires rewriting many tests, tests don't catch real bugs

### Pitfall 7: No Coverage Thresholds
**What goes wrong:** Test coverage degrades over time as new code is added without tests
**Why it happens:** No automated enforcement, developers forget to add tests
**How to avoid:** Set coverage thresholds in vitest.config.ts (80% lines/functions, 75% branches), fail build on violations
**Warning signs:** Coverage percentage decreasing in reports, critical code paths untested

## Code Examples

Verified patterns from official sources:

### Vitest Setup File for Mantine (Web App)
```typescript
// apps/web/vitest.setup.ts
// Source: https://mantine.dev/guides/vitest/
import '@testing-library/jest-dom/vitest';

// Mock window.matchMedia (required by Mantine)
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation((query) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
});

// Mock ResizeObserver (required by Mantine)
global.ResizeObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}));

// Mock scrollIntoView (not available in jsdom)
Element.prototype.scrollIntoView = vi.fn();
```

### Web App Vitest Configuration
```typescript
// apps/web/vitest.config.ts
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import { nxViteTsPaths } from '@nx/vite/plugins/nx-tsconfig-paths.plugin';

export default defineConfig({
  plugins: [react(), nxViteTsPaths()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './vitest.setup.ts',
    include: ['src/**/*.spec.{ts,tsx}'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html', 'lcov'],
      include: ['src/**/*.{ts,tsx}'],
      exclude: [
        'src/**/*.spec.{ts,tsx}',
        'src/test-utils/**',
        'src/main.tsx',
        'src/router.tsx',
      ],
      thresholds: {
        lines: 80,
        functions: 80,
        branches: 75,
        statements: 80,
      },
    },
  },
});
```

### API Vitest Configuration
```typescript
// apps/api/vitest.config.ts
import { defineConfig } from 'vitest/config';
import { nxViteTsPaths } from '@nx/vite/plugins/nx-tsconfig-paths.plugin';

export default defineConfig({
  plugins: [nxViteTsPaths()],
  test: {
    globals: true,
    environment: 'node',
    include: ['src/**/*.spec.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html', 'lcov'],
      include: ['src/**/*.ts'],
      exclude: [
        'src/**/*.spec.ts',
        'src/test-utils/**',
        'src/main.ts',
      ],
      thresholds: {
        lines: 80,
        functions: 80,
        branches: 75,
        statements: 80,
      },
    },
  },
});
```

### TestWebSocket Helper Class
```typescript
// apps/api/src/test-utils/test-websocket.ts
// Source: https://github.com/ITenthusiasm/testing-websockets
import WebSocket from 'ws';

export class TestWebSocket extends WebSocket {
  /**
   * Wait until WebSocket reaches target state or timeout
   * @param targetState 'open' | 'closed'
   * @param timeout Milliseconds to wait (default 1000)
   */
  async waitUntil(
    targetState: 'open' | 'closed',
    timeout = 1000
  ): Promise<void> {
    const stateMap = { open: WebSocket.OPEN, closed: WebSocket.CLOSED };
    const readyState = stateMap[targetState];

    // Already in target state
    if (this.readyState === readyState) {
      return Promise.resolve();
    }

    // Wait for state change with timeout
    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        reject(new Error(`Timeout waiting for WebSocket to be ${targetState}`));
      }, timeout);

      const handler = () => {
        clearTimeout(timer);
        resolve();
      };

      if (targetState === 'open') {
        this.once('open', handler);
      } else {
        this.once('close', handler);
      }
    });
  }

  /**
   * Wait for next message with timeout
   * @param timeout Milliseconds to wait (default 1000)
   */
  async waitForMessage<T = any>(timeout = 1000): Promise<T> {
    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        reject(new Error('Timeout waiting for message'));
      }, timeout);

      this.once('message', (data: Buffer) => {
        clearTimeout(timer);
        try {
          resolve(JSON.parse(data.toString()));
        } catch (err) {
          reject(new Error('Failed to parse message JSON'));
        }
      });
    });
  }

  /**
   * Send JSON message
   */
  sendJSON(message: object): void {
    this.send(JSON.stringify(message));
  }
}
```

### Nx Test Scripts in package.json
```json
{
  "scripts": {
    "test": "nx run-many -t test --all",
    "test:api": "nx test api",
    "test:web": "nx test web",
    "test:watch": "nx test api --watch",
    "test:coverage": "nx run-many -t test --all --coverage",
    "test:ui": "nx test web --ui"
  }
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Jest | Vitest | 2021-2022 | 5-10x faster, native ESM, Vite integration |
| c8 coverage | v8 provider | Vitest 3.2.0+ (2024) | Same accuracy as Istanbul, much faster |
| Manual WS test wrappers | Integration tests with TestWebSocket class | 2024 | Simpler, more realistic, fewer mocks |
| Testing implementation | Testing behavior | Ongoing shift | Less brittle tests, easier refactoring |
| Istanbul coverage | v8 coverage | 2024-2025 | 3x faster with equivalent accuracy |
| Separate unit/integration configs | Single vitest.config.ts with patterns | Vitest 1.0+ | Simpler config, better DX |

**Deprecated/outdated:**
- **Jest with Vite:** Jest requires additional transforms for ESM, Vitest is native
- **c8 package:** Replaced by @vitest/coverage-v8 provider
- **vitest-websocket-mock for ws library:** Only supports browser API, use integration tests instead
- **@testing-library/react-hooks:** Merged into @testing-library/react in v13+

## Open Questions

Things that couldn't be fully resolved:

1. **TanStack Router testing setup**
   - What we know: Requires createMemoryHistory and RouterProvider wrapper
   - What's unclear: Official docs redirect (303) prevented full extraction, need to reference community examples
   - Recommendation: Follow pattern from https://github.com/TanStack/router/discussions/655 and create test router factory in test-utils

2. **MSW integration for API mocking**
   - What we know: MSW is recommended for mocking HTTP/WebSocket requests
   - What's unclear: Whether to use MSW for WebSocket mocking or stick with integration tests
   - Recommendation: Start with integration tests for WebSockets (more realistic), consider MSW later for complex scenarios

3. **Coverage threshold levels**
   - What we know: 80% lines/functions, 75% branches is common
   - What's unclear: Whether retroactive coverage of existing code can immediately meet these thresholds
   - Recommendation: Start with lower thresholds (60-70%) for existing code, 80%+ for new code, gradually increase

4. **Nx test caching and distribution**
   - What we know: Nx caches test results, supports distributed execution
   - What's unclear: Optimal CI/CD setup for test parallelization in this specific project
   - Recommendation: Document in testing standards after initial setup, revisit during CI/CD phase

## Sources

### Primary (HIGH confidence)
- [Vitest Official Guide](https://vitest.dev/guide/) - Core configuration and patterns
- [Vitest Coverage Configuration](https://vitest.dev/config/coverage) - Coverage thresholds and providers
- [Vitest Timer Mocking](https://vitest.dev/guide/mocking/timers) - Mock timers API
- [Nx Vite Plugin Documentation](https://nx.dev/docs/technologies/build-tools/vite/introduction) - Nx integration
- [Mantine Vitest Guide](https://mantine.dev/guides/vitest/) - Polyfills and setup
- [Testing Library React Documentation](https://testing-library.com/docs/react-testing-library/intro/) - Component testing
- [Testing WebSockets Repository](https://github.com/ITenthusiasm/testing-websockets) - Integration test patterns

### Secondary (MEDIUM confidence)
- [Writing Integration Tests for WebSocket Servers](https://thomason-isaiah.medium.com/writing-integration-tests-for-websocket-servers-using-jest-and-ws-8e5c61726b2a) - WebSocket testing patterns
- [Testing Zod Schemas](https://stevekinney.com/courses/full-stack-typescript/testing-zod-schema) - Schema validation testing
- [Testing TanStack Query](https://tkdodo.eu/blog/testing-react-query) - Query testing patterns
- [TanStack Query Official Testing Guide](https://tanstack.com/query/v4/docs/react/guides/testing) - Setup and mocking
- [Unit Testing React in Nx Monorepo with Vitest](https://dev.to/shannonlal/unit-testing-react-applications-in-a-nx-nrwl-monorepo-with-vitest-322o) - Nx-specific patterns

### Tertiary (LOW confidence)
- [Vitest WebSocket Mock](https://github.com/akiomik/vitest-websocket-mock) - WebSocket mocking library (limited ws support)
- [MSW WebSocket Discussion](https://github.com/mswjs/msw/discussions/2414) - MSW WebSocket capabilities

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Vitest already installed, official Nx support, battle-tested libraries
- Architecture: HIGH - Official documentation and community patterns well-established
- WebSocket testing: MEDIUM-HIGH - Integration test pattern verified, but project-specific implementation needed
- React testing: HIGH - Mantine guide provides exact setup, Testing Library is standard
- Pitfalls: HIGH - Derived from official docs and community experience

**Research date:** 2026-01-19
**Valid until:** ~45 days (Vitest and Nx evolve steadily, testing patterns stable)

**Notes:**
- Project already has Vitest 4.0 installed - configuration is main task, not installation
- v8 coverage provider recommended over Istanbul (3.2.0+ accuracy improvement)
- Integration tests for WebSocket server preferred over mocks due to ws library limitations
- Retroactive testing will be substantial effort - prioritize critical paths first
