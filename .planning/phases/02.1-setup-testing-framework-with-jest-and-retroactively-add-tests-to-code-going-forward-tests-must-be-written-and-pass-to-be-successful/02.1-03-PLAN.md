---
phase: 02.1-setup-testing-framework
plan: 03
type: execute
wave: 2
depends_on: ["02.1-01"]
files_modified:
  - apps/web/src/lib/websocket.spec.ts
  - apps/web/src/lib/websocket-context.spec.tsx
  - apps/web/src/routes/index.spec.tsx
  - apps/web/src/components/AnimatedBackground.spec.tsx
  - apps/web/src/routes/lobby.spec.tsx
autonomous: true

must_haves:
  truths:
    - "All web app React components have test coverage"
    - "WebSocket client code is tested"
    - "User interactions are verified (form submission, validation)"
    - "Components render without crashing"
    - "All tests pass when running nx test web"
  artifacts:
    - path: "apps/web/src/lib/websocket.spec.ts"
      provides: "ReconnectingWebSocket class tests"
      min_lines: 80
    - path: "apps/web/src/lib/websocket-context.spec.tsx"
      provides: "WebSocket React context tests"
      min_lines: 60
    - path: "apps/web/src/routes/index.spec.tsx"
      provides: "Landing page component tests"
      min_lines: 80
    - path: "apps/web/src/components/AnimatedBackground.spec.tsx"
      provides: "AnimatedBackground component tests"
      min_lines: 30
  key_links:
    - from: "apps/web/src/routes/index.spec.tsx"
      to: "apps/web/src/test-utils/render.tsx"
      via: "uses custom render"
      pattern: "import.*render.*test-utils"
    - from: "apps/web/src/lib/websocket.spec.ts"
      to: "fake timers"
      via: "vi.useFakeTimers for backoff"
      pattern: "vi.useFakeTimers"
    - from: "apps/web/src/lib/websocket-context.spec.tsx"
      to: "WebSocketProvider"
      via: "renders provider with children"
      pattern: "WebSocketProvider"
---

<objective>
Add comprehensive test coverage for web app including WebSocket client, React context, and all UI components.

Purpose: Ensure existing frontend code is tested before building additional features
Output: Full test suite for web app covering WebSocket logic and React components
</objective>

<execution_context>
@/Users/bmcalindin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/bmcalindin/workspace/catan/.planning/PROJECT.md
@/Users/bmcalindin/workspace/catan/.planning/ROADMAP.md
@/Users/bmcalindin/workspace/catan/.planning/STATE.md
@/Users/bmcalindin/workspace/catan/.planning/phases/02.1-setup-testing-framework-with-jest-and-retroactively-add-tests-to-code-going-forward-tests-must-be-written-and-pass-to-be-successful/02.1-RESEARCH.md

# Source files to test
@/Users/bmcalindin/workspace/catan/apps/web/src/lib/websocket.ts
@/Users/bmcalindin/workspace/catan/apps/web/src/lib/websocket-context.tsx
@/Users/bmcalindin/workspace/catan/apps/web/src/routes/index.tsx
@/Users/bmcalindin/workspace/catan/apps/web/src/components/AnimatedBackground.tsx
@/Users/bmcalindin/workspace/catan/apps/web/src/routes/lobby.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Test ReconnectingWebSocket class with fake timers</name>
  <files>
    apps/web/src/lib/websocket.spec.ts
  </files>
  <action>
**WebSocket client tests (websocket.spec.ts):**
Follow RESEARCH.md Pattern 6 "Testing with Mock Timers":

Test connection lifecycle:
- connect() creates WebSocket instance with correct URL
- Successful connection triggers onStatusChange callback with 'connected'
- Connection failure triggers reconnection attempt
- disconnect() closes WebSocket and clears timers

Test exponential backoff with fake timers:
- Use vi.useFakeTimers() in beforeEach, vi.useRealTimers() in afterEach
- First reconnection after 1000ms (base delay)
- Second reconnection after 2000ms (2x backoff)
- Third reconnection after 4000ms (4x backoff)
- Max delay caps at 30000ms
- Jitter adds 0-25% randomness (test range)

Test message handling:
- sendMessage queues messages when disconnected
- sendMessage sends immediately when connected
- Message handlers receive parsed messages
- addMessageHandler and removeMessageHandler work correctly

Test clientId persistence:
- getClientId returns null initially
- setClientId stores ID
- Reconnection includes clientId in handshake payload

Mock WebSocket:
```typescript
// Mock browser WebSocket API
global.WebSocket = vi.fn().mockImplementation((url) => ({
  url,
  readyState: WebSocket.CONNECTING,
  send: vi.fn(),
  close: vi.fn(),
  addEventListener: vi.fn(),
  removeEventListener: vi.fn(),
}));
```

Why this approach: ReconnectingWebSocket encapsulates complex reconnection logic with timers. Fake timers make backoff tests instant and deterministic. Mock WebSocket prevents real network calls in unit tests.
  </action>
  <verify>
```bash
nx test web --run --testNamePattern="ReconnectingWebSocket|websocket.spec"
```

All WebSocket client tests pass.
  </verify>
  <done>
ReconnectingWebSocket class tested with connection lifecycle and backoff logic verified.
  </done>
</task>

<task type="auto">
  <name>Task 2: Test WebSocket React context provider</name>
  <files>
    apps/web/src/lib/websocket-context.spec.tsx
  </files>
  <action>
**WebSocket context tests (websocket-context.spec.tsx):**

Test provider rendering:
- WebSocketProvider renders children without crashing
- useWebSocket hook returns connection object
- useWebSocket throws error when used outside provider

Test connection state:
- Initial status is 'connecting'
- Status updates to 'connected' after successful connection
- Status updates to 'reconnecting' after disconnect

Test message sending:
- sendMessage delegates to ReconnectingWebSocket instance
- Multiple components can call sendMessage

Test message handlers:
- addMessageHandler registers handler function
- Received messages trigger all registered handlers
- removeMessageHandler unregisters handler

Use custom render from test-utils:
```typescript
import { render, screen } from '../test-utils/render';
import { useWebSocket } from './websocket-context';

function TestComponent() {
  const { status, sendMessage } = useWebSocket();
  return <div>Status: {status}</div>;
}
```

Mock ReconnectingWebSocket:
```typescript
vi.mock('./websocket', () => ({
  ReconnectingWebSocket: vi.fn().mockImplementation(() => ({
    connect: vi.fn(),
    disconnect: vi.fn(),
    sendMessage: vi.fn(),
    addMessageHandler: vi.fn(),
    removeMessageHandler: vi.fn(),
    getClientId: vi.fn(),
    setClientId: vi.fn(),
  })),
}));
```

Why this approach: Context tests verify React integration without testing WebSocket logic again (that's in websocket.spec.ts). Mock underlying WebSocket to isolate React behavior. Use custom render to provide necessary providers (Mantine, QueryClient).
  </action>
  <verify>
```bash
nx test web --run --testNamePattern="WebSocket.*context|websocket-context.spec"
```

All context tests pass.
  </verify>
  <done>
WebSocket context provider tested with React integration verified.
  </done>
</task>

<task type="auto">
  <name>Task 3: Test React components with user interactions</name>
  <files>
    apps/web/src/routes/index.spec.tsx
    apps/web/src/components/AnimatedBackground.spec.tsx
    apps/web/src/routes/lobby.spec.tsx
  </files>
  <action>
**Landing page tests (index.spec.tsx):**
Follow RESEARCH.md Pattern 5 "React Component Testing with Mantine + TanStack Router":

Test rendering:
- Renders nickname input field
- Renders Join Lobby button
- Renders character counter (0/30 initially)

Test form validation:
- Nickname too short (< 3 chars) shows error
- Nickname too long (> 30 chars) shows error
- Valid nickname enables submit
- Character counter updates as user types

Test user interactions with @testing-library/user-event:
```typescript
import userEvent from '@testing-library/user-event';

const user = userEvent.setup();
await user.type(input, 'Alice');
await user.click(button);
```

Test WebSocket flow:
- Submit sends SET_NICKNAME message
- NICKNAME_ACCEPTED triggers JOIN_ROOM message
- NICKNAME_REJECTED shows error message
- Mock useWebSocket hook:
```typescript
const mockSendMessage = vi.fn();
vi.mock('../lib/websocket-context', () => ({
  useWebSocket: () => ({
    status: 'connected',
    sendMessage: mockSendMessage,
    addMessageHandler: vi.fn(),
    removeMessageHandler: vi.fn(),
  }),
}));
```

**AnimatedBackground tests (AnimatedBackground.spec.tsx):**
- Renders without crashing
- Contains animated elements (hexagons/dice)
- CSS classes applied correctly

**Lobby placeholder tests (lobby.spec.tsx):**
- Renders placeholder text
- Shows "Lobby" heading
- No runtime errors with Mantine components

Why this approach: Component tests verify user-facing behavior, not implementation details. Use screen queries (getByRole, getByText) for accessibility-friendly selectors. Mock WebSocket context to test component logic in isolation. userEvent simulates real user interactions better than fireEvent.
  </action>
  <verify>
```bash
nx test web --run --testNamePattern="Landing|AnimatedBackground|Lobby"
```

All component tests pass, user interactions verified.
  </verify>
  <done>
All React components tested with rendering, validation, and user interaction scenarios.
  </done>
</task>

</tasks>

<verification>
Run full web test suite with coverage:
```bash
nx test web --coverage
```

Expected:
- All tests pass (WebSocket, context, components)
- Coverage meets thresholds (80% lines/functions, 75% branches)
- Mantine polyfills prevent crashes
- No hanging promises or memory leaks
</verification>

<success_criteria>
1. All web test files created and tests pass
2. ReconnectingWebSocket tested with fake timers
3. React context tested with provider behavior
4. Component tests use custom render with providers
5. User interactions tested with userEvent
6. Coverage thresholds met (80%+ lines/functions)
7. `nx test web` completes successfully
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-setup-testing-framework-with-jest-and-retroactively-add-tests-to-code-going-forward-tests-must-be-written-and-pass-to-be-successful/02.1-03-SUMMARY.md`
</output>
