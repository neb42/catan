---
phase: 07-robber
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - libs/shared/src/schemas/messages.ts
  - libs/shared/src/schemas/game.ts
  - libs/shared/src/index.ts
  - apps/api/src/game/resource-distributor.ts
  - apps/api/src/game/resource-distributor.spec.ts
autonomous: true

must_haves:
  truths:
    - 'Robber message schemas exist and are type-safe'
    - 'GameState includes robber position'
    - 'Hexes with robber do not produce resources'
  artifacts:
    - path: 'libs/shared/src/schemas/messages.ts'
      provides: 'Robber WebSocket message schemas'
      contains: 'DiscardRequiredMessageSchema'
    - path: 'libs/shared/src/schemas/game.ts'
      provides: 'Robber position in game state'
      contains: 'robberHexId'
    - path: 'apps/api/src/game/resource-distributor.ts'
      provides: 'Robber blocking logic'
      contains: 'robberHexId'
  key_links:
    - from: 'apps/api/src/game/resource-distributor.ts'
      to: 'GameState.robberHexId'
      via: 'parameter to distributeResources'
      pattern: 'robberHexId.*string'
---

<objective>
Add robber foundation to shared schemas and implement robber blocking in resource distribution.

Purpose: Establishes type-safe contracts for all robber WebSocket messages and ensures the robber blocks resource production from its hex. This is the foundation that all other robber plans depend on.

Output: Extended message schemas, robber position in GameState, robber-aware resource distributor.
</objective>

<execution_context>
@/Users/bmcalindin/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-robber/07-CONTEXT.md
@.planning/phases/07-robber/07-RESEARCH.md

@libs/shared/src/schemas/messages.ts
@libs/shared/src/schemas/game.ts
@apps/api/src/game/resource-distributor.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add robber message schemas to shared library</name>
  <files>
    libs/shared/src/schemas/messages.ts
    libs/shared/src/index.ts
  </files>
  <action>
Add all robber-related WebSocket message schemas to messages.ts following existing patterns:

**Client → Server messages:**

1. `DiscardSubmittedMessageSchema` - Player submits their discard selection
   - type: 'discard_submitted'
   - resources: ResourceRecordSchema (what player is discarding)

2. `MoveRobberMessageSchema` - Player places robber on hex
   - type: 'move_robber'
   - hexId: z.string() (format: "q,r")

3. `StealTargetMessageSchema` - Player selects victim to steal from
   - type: 'steal_target'
   - victimId: z.string()

**Server → Client messages:**

1. `DiscardRequiredMessageSchema` - Server tells player to discard
   - type: 'discard_required'
   - playerId: z.string()
   - targetCount: z.number() (how many cards to discard)
   - currentResources: ResourceRecordSchema (player's current resources)

2. `DiscardCompletedMessageSchema` - Broadcast when player finishes discarding
   - type: 'discard_completed'
   - playerId: z.string()
   - discarded: ResourceRecordSchema

3. `AllDiscardsCompleteMessageSchema` - All 8+ players have discarded
   - type: 'all_discards_complete'

4. `RobberMoveRequiredMessageSchema` - Tell roller to move robber
   - type: 'robber_move_required'
   - currentHexId: z.string().nullable()

5. `RobberMovedMessageSchema` - Broadcast robber placement
   - type: 'robber_moved'
   - hexId: z.string()
   - playerId: z.string()

6. `StealRequiredMessageSchema` - Tell roller to pick steal victim
   - type: 'steal_required'
   - candidates: z.array(z.object({ playerId: z.string(), nickname: z.string(), cardCount: z.number() }))

7. `StolenMessageSchema` - Broadcast theft result
   - type: 'stolen'
   - thiefId: z.string()
   - victimId: z.string()
   - resourceType: z.enum(['wood', 'brick', 'sheep', 'wheat', 'ore']).nullable() (null if victim had no cards)

8. `NoStealPossibleMessageSchema` - No valid steal targets
   - type: 'no_steal_possible'

Add all schemas to WebSocketMessageSchema discriminated union.
Export all types at bottom of file.
Update libs/shared/src/index.ts to export new schemas if needed.
</action>
<verify>
Run: `npx tsc --noEmit -p libs/shared/tsconfig.json`
TypeScript compiles without errors. All new schemas are properly typed.
</verify>
<done>
All robber message schemas defined, added to discriminated union, and types exported.
</done>
</task>

<task type="auto">
  <name>Task 2: Add robber position to GameState schema</name>
  <files>libs/shared/src/schemas/game.ts</files>
  <action>
Add `robberHexId` field to GameStateSchema:

1. Add to GameStateSchema object:

   ```typescript
   robberHexId: z.string().nullable(), // "q,r" format, null if on desert initially
   ```

2. Place after `settlements` field to keep related game state together.

3. The robber starts on the desert hex at game start. The initial value will be set by GameManager when game starts (not in schema default).

Note: The schema just defines the shape. GameManager will set the initial robber position based on which hex has terrain === 'desert'.
</action>
<verify>
Run: `npx tsc --noEmit -p libs/shared/tsconfig.json`
Schema compiles. GameState type includes robberHexId.
</verify>
<done>
GameState includes robberHexId field for tracking robber position.
</done>
</task>

<task type="auto">
  <name>Task 3: Update resource distributor to respect robber blocking</name>
  <files>
    apps/api/src/game/resource-distributor.ts
    apps/api/src/game/resource-distributor.spec.ts
  </files>
  <action>
Modify distributeResources function to skip hexes with robber:

1. Add `robberHexId` parameter (nullable string):

   ```typescript
   export function distributeResources(
     diceTotal: number,
     hexes: Hex[],
     settlements: Settlement[],
     vertices: Vertex[],
     playerResources: Record<string, PlayerResources>,
     robberHexId: string | null, // NEW PARAMETER
   ): PlayerResourceGrant[];
   ```

2. In matchingHexes filter, add robber check:

   ```typescript
   const matchingHexes = hexes.filter(
     (hex) =>
       hex.number === diceTotal &&
       hex.terrain !== 'desert' &&
       `${hex.q},${hex.r}` !== robberHexId, // Skip robber hex
   );
   ```

3. Add test cases in resource-distributor.spec.ts:
   - Test: Hex with robber produces no resources
   - Test: Adjacent hexes with same number still produce (only blocked hex skipped)
   - Test: robberHexId null means no blocking (backward compat)

4. Update existing tests to pass `null` as robberHexId parameter.
   </action>
   <verify>
   Run: `cd apps/api && npx vitest run resource-distributor.spec.ts`
   All tests pass including new robber blocking tests.
   </verify>
   <done>
   Resource distributor skips hexes with robber. Verified with unit tests.
   </done>
   </task>

</tasks>

<verification>
1. TypeScript compiles across all modified projects: `npx nx run-many -t typecheck -p shared,api`
2. Resource distributor tests pass: `cd apps/api && npx vitest run resource-distributor.spec.ts`
3. Shared library exports all new types: grep for exports in libs/shared/src/index.ts
</verification>

<success_criteria>

- All robber message schemas defined and type-safe
- GameState.robberHexId field exists
- distributeResources skips robber hex
- All unit tests pass
- TypeScript compiles without errors
  </success_criteria>

<output>
After completion, create `.planning/phases/07-robber/07-01-SUMMARY.md`
</output>
