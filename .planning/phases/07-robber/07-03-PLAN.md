---
phase: 07-robber
plan: 03
type: execute
wave: 2
depends_on: ['07-01']
files_modified:
  - apps/api/src/handlers/websocket.ts
autonomous: true

must_haves:
  truths:
    - 'WebSocket handles discard_submitted messages'
    - 'WebSocket handles move_robber messages'
    - 'WebSocket handles steal_target messages'
  artifacts:
    - path: 'apps/api/src/handlers/websocket.ts'
      provides: 'Robber WebSocket message handlers'
      contains: 'discard_submitted'
  key_links:
    - from: 'apps/api/src/handlers/websocket.ts'
      to: 'GameManager.submitDiscard'
      via: 'handler calls method'
      pattern: "gameManager\\.submitDiscard"
    - from: 'apps/api/src/handlers/websocket.ts'
      to: 'GameManager.moveRobber'
      via: 'handler calls method'
      pattern: "gameManager\\.moveRobber"
---

<objective>
Add WebSocket handlers for all robber-related messages to enable real-time robber flow.

Purpose: Wires up client messages to GameManager methods and broadcasts state changes to all players. This enables the multi-step robber flow (discard → move → steal) across all connected clients.

Output: Complete WebSocket handlers for robber flow in websocket.ts.
</objective>

<execution_context>
@/Users/bmcalindin/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-robber/07-CONTEXT.md
@.planning/phases/07-robber/07-RESEARCH.md
@.planning/phases/07-robber/07-01-SUMMARY.md

@apps/api/src/handlers/websocket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend roll_dice handler to trigger robber flow on 7</name>
  <files>apps/api/src/handlers/websocket.ts</files>
  <action>
Modify the existing `roll_dice` case to handle the robber flow when 7 is rolled:

After calling `gameManager.rollDice(playerId)`, check for `robberTriggered`:

```typescript
case 'roll_dice': {
  // ... existing validation ...

  const result = gameManager.rollDice(playerId);

  if (!result.success) {
    sendError(ws, result.error || 'Cannot roll dice');
    return;
  }

  // Broadcast dice result to all
  roomManager.broadcastToRoom(currentRoomId, {
    type: 'dice_rolled',
    dice1: result.dice1,
    dice2: result.dice2,
    total: result.total,
    resourcesDistributed: result.resourcesDistributed,
  });

  // Handle robber triggered (rolled 7)
  if (result.robberTriggered) {
    // Send discard_required to each player who must discard
    for (const { playerId: discardPlayerId, targetCount } of result.mustDiscardPlayers || []) {
      const playerWs = roomManager.getPlayerWebSocket(currentRoomId, discardPlayerId);
      if (playerWs) {
        const playerResources = gameManager.getPlayerResources(discardPlayerId);
        playerWs.send(JSON.stringify({
          type: 'discard_required',
          playerId: discardPlayerId,
          targetCount,
          currentResources: playerResources,
        }));
      }
    }

    // If no discards needed, immediately send robber_move_required
    if (result.proceedToRobberMove) {
      const playerWs = roomManager.getPlayerWebSocket(currentRoomId, playerId);
      if (playerWs) {
        playerWs.send(JSON.stringify({
          type: 'robber_move_required',
          currentHexId: gameManager.getGameState().robberHexId,
        }));
      }
    }
  }
  break;
}
```

Note: You'll need to add `getPlayerWebSocket` method to roomManager if it doesn't exist, or use existing broadcast mechanism with player filtering.
</action>
<verify>
Run: `npx tsc --noEmit -p apps/api/tsconfig.json`
Handler compiles without errors.
</verify>
<done>
roll_dice handler triggers robber flow on 7, sends discard_required or robber_move_required.
</done>
</task>

<task type="auto">
  <name>Task 2: Add discard_submitted handler</name>
  <files>apps/api/src/handlers/websocket.ts</files>
  <action>
Add handler for discard_submitted messages in the message switch:

```typescript
case 'discard_submitted': {
  if (!currentRoomId || !playerId) {
    sendError(ws, 'Not in a room');
    return;
  }

  const gameManager = roomManager.getGameManager(currentRoomId);
  if (!gameManager) {
    sendError(ws, 'Game not started');
    return;
  }

  const result = gameManager.submitDiscard(playerId, message.resources);

  if (!result.success) {
    sendError(ws, result.error || 'Invalid discard');
    return;
  }

  // Broadcast discard completion to all players
  roomManager.broadcastToRoom(currentRoomId, {
    type: 'discard_completed',
    playerId,
    discarded: result.discarded,
  });

  // If all discards done, notify and trigger robber move
  if (result.allDiscardsDone) {
    roomManager.broadcastToRoom(currentRoomId, {
      type: 'all_discards_complete',
    });

    // Send robber_move_required to the player who rolled 7
    const robberMover = gameManager.getRobberMover();
    if (robberMover) {
      const moverWs = roomManager.getPlayerWebSocket(currentRoomId, robberMover);
      if (moverWs) {
        moverWs.send(JSON.stringify({
          type: 'robber_move_required',
          currentHexId: gameManager.getGameState().robberHexId,
        }));
      }
    }
  }
  break;
}
```

  </action>
  <verify>
Handler added to switch statement and compiles.
  </verify>
  <done>
discard_submitted handler validates, applies discard, broadcasts completion, triggers robber move when all done.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add move_robber and steal_target handlers</name>
  <files>apps/api/src/handlers/websocket.ts</files>
  <action>
Add handlers for move_robber and steal_target messages:

**move_robber handler:**

```typescript
case 'move_robber': {
  if (!currentRoomId || !playerId) {
    sendError(ws, 'Not in a room');
    return;
  }

  const gameManager = roomManager.getGameManager(currentRoomId);
  if (!gameManager) {
    sendError(ws, 'Game not started');
    return;
  }

  const result = gameManager.moveRobber(playerId, message.hexId);

  if (!result.success) {
    sendError(ws, result.error || 'Invalid robber placement');
    return;
  }

  // Broadcast robber moved to all
  roomManager.broadcastToRoom(currentRoomId, {
    type: 'robber_moved',
    hexId: message.hexId,
    playerId,
  });

  // Handle steal phase
  if (result.noStealPossible) {
    // Broadcast no steal possible
    roomManager.broadcastToRoom(currentRoomId, {
      type: 'no_steal_possible',
    });
  } else if (result.autoStolen) {
    // Single victim - auto-steal already executed
    roomManager.broadcastToRoom(currentRoomId, {
      type: 'stolen',
      thiefId: playerId,
      victimId: result.autoStolen.victimId,
      resourceType: result.autoStolen.resourceType,
    });
  } else if (result.stealCandidates && result.stealCandidates.length > 1) {
    // Multiple candidates - send steal_required to thief
    // Get nicknames for candidates
    const room = roomManager.getRoom(currentRoomId);
    const candidatesWithNicknames = result.stealCandidates.map(c => ({
      playerId: c.playerId,
      nickname: room?.players.find(p => p.id === c.playerId)?.nickname || 'Unknown',
      cardCount: c.cardCount,
    }));

    ws.send(JSON.stringify({
      type: 'steal_required',
      candidates: candidatesWithNicknames,
    }));
  }
  break;
}
```

**steal_target handler:**

```typescript
case 'steal_target': {
  if (!currentRoomId || !playerId) {
    sendError(ws, 'Not in a room');
    return;
  }

  const gameManager = roomManager.getGameManager(currentRoomId);
  if (!gameManager) {
    sendError(ws, 'Game not started');
    return;
  }

  const result = gameManager.stealFrom(playerId, message.victimId);

  if (!result.success) {
    sendError(ws, result.error || 'Invalid steal target');
    return;
  }

  // Broadcast theft result
  roomManager.broadcastToRoom(currentRoomId, {
    type: 'stolen',
    thiefId: playerId,
    victimId: message.victimId,
    resourceType: result.resourceType,
  });
  break;
}
```

**Also add helper method to RoomManager if needed:**
If `getPlayerWebSocket` doesn't exist, add it to RoomManager:

```typescript
getPlayerWebSocket(roomId: string, playerId: string): WebSocket | undefined {
  // Implementation depends on how you track player connections
  // May need to store WebSocket refs in a map keyed by playerId
}
```

Alternative: Use targetted broadcast or store player->ws mapping.
</action>
<verify>
Run: `npx tsc --noEmit -p apps/api/tsconfig.json`
All handlers compile. No type errors.
</verify>
<done>
move_robber handler moves robber, broadcasts, and triggers steal flow.
steal_target handler executes and broadcasts theft.
</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx nx typecheck api`
2. All handlers present in switch statement
3. Each handler follows pattern: validate → call GameManager → broadcast result
</verification>

<success_criteria>

- roll_dice triggers robber flow on 7
- discard_submitted validates and broadcasts
- move_robber places robber and triggers steal
- steal_target executes theft and broadcasts
- All messages broadcast to room appropriately
  </success_criteria>

<output>
After completion, create `.planning/phases/07-robber/07-03-SUMMARY.md`
</output>
