---
phase: 07-robber
plan: 02
type: execute
wave: 2
depends_on: ['07-01']
files_modified:
  - apps/api/src/game/GameManager.ts
  - apps/api/src/game/robber-logic.ts
autonomous: true

must_haves:
  truths:
    - 'GameManager can process discard submissions'
    - 'GameManager can move robber to any land hex'
    - 'GameManager can execute random steal from adjacent player'
  artifacts:
    - path: 'apps/api/src/game/robber-logic.ts'
      provides: 'Robber validation and helper functions'
      exports: ['validateDiscard', 'getStealCandidates', 'executeSteal']
    - path: 'apps/api/src/game/GameManager.ts'
      provides: 'Robber state management methods'
      contains: 'submitDiscard'
  key_links:
    - from: 'apps/api/src/game/GameManager.ts'
      to: 'apps/api/src/game/robber-logic.ts'
      via: 'import and use validators'
      pattern: 'import.*robber-logic'
---

<objective>
Implement GameManager methods for the complete robber flow: discard, move, and steal.

Purpose: Provides the core server-side logic for handling all robber mechanics triggered by rolling a 7. This is the brain of the robber system that WebSocket handlers will call.

Output: robber-logic.ts with validation/helper functions, GameManager with discard/move/steal methods.
</objective>

<execution_context>
@/Users/bmcalindin/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-robber/07-CONTEXT.md
@.planning/phases/07-robber/07-RESEARCH.md
@.planning/phases/07-robber/07-01-SUMMARY.md

@apps/api/src/game/GameManager.ts
@libs/shared/src/schemas/game.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create robber-logic.ts with validation and helper functions</name>
  <files>apps/api/src/game/robber-logic.ts</files>
  <action>
Create new file with robber validation and helper functions:

```typescript
import {
  Hex,
  PlayerResources,
  ResourceType,
  Settlement,
  Vertex,
} from '@catan/shared';

/**
 * Check if player must discard (8+ cards in hand)
 */
export function mustDiscard(resources: PlayerResources): boolean {
  const total = Object.values(resources).reduce((sum, count) => sum + count, 0);
  return total >= 8;
}

/**
 * Calculate how many cards player must discard (half rounded down)
 */
export function getDiscardTarget(resources: PlayerResources): number {
  const total = Object.values(resources).reduce((sum, count) => sum + count, 0);
  return Math.floor(total / 2);
}

/**
 * Validate discard submission matches target and player has resources
 */
export function validateDiscard(
  submitted: Partial<Record<ResourceType, number>>,
  currentResources: PlayerResources,
  targetCount: number,
): { valid: boolean; error?: string } {
  // Check submitted total equals target
  const submittedTotal = Object.values(submitted).reduce(
    (sum, count) => sum + (count ?? 0),
    0,
  );
  if (submittedTotal !== targetCount) {
    return {
      valid: false,
      error: `Must discard exactly ${targetCount} cards, got ${submittedTotal}`,
    };
  }

  // Check player has each resource being discarded
  for (const [resource, count] of Object.entries(submitted)) {
    const resType = resource as ResourceType;
    const discarding = count ?? 0;
    const has = currentResources[resType] ?? 0;
    if (discarding > has) {
      return {
        valid: false,
        error: `Cannot discard ${discarding} ${resType}, only have ${has}`,
      };
    }
  }

  return { valid: true };
}

/**
 * Get list of players adjacent to a hex who can be stolen from
 */
export function getStealCandidates(
  hexId: string,
  settlements: Settlement[],
  vertices: Vertex[],
  playerResources: Record<string, PlayerResources>,
  excludePlayerId: string, // The thief (can't steal from self)
): Array<{ playerId: string; cardCount: number }> {
  // Find vertices adjacent to this hex
  const adjacentVertexIds = vertices
    .filter((v) => v.adjacentHexes.includes(hexId))
    .map((v) => v.id);

  // Find settlements on those vertices (excluding thief's own)
  const adjacentSettlements = settlements.filter(
    (s) =>
      adjacentVertexIds.includes(s.vertexId) && s.playerId !== excludePlayerId,
  );

  // Get unique players with card counts
  const playerMap = new Map<string, number>();
  for (const settlement of adjacentSettlements) {
    if (!playerMap.has(settlement.playerId)) {
      const resources = playerResources[settlement.playerId] ?? {
        wood: 0,
        brick: 0,
        sheep: 0,
        wheat: 0,
        ore: 0,
      };
      const cardCount = Object.values(resources).reduce((sum, c) => sum + c, 0);
      playerMap.set(settlement.playerId, cardCount);
    }
  }

  // Filter to only players with cards
  return Array.from(playerMap.entries())
    .filter(([, cardCount]) => cardCount > 0)
    .map(([playerId, cardCount]) => ({ playerId, cardCount }));
}

/**
 * Execute steal: pick random resource from victim
 */
export function executeSteal(
  victimResources: PlayerResources,
): ResourceType | null {
  // Build array of resource types weighted by count
  const pool: ResourceType[] = [];
  for (const [resource, count] of Object.entries(victimResources)) {
    for (let i = 0; i < count; i++) {
      pool.push(resource as ResourceType);
    }
  }

  if (pool.length === 0) {
    return null; // Victim has no cards
  }

  // Pick random
  const randomIndex = Math.floor(Math.random() * pool.length);
  return pool[randomIndex];
}

/**
 * Validate robber can be placed on hex (must be land, can be anywhere including current position)
 */
export function validateRobberPlacement(
  hexId: string,
  hexes: Hex[],
): { valid: boolean; error?: string } {
  const hex = hexes.find((h) => `${h.q},${h.r}` === hexId);

  if (!hex) {
    return { valid: false, error: 'Invalid hex' };
  }

  // Robber can be placed on any land hex including desert and current position
  // Per ROBBER-02 and ROBBER-04: any land hex, including same position
  const landTerrains = [
    'forest',
    'hills',
    'pasture',
    'fields',
    'mountains',
    'desert',
  ];
  if (!landTerrains.includes(hex.terrain)) {
    return { valid: false, error: 'Robber must be placed on land hex' };
  }

  return { valid: true };
}
```

  </action>
  <verify>
Run: `npx tsc --noEmit -p apps/api/tsconfig.json`
File compiles without errors.
  </verify>
  <done>
robber-logic.ts created with all validation and helper functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add robber state and methods to GameManager</name>
  <files>apps/api/src/game/GameManager.ts</files>
  <action>
Extend GameManager with robber state tracking and methods:

**1. Add robber state properties:**

```typescript
// Add to class properties
private pendingDiscards: Map<string, number> = new Map(); // playerId -> targetCount
private robberPhase: 'none' | 'discarding' | 'moving' | 'stealing' = 'none';
private robberMover: string | null = null; // playerId who rolled 7
```

**2. Add import for robber-logic:**

```typescript
import {
  mustDiscard,
  getDiscardTarget,
  validateDiscard,
  getStealCandidates,
  executeSteal,
  validateRobberPlacement,
} from './robber-logic';
```

**3. Modify rollDice to trigger robber flow on 7:**
After generating dice but BEFORE distributing resources, check for 7:

```typescript
if (total === 7) {
  // Find players who must discard (8+ cards)
  const mustDiscardPlayers: Array<{ playerId: string; targetCount: number }> =
    [];
  for (const [playerId, resources] of Object.entries(
    this.gameState.playerResources,
  )) {
    if (mustDiscard(resources)) {
      const target = getDiscardTarget(resources);
      this.pendingDiscards.set(playerId, target);
      mustDiscardPlayers.push({ playerId, targetCount: target });
    }
  }

  this.robberMover = playerId;

  if (mustDiscardPlayers.length > 0) {
    this.robberPhase = 'discarding';
  } else {
    this.robberPhase = 'moving';
  }

  // Return special result for 7 - no resources distributed
  return {
    success: true,
    dice1,
    dice2,
    total,
    resourcesDistributed: [], // No resources on 7
    robberTriggered: true,
    mustDiscardPlayers,
    proceedToRobberMove: mustDiscardPlayers.length === 0,
  };
}
```

**4. Add submitDiscard method:**

```typescript
submitDiscard(playerId: string, resources: Partial<Record<ResourceType, number>>): {
  success: boolean;
  error?: string;
  allDiscardsDone?: boolean;
  discarded?: Partial<Record<ResourceType, number>>;
} {
  // Check player needs to discard
  const targetCount = this.pendingDiscards.get(playerId);
  if (targetCount === undefined) {
    return { success: false, error: 'You do not need to discard' };
  }

  // Validate discard
  const currentResources = this.gameState.playerResources[playerId];
  const validation = validateDiscard(resources, currentResources, targetCount);
  if (!validation.valid) {
    return { success: false, error: validation.error };
  }

  // Apply discard - deduct resources
  for (const [resource, count] of Object.entries(resources)) {
    const resType = resource as ResourceType;
    const discarding = count ?? 0;
    if (discarding > 0) {
      this.gameState.playerResources[playerId][resType] -= discarding;
    }
  }

  // Remove from pending
  this.pendingDiscards.delete(playerId);

  // Check if all done
  const allDone = this.pendingDiscards.size === 0;
  if (allDone) {
    this.robberPhase = 'moving';
  }

  return { success: true, allDiscardsDone: allDone, discarded: resources };
}
```

**5. Add moveRobber method:**

```typescript
moveRobber(playerId: string, hexId: string): {
  success: boolean;
  error?: string;
  stealCandidates?: Array<{ playerId: string; cardCount: number }>;
  noStealPossible?: boolean;
} {
  // Verify it's robber mover's turn
  if (playerId !== this.robberMover) {
    return { success: false, error: 'Not your turn to move robber' };
  }

  if (this.robberPhase !== 'moving') {
    return { success: false, error: 'Not in robber move phase' };
  }

  // Validate placement
  const validation = validateRobberPlacement(hexId, this.gameState.board.hexes);
  if (!validation.valid) {
    return { success: false, error: validation.error };
  }

  // Move robber
  this.gameState.robberHexId = hexId;

  // Get steal candidates
  const candidates = getStealCandidates(
    hexId,
    this.gameState.settlements,
    this.gameState.board.vertices,
    this.gameState.playerResources,
    playerId
  );

  if (candidates.length === 0) {
    // No one to steal from - robber phase complete
    this.robberPhase = 'none';
    this.robberMover = null;
    return { success: true, noStealPossible: true };
  }

  if (candidates.length === 1) {
    // Auto-steal from single victim
    const victim = candidates[0];
    const stolen = this.executeStealInternal(playerId, victim.playerId);
    this.robberPhase = 'none';
    this.robberMover = null;
    return {
      success: true,
      stealCandidates: candidates,
      autoStolen: { victimId: victim.playerId, resourceType: stolen }
    };
  }

  // Multiple candidates - need player to choose
  this.robberPhase = 'stealing';
  return { success: true, stealCandidates: candidates };
}
```

**6. Add stealFrom method:**

```typescript
stealFrom(playerId: string, victimId: string): {
  success: boolean;
  error?: string;
  resourceType?: ResourceType | null;
} {
  if (playerId !== this.robberMover) {
    return { success: false, error: 'Not your turn to steal' };
  }

  if (this.robberPhase !== 'stealing') {
    return { success: false, error: 'Not in steal phase' };
  }

  // Validate victim is adjacent to robber
  const candidates = getStealCandidates(
    this.gameState.robberHexId!,
    this.gameState.settlements,
    this.gameState.board.vertices,
    this.gameState.playerResources,
    playerId
  );

  if (!candidates.some(c => c.playerId === victimId)) {
    return { success: false, error: 'Invalid steal target' };
  }

  const stolen = this.executeStealInternal(playerId, victimId);
  this.robberPhase = 'none';
  this.robberMover = null;

  return { success: true, resourceType: stolen };
}

private executeStealInternal(thiefId: string, victimId: string): ResourceType | null {
  const victimResources = this.gameState.playerResources[victimId];
  const stolen = executeSteal(victimResources);

  if (stolen) {
    // Transfer resource
    this.gameState.playerResources[victimId][stolen] -= 1;
    this.gameState.playerResources[thiefId][stolen] += 1;
  }

  return stolen;
}
```

**7. Add getter methods:**

```typescript
getPendingDiscards(): Map<string, number> {
  return new Map(this.pendingDiscards);
}

getRobberPhase(): string {
  return this.robberPhase;
}

getRobberMover(): string | null {
  return this.robberMover;
}
```

**8. Initialize robber position in startGame:**
When starting game, find desert hex and set initial robber position:

```typescript
// In startGame or wherever board is initialized:
const desertHex = this.gameState.board.hexes.find(
  (h) => h.terrain === 'desert',
);
if (desertHex) {
  this.gameState.robberHexId = `${desertHex.q},${desertHex.r}`;
} else {
  this.gameState.robberHexId = null;
}
```

**9. Update rollDice to pass robberHexId to distributeResources:**
For non-7 rolls, pass robberHexId to block that hex:

```typescript
const resourcesDistributed = distributeResources(
  total,
  this.gameState.board.hexes,
  this.gameState.settlements,
  this.gameState.board.vertices,
  this.gameState.playerResources,
  this.gameState.robberHexId, // Pass robber position
);
```

  </action>
  <verify>
Run: `npx tsc --noEmit -p apps/api/tsconfig.json`
GameManager compiles. All new methods properly typed.
  </verify>
  <done>
GameManager has complete robber flow: submitDiscard, moveRobber, stealFrom methods.
Robber phase state machine tracks discarding → moving → stealing → none.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx nx typecheck api`
2. Existing tests still pass: `cd apps/api && npx vitest run`
3. robber-logic.ts exports all functions
4. GameManager has all new methods
</verification>

<success_criteria>

- robber-logic.ts created with validation functions
- GameManager tracks robber phase state
- submitDiscard validates and applies discards
- moveRobber validates and updates robber position
- stealFrom executes random steal
- Robber position initialized on desert at game start
  </success_criteria>

<output>
After completion, create `.planning/phases/07-robber/07-02-SUMMARY.md`
</output>
