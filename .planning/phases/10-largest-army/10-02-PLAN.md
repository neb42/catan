---
phase: 10-largest-army
plan: 02
type: execute
wave: 2
depends_on: ['10-01']
files_modified:
  - libs/shared/src/schemas/messages.ts
  - apps/api/src/handlers/websocket.ts
  - apps/web/src/stores/gameStore.ts
  - apps/web/src/components/Lobby.tsx
autonomous: true

must_haves:
  truths:
    - 'largest_army_updated message broadcast on transfer'
    - 'Frontend state updates when message received'
    - 'Knight counts available in frontend store'
  artifacts:
    - path: 'libs/shared/src/schemas/messages.ts'
      provides: 'LargestArmyUpdatedMessageSchema'
      contains: 'largest_army_updated'
    - path: 'apps/api/src/handlers/websocket.ts'
      provides: 'broadcastLargestArmyIfTransferred function'
      contains: 'largest_army_updated'
    - path: 'apps/web/src/stores/gameStore.ts'
      provides: 'LargestArmySlice and selectors'
      contains: 'largestArmyHolderId'
  key_links:
    - from: 'apps/api/src/handlers/websocket.ts'
      to: 'broadcastLargestArmyIfTransferred'
      via: 'called after knight plays'
      pattern: 'broadcastLargestArmyIfTransferred'
    - from: 'apps/web/src/components/Lobby.tsx'
      to: 'gameStore.setLargestArmyState'
      via: 'WebSocket message handler'
      pattern: "case 'largest_army_updated'"
---

<objective>
Add WebSocket message schema and handlers for largest army updates, integrate with frontend state.

Purpose: Enable real-time broadcast of largest army changes to all clients
Output: Message schema, server broadcast function, frontend state slice and handlers
</objective>

<execution_context>
@/Users/bmcalindin/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-largest-army/10-01-SUMMARY.md

Key reference files:
@libs/shared/src/schemas/messages.ts — Add LargestArmyUpdatedMessageSchema (mirror LongestRoadUpdatedMessageSchema)
@apps/api/src/handlers/websocket.ts — Add broadcastLargestArmyIfTransferred (mirror broadcastLongestRoadIfTransferred)
@apps/web/src/stores/gameStore.ts — Add LargestArmySlice (mirror LongestRoadSlice)
@apps/web/src/components/Lobby.tsx — Add 'largest_army_updated' handler (mirror 'longest_road_updated')
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add LargestArmyUpdatedMessageSchema to messages.ts</name>
  <files>
    libs/shared/src/schemas/messages.ts
  </files>
  <action>
1. Add schema after LongestRoadUpdatedMessageSchema (around line 472):

```typescript
// Largest Army Messages - Server -> Client
export const LargestArmyUpdatedMessageSchema = z.object({
  type: z.literal('largest_army_updated'),
  holderId: z.string().nullable(),
  holderKnights: z.number(),
  playerKnightCounts: z.record(z.string(), z.number()), // All players' knight counts
  transferredFrom: z.string().nullable(), // Previous holder if transferred
});
```

2. Add to WebSocketMessageSchema discriminated union array (around line 550, after LongestRoadUpdatedMessageSchema):

```typescript
  LargestArmyUpdatedMessageSchema,
```

  </action>
  <verify>
Run `cd libs/shared && npm run build` - builds without errors.
Check that 'largest_army_updated' is a valid message type.
  </verify>
  <done>
LargestArmyUpdatedMessageSchema exists and is part of WebSocketMessageSchema union
  </done>
</task>

<task type="auto">
  <name>Task 2: Add broadcast function and integrate with knight plays in websocket.ts</name>
  <files>
    apps/api/src/handlers/websocket.ts
  </files>
  <action>
1. Import LargestArmyResult at top (around line 17, after LongestRoadResult import):

```typescript
import { LargestArmyResult } from '../game/largest-army-logic';
```

2. Add broadcastLargestArmyIfTransferred function after broadcastLongestRoadIfTransferred (around line 96):

```typescript
/**
 * Broadcast largest_army_updated if a transfer occurred.
 */
function broadcastLargestArmyIfTransferred(
  roomManager: RoomManager,
  roomId: string,
  result: LargestArmyResult | undefined,
): void {
  if (!result?.transferred) return;

  roomManager.broadcastToRoom(roomId, {
    type: 'largest_army_updated',
    holderId: result.newState.holderId,
    holderKnights: result.newState.knights,
    playerKnightCounts: result.playerKnightCounts,
    transferredFrom: result.fromPlayerId ?? null,
  });
}
```

3. Find the 'play_dev_card' handler for knight cards. In the knight card handling section (case 'knight' block starting at line 1071), locate the dev_card_played broadcast (around line 1092). **Call after knight card play in websocket.ts case 'knight' block (after line 1092 dev_card_played broadcast)**. Add immediately after:

```typescript
// Broadcast largest army if transferred (add after line 1092, before robber_move_required)
broadcastLargestArmyIfTransferred(
  roomManager,
  currentRoomId,
  result.largestArmyResult,
);
```

Note: You'll need to ensure GameManager.playKnight() returns largestArmyResult in its return object. Check the return type and update if needed.
</action>
<verify>
Run `cd apps/api && npm run build` - compiles without errors.
Grep for 'largest_army_updated' in websocket.ts to confirm broadcast is wired.
</verify>
<done>
broadcastLargestArmyIfTransferred function exists and is called after knight plays
</done>
</task>

<task type="auto">
  <name>Task 3: Add largestArmyHolderId state field and selector, add frontend handler in Lobby.tsx</name>
  <files>
    apps/web/src/stores/gameStore.ts
    apps/web/src/components/Lobby.tsx
  </files>
  <action>
**In gameStore.ts:**

Note: `knightsPlayed` state already exists in gameStore (as a Map or Record tracking knight counts per player). We only need to add:

1. `largestArmyHolderId` state field
2. `largestArmyKnights` state field
3. `useLargestArmyHolder` selector
4. `setLargestArmyState` action

**Do NOT create a full new slice** - just add these fields to existing GameStore interface and implementation.

1. Add state fields for largest army holder after existing longestRoad fields (around line 130):

```typescript
// Largest army state (knightsPlayed already exists)
largestArmyHolderId: string | null;
largestArmyKnights: number;
```

2. Add to GameStore interface (around line 165):

Ensure GameStore includes the new fields in its type definition.

3. Add initial state in create() call (around line 365, after longestRoad state):

```typescript
// Largest army initial state
largestArmyHolderId: null,
largestArmyKnights: 0,
```

4. Add setLargestArmyState action in GameStore interface (around line 283, after setLongestRoadState):

```typescript
// Largest army actions
setLargestArmyState: (state: {
  holderId: string | null;
  holderKnights: number;
  playerKnightCounts: Record<string, number>;
}) => void;
```

5. Implement the action (around line 617, after setLongestRoadState implementation):

```typescript
// Largest army actions
setLargestArmyState: (state) =>
  set({
    largestArmyHolderId: state.holderId,
    largestArmyKnights: state.holderKnights,
    // Update knightsPlayed map from playerKnightCounts
    knightsPlayed: state.playerKnightCounts,
  }),
```

6. Add selector hook at end of file (after useLongestRoadHolder):

```typescript
// Largest army state selector hook
export const useLargestArmyHolder = () =>
  useGameStore((s) => s.largestArmyHolderId);
```

Note: `usePlayerKnightCounts` is not needed as `knightsPlayed` already provides this via existing selector.

**In Lobby.tsx:**

1. Add handler for 'largest_army_updated' after 'longest_road_updated' case (around line 856):

```typescript
// ============================================================================
// LARGEST ARMY HANDLERS
// ============================================================================

case 'largest_army_updated': {
  const gameStore = useGameStore.getState();
  const { holderId, holderKnights, playerKnightCounts, transferredFrom } =
    message;

  // Update state
  gameStore.setLargestArmyState({
    holderId,
    holderKnights,
    playerKnightCounts,
  });

  // Toast notification per phase context: "[Player] earned Largest Army (X knights)" format
  if (holderId) {
    const toPlayer = room?.players.find((p) => p.id === holderId);
    if (toPlayer) {
      // Required format from phase context: "[Player] earned Largest Army (X knights)"
      showGameNotification(
        `${toPlayer.nickname} earned Largest Army (${holderKnights} knights)`,
        'success',
      );
    }
  } else if (transferredFrom) {
    // Award lost (no new holder)
    const fromPlayer = room?.players.find((p) => p.id === transferredFrom);
    showGameNotification(
      `${fromPlayer?.nickname} loses Largest Army!`,
      'warning',
    );
  }
  break;
}
```

  </action>
  <verify>
Run `cd apps/web && npm run build` - builds without errors.
Check gameStore.ts exports useLargestArmyHolder hook.
Check Lobby.tsx has 'largest_army_updated' case.
  </verify>
  <done>
Frontend state slice exists, WebSocket handler updates state and shows toast on transfers
  </done>
</task>

</tasks>

<verification>
1. Run `cd libs/shared && npm run build` - schema builds
2. Run `cd apps/api && npm run build` - API builds with new broadcast function
3. Run `cd apps/web && npm run build` - frontend builds with new state
4. Grep for 'largest_army' across codebase confirms wiring:
   - messages.ts: schema exists
   - websocket.ts: broadcast function exists
   - gameStore.ts: slice and selectors exist
   - Lobby.tsx: handler exists
</verification>

<success_criteria>

- LargestArmyUpdatedMessageSchema in shared/messages.ts
- broadcastLargestArmyIfTransferred in websocket.ts called after knight plays
- LargestArmySlice in gameStore.ts with setLargestArmyState action
- 'largest_army_updated' handler in Lobby.tsx with toast notifications
  </success_criteria>

<output>
After completion, create `.planning/phases/10-largest-army/10-02-SUMMARY.md`
</output>
