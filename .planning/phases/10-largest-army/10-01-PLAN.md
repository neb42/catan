---
phase: 10-largest-army
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - apps/api/src/game/largest-army-logic.ts
  - apps/api/src/game/largest-army-logic.test.ts
  - libs/shared/src/schemas/game.ts
  - apps/api/src/game/GameManager.ts
autonomous: true

must_haves:
  truths:
    - 'Largest army requires minimum 3 knights played'
    - 'Ties favor current holder (challenger must EXCEED)'
    - 'Award transfers when surpassed'
  artifacts:
    - path: 'apps/api/src/game/largest-army-logic.ts'
      provides: 'recalculateLargestArmy pure function'
      exports: ['recalculateLargestArmy', 'LargestArmyResult']
    - path: 'apps/api/src/game/largest-army-logic.test.ts'
      provides: 'TDD test suite for edge cases'
      contains: "describe('recalculateLargestArmy'"
    - path: 'libs/shared/src/schemas/game.ts'
      provides: 'GameState schema with largest army fields'
      contains: 'largestArmyHolderId'
  key_links:
    - from: 'apps/api/src/game/GameManager.ts'
      to: 'apps/api/src/game/largest-army-logic.ts'
      via: 'import and call in updateLargestArmy()'
      pattern: 'recalculateLargestArmy'
---

<objective>
Create largest army calculation logic with TDD approach and add state fields to GameState schema.

Purpose: Enable tracking of largest army award (2 VP) based on knight cards played
Output: Pure function for award calculation, GameState fields, GameManager integration
</objective>

<execution_context>
@/Users/bmcalindin/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key reference files:
@apps/api/src/game/longest-road-logic.ts — Mirror this pattern exactly
@libs/shared/src/schemas/game.ts — Add parallel fields to GameStateSchema
@apps/api/src/game/GameManager.ts — Add updateLargestArmy() method
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create largest-army-logic.ts with TDD tests</name>
  <files>
    apps/api/src/game/largest-army-logic.ts
    apps/api/src/game/largest-army-logic.test.ts
  </files>
  <action>
RED PHASE: Create test file first with failing tests:

```typescript
// apps/api/src/game/largest-army-logic.test.ts
import { describe, it, expect } from 'vitest';
import { recalculateLargestArmy } from './largest-army-logic';

describe('recalculateLargestArmy', () => {
  const playerIds = ['p1', 'p2', 'p3', 'p4'];

  it('returns no holder when no one has 3+ knights', () => {
    const knightCounts = { p1: 2, p2: 1, p3: 0, p4: 0 };
    const currentState = { holderId: null, knights: 0 };

    const result = recalculateLargestArmy(
      knightCounts,
      playerIds,
      currentState,
    );

    expect(result.newState.holderId).toBeNull();
    expect(result.newState.knights).toBe(0);
    expect(result.transferred).toBe(false);
  });

  it('awards to first player reaching exactly 3 knights', () => {
    const knightCounts = { p1: 3, p2: 2, p3: 0, p4: 0 };
    const currentState = { holderId: null, knights: 0 };

    const result = recalculateLargestArmy(
      knightCounts,
      playerIds,
      currentState,
    );

    expect(result.newState.holderId).toBe('p1');
    expect(result.newState.knights).toBe(3);
    expect(result.transferred).toBe(true);
    expect(result.toPlayerId).toBe('p1');
  });

  it('current holder keeps on tie', () => {
    const knightCounts = { p1: 3, p2: 3, p3: 0, p4: 0 };
    const currentState = { holderId: 'p1', knights: 3 };

    const result = recalculateLargestArmy(
      knightCounts,
      playerIds,
      currentState,
    );

    expect(result.newState.holderId).toBe('p1');
    expect(result.transferred).toBe(false);
  });

  it('transfers when challenger exceeds current holder', () => {
    const knightCounts = { p1: 3, p2: 4, p3: 0, p4: 0 };
    const currentState = { holderId: 'p1', knights: 3 };

    const result = recalculateLargestArmy(
      knightCounts,
      playerIds,
      currentState,
    );

    expect(result.newState.holderId).toBe('p2');
    expect(result.newState.knights).toBe(4);
    expect(result.transferred).toBe(true);
    expect(result.fromPlayerId).toBe('p1');
    expect(result.toPlayerId).toBe('p2');
  });

  it('holder loses if they drop below minimum and no one else qualifies', () => {
    // Edge case: holder at 3, but their count is reduced (shouldn't happen in practice)
    // Test that if the max is below 3, no one holds
    const knightCounts = { p1: 2, p2: 2, p3: 0, p4: 0 };
    const currentState = { holderId: 'p1', knights: 3 };

    const result = recalculateLargestArmy(
      knightCounts,
      playerIds,
      currentState,
    );

    expect(result.newState.holderId).toBeNull();
    expect(result.transferred).toBe(true);
    expect(result.fromPlayerId).toBe('p1');
  });

  it('does not transfer if challenger only matches', () => {
    const knightCounts = { p1: 4, p2: 4, p3: 0, p4: 0 };
    const currentState = { holderId: 'p1', knights: 4 };

    const result = recalculateLargestArmy(
      knightCounts,
      playerIds,
      currentState,
    );

    expect(result.newState.holderId).toBe('p1');
    expect(result.transferred).toBe(false);
  });
});
```

GREEN PHASE: Implement the logic:

```typescript
// apps/api/src/game/largest-army-logic.ts
const MIN_KNIGHTS_FOR_ARMY = 3;

interface LargestArmyState {
  holderId: string | null;
  knights: number;
}

export interface LargestArmyResult {
  newState: LargestArmyState;
  playerKnightCounts: Record<string, number>;
  transferred: boolean;
  fromPlayerId?: string;
  toPlayerId?: string;
}

/**
 * Recalculate largest army for all players and determine award holder.
 *
 * Rules:
 * - Minimum 3 knights to qualify
 * - New player must EXCEED current holder's count (not match)
 * - Ties favor current holder
 */
export function recalculateLargestArmy(
  knightCounts: Record<string, number>,
  playerIds: string[],
  currentState: LargestArmyState,
): LargestArmyResult {
  // Calculate max across all players
  const playerKnightCounts: Record<string, number> = {};
  for (const playerId of playerIds) {
    playerKnightCounts[playerId] = knightCounts[playerId] || 0;
  }

  const maxKnights = Math.max(...Object.values(playerKnightCounts), 0);

  // No one qualifies (< 3)
  if (maxKnights < MIN_KNIGHTS_FOR_ARMY) {
    if (currentState.holderId) {
      return {
        newState: { holderId: null, knights: 0 },
        playerKnightCounts,
        transferred: true,
        fromPlayerId: currentState.holderId,
      };
    }
    return {
      newState: { holderId: null, knights: 0 },
      playerKnightCounts,
      transferred: false,
    };
  }

  // Find all players at max
  const playersAtMax = Object.entries(playerKnightCounts)
    .filter(([_, count]) => count === maxKnights)
    .map(([id]) => id);

  // Multiple players tied at max
  if (playersAtMax.length > 1) {
    // Current holder keeps if still at max
    if (currentState.holderId && playersAtMax.includes(currentState.holderId)) {
      return {
        newState: { holderId: currentState.holderId, knights: maxKnights },
        playerKnightCounts,
        transferred: false,
      };
    }
    // Tie with no current holder at max - no one gets it
    if (currentState.holderId) {
      return {
        newState: { holderId: null, knights: 0 },
        playerKnightCounts,
        transferred: true,
        fromPlayerId: currentState.holderId,
      };
    }
    return {
      newState: { holderId: null, knights: 0 },
      playerKnightCounts,
      transferred: false,
    };
  }

  // Single player has max
  const winnerId = playersAtMax[0];

  // New player must exceed (not match) current holder
  if (currentState.holderId && currentState.holderId !== winnerId) {
    if (maxKnights <= currentState.knights) {
      return {
        newState: currentState,
        playerKnightCounts,
        transferred: false,
      };
    }
  }

  // Award to winner
  if (winnerId !== currentState.holderId) {
    return {
      newState: { holderId: winnerId, knights: maxKnights },
      playerKnightCounts,
      transferred: true,
      fromPlayerId: currentState.holderId ?? undefined,
      toPlayerId: winnerId,
    };
  }

  // Current holder still has it (possibly with updated count)
  return {
    newState: { holderId: winnerId, knights: maxKnights },
    playerKnightCounts,
    transferred: false,
  };
}
```

Run tests to confirm green: `npx vitest run apps/api/src/game/largest-army-logic.test.ts`
</action>
<verify>
Run `cd apps/api && npx vitest run src/game/largest-army-logic.test.ts` - all tests pass
</verify>
<done>
Pure function recalculateLargestArmy() correctly handles: min 3 knights threshold, tie-breaking favoring holder, transfer on exceed
</done>
</task>

<task type="auto">
  <name>Task 2: Add GameState schema fields for largest army</name>
  <files>
    libs/shared/src/schemas/game.ts
  </files>
  <action>
Add three fields to GameStateSchema, parallel to longest road fields:

1. `largestArmyHolderId: z.string().nullable()` — Player with largest army card, null if no one has 3+
2. `largestArmyKnights: z.number()` — Knight count of holder (0 if no holder)
3. `playerKnightCounts: z.record(z.string(), z.number())` — playerId -> knights played

Place these immediately after the longestRoad fields (around line 113) for consistency.

The GameStateSchema should look like:

```typescript
export const GameStateSchema = z.object({
  // ... existing fields ...
  // Longest road tracking
  longestRoadHolderId: z.string().nullable(),
  longestRoadLength: z.number(),
  playerRoadLengths: z.record(z.string(), z.number()),
  // Largest army tracking
  largestArmyHolderId: z.string().nullable(),
  largestArmyKnights: z.number(),
  playerKnightCounts: z.record(z.string(), z.number()),
});
```

  </action>
  <verify>
Run `cd libs/shared && npm run build` - builds without errors.
Import GameState type in a test file to confirm type includes new fields.
  </verify>
  <done>
GameStateSchema includes largestArmyHolderId, largestArmyKnights, playerKnightCounts fields
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate updateLargestArmy() into GameManager</name>
  <files>
    apps/api/src/game/GameManager.ts
  </files>
  <action>
1. Import the new logic at top of file:
```typescript
import {
  recalculateLargestArmy,
  LargestArmyResult,
} from './largest-army-logic';
```

2. Initialize new GameState fields in constructor (around line 100, after longestRoad fields):

```typescript
// Largest army tracking (initialized)
largestArmyHolderId: null,
largestArmyKnights: 0,
playerKnightCounts: Object.fromEntries(playerIds.map(id => [id, 0])),
```

3. Add updateLargestArmy() method at the end of the file (after updateLongestRoad):

```typescript
// ============================================================================
// LARGEST ARMY METHODS
// ============================================================================

/**
 * Recalculate largest army and update game state.
 * Returns the result for broadcasting transfer events.
 */
private updateLargestArmy(): LargestArmyResult {
  const currentState = {
    holderId: this.gameState.largestArmyHolderId,
    knights: this.gameState.largestArmyKnights,
  };

  // Build knight counts from internal tracking
  const knightCounts: Record<string, number> = {};
  for (const playerId of this.playerIds) {
    knightCounts[playerId] = this.knightsPlayed.get(playerId) || 0;
  }

  const result = recalculateLargestArmy(knightCounts, this.playerIds, currentState);

  // Update game state
  this.gameState.largestArmyHolderId = result.newState.holderId;
  this.gameState.largestArmyKnights = result.newState.knights;
  this.gameState.playerKnightCounts = result.playerKnightCounts;

  return result;
}
```

4. Call updateLargestArmy() in playKnight() method. Find the existing playKnight method (search for "Knight card specific" or "moveRobber" in knight handling). After incrementing knightsPlayed, add:

```typescript
// Update largest army
const largestArmyResult = this.updateLargestArmy();
```

Then include `largestArmyResult` in the return object.

5. Also update getKnightsPlayed() to sync with gameState if needed (the existing Map is already synced via incrementKnightsPlayed).
   </action>
   <verify>
   Run `cd apps/api && npm run build` - compiles without errors.
   Run existing tests: `npm test` - all tests still pass.
   </verify>
   <done>
   GameManager has updateLargestArmy() method called after knight plays, GameState fields initialized in constructor
   </done>
   </task>

</tasks>

<verification>
1. Run `cd apps/api && npx vitest run src/game/largest-army-logic.test.ts` - all TDD tests pass
2. Run `cd libs/shared && npm run build` - shared library builds
3. Run `cd apps/api && npm run build` - API builds with new imports
4. Run `npm test` from root - all existing tests pass
</verification>

<success_criteria>

- recalculateLargestArmy() pure function exists with 6+ test cases covering edge cases
- GameStateSchema has largestArmyHolderId, largestArmyKnights, playerKnightCounts
- GameManager initializes fields and calls updateLargestArmy() after knight plays
- All tests pass, build succeeds
  </success_criteria>

<output>
After completion, create `.planning/phases/10-largest-army/10-01-SUMMARY.md`
</output>
