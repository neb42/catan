---
phase: 14-victory-stats-and-rematch
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/managers/RoomManager.ts
  - libs/shared/src/schemas/messages.ts
  - libs/shared/src/types/room.ts
  - apps/api/src/handlers/lobby-handlers.ts
autonomous: true

must_haves:
  truths:
    - 'Players can vote for rematch after game ends'
    - 'All players must vote for rematch to trigger'
    - 'Rematch resets game state and generates new board'
    - 'Player identities persist through rematch'
  artifacts:
    - path: 'libs/shared/src/schemas/messages.ts'
      provides: 'Rematch message schemas'
      contains: 'RequestRematchMessageSchema'
    - path: 'apps/api/src/managers/RoomManager.ts'
      provides: 'Rematch vote tracking and reset logic'
      contains: 'rematchVotes'
    - path: 'apps/api/src/handlers/lobby-handlers.ts'
      provides: 'Rematch message handler'
      contains: 'request_rematch'
  key_links:
    - from: 'apps/api/src/handlers/lobby-handlers.ts'
      to: 'RoomManager.handleRematchVote'
      via: 'called in request_rematch handler'
      pattern: "roomManager\\.handleRematchVote"
    - from: 'apps/api/src/managers/RoomManager.ts'
      to: 'GameManager constructor'
      via: 'creates new instance on reset'
      pattern: "new GameManager\\("
---

<objective>
Implement rematch voting system and game state reset logic on the backend.

Purpose: Enable players to replay with a fresh game after victory, using unanimous voting system. Reset creates new board and GameManager while preserving player party.

Output: Rematch WebSocket messages, RoomManager vote tracking, reset logic that generates new board and clears game state.
</objective>

<execution_context>
@/Users/bmcalindin/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-victory-stats-and-rematch/14-CONTEXT.md
@.planning/phases/14-victory-stats-and-rematch/14-RESEARCH.md

# Existing room and game management

@apps/api/src/managers/RoomManager.ts
@apps/api/src/game/GameManager.ts
@apps/api/src/handlers/lobby-handlers.ts
@libs/shared/src/schemas/messages.ts
</context>

<tasks>

<task type="auto">
  <name>Add rematch message schemas</name>
  <files>
    libs/shared/src/schemas/messages.ts
  </files>
  <action>
Add three new message schemas at the end of the file (before ClientMessageSchema union):

```typescript
export const RequestRematchMessageSchema = z.object({
  type: z.literal('request_rematch'),
  playerId: z.string(),
});

export const RematchUpdateMessageSchema = z.object({
  type: z.literal('rematch_update'),
  readyCount: z.number(),
  totalPlayers: z.number(),
  readyPlayers: z.array(z.string()), // Array of player IDs who voted
});

export const GameResetMessageSchema = z.object({
  type: z.literal('game_reset'),
  board: BoardStateSchema,
});
```

Add to ClientMessageSchema union: `RequestRematchMessageSchema`.
Add to ServerMessageSchema union: `RematchUpdateMessageSchema, GameResetMessageSchema`.

Export types: `export type RequestRematchMessage = z.infer<typeof RequestRematchMessageSchema>` (and others).
</action>
<verify>
npx nx typecheck shared
rg "RequestRematchMessageSchema|RematchUpdateMessageSchema|GameResetMessageSchema" libs/shared/src/schemas/messages.ts confirms all three schemas
</verify>
<done>
Three rematch message schemas exist, added to unions, types exported. TypeScript compilation succeeds.
</done>
</task>

<task type="auto">
  <name>Add rematch vote tracking to RoomManager</name>
  <files>
    apps/api/src/managers/RoomManager.ts
    libs/shared/src/types/room.ts
  </files>
  <action>
In `room.ts`, add to Room type (if ManagedRoom is only in RoomManager, add there instead):
```typescript
rematchVotes: Set<string>; // Player IDs who voted for rematch
```

In RoomManager.createRoom(), initialize: `rematchVotes: new Set()`.

Add new method to RoomManager:

```typescript
handleRematchVote(roomId: string, playerId: string): void {
  const room = this.rooms.get(roomId);
  if (!room) return;

  // Add vote
  room.rematchVotes.add(playerId);

  // Broadcast update
  this.broadcastToRoom(roomId, {
    type: 'rematch_update',
    readyCount: room.rematchVotes.size,
    totalPlayers: room.players.size,
    readyPlayers: Array.from(room.rematchVotes),
  });

  // Check if all players voted
  if (room.rematchVotes.size === room.players.size) {
    this.resetGame(roomId);
  }
}
```

Add resetGame method:

```typescript
private resetGame(roomId: string): void {
  const room = this.rooms.get(roomId);
  if (!room) return;

  // Import board generator
  const { generateBoard } = require('../game/board-generator');

  // Generate new board
  const newBoard = generateBoard();
  room.board = newBoard;

  // Create new GameManager with existing player IDs
  const playerIds = Array.from(room.players.keys());
  room.gameManager = new GameManager(newBoard, playerIds);

  // Clear rematch votes
  room.rematchVotes.clear();

  // Reset player ready states
  room.players.forEach(player => {
    player.ready = false;
  });

  // Broadcast game reset with new board
  this.broadcastToRoom(roomId, {
    type: 'game_reset',
    board: newBoard,
  });
}
```

Per RESEARCH.md: Use `new GameManager()` instead of manually clearing fields to prevent state leakage.
</action>
<verify>
npx nx typecheck api
rg "handleRematchVote|resetGame" apps/api/src/managers/RoomManager.ts confirms both methods exist
rg "rematchVotes" apps/api/src/managers/RoomManager.ts shows initialization and usage
</verify>
<done>
ManagedRoom has rematchVotes field. RoomManager has handleRematchVote and resetGame methods. resetGame creates new board and GameManager.
</done>
</task>

<task type="auto">
  <name>Create rematch WebSocket handler</name>
  <files>
    apps/api/src/handlers/lobby-handlers.ts
  </files>
  <action>
Import RequestRematchMessageSchema at top of file.

Add handler function to the handlers object exported:

```typescript
request_rematch: (
  ws: WebSocket,
  message: RequestRematchMessage,
  context: MessageContext
) => {
  const { roomManager } = context;
  const roomId = context.roomId!;
  const playerId = message.playerId;

  // Validate player is in room
  const room = roomManager.getRoom(roomId);
  if (!room || !room.players.has(playerId)) {
    return;
  }

  // Handle rematch vote
  roomManager.handleRematchVote(roomId, playerId);
},
```

This follows existing handler pattern in the file (see player_ready, toggle_ready handlers).
</action>
<verify>
npx nx typecheck api
rg "request_rematch.\*:" apps/api/src/handlers/lobby-handlers.ts confirms handler exists
</verify>
<done>
request_rematch handler exists in lobby-handlers.ts, calls RoomManager.handleRematchVote.
</done>
</task>

</tasks>

<verification>
Type check all affected packages:
```bash
npx nx typecheck shared
npx nx typecheck api
```

Verify message schemas:

```bash
rg "RequestRematch|RematchUpdate|GameReset" libs/shared/src/schemas/messages.ts
```

Verify RoomManager integration:

```bash
rg "handleRematchVote|resetGame|rematchVotes" apps/api/src/managers/RoomManager.ts
```

</verification>

<success_criteria>

1. **Message schemas complete** — Three rematch schemas defined and added to unions
2. **Vote tracking works** — RoomManager tracks votes, broadcasts updates, triggers reset at unanimous vote
3. **Reset logic robust** — Creates new board and GameManager, clears votes, resets ready states
4. **Handler integrated** — request_rematch handler calls RoomManager method
   </success_criteria>

<output>
After completion, create `.planning/phases/14-victory-stats-and-rematch/14-03-SUMMARY.md` following summary template guidelines.
</output>
