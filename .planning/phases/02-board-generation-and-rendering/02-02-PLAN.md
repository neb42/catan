---
phase: 02-board-generation-and-rendering
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - libs/shared/src/schemas/board.ts
  - libs/shared/src/schemas/messages.ts
  - libs/shared/src/index.ts
  - apps/api/src/managers/RoomManager.ts
autonomous: true

must_haves:
  truths:
    - "Board state has type-safe schema"
    - "Board state can be sent via WebSocket"
    - "Clients can receive and parse board state"
  artifacts:
    - path: "libs/shared/src/schemas/board.ts"
      provides: "Zod schemas for board entities"
      exports: ["HexSchema", "PortSchema", "BoardStateSchema"]
      min_lines: 40
    - path: "libs/shared/src/schemas/messages.ts"
      provides: "GameStarted message with board"
      contains: "GameStartedMessageSchema"
    - path: "apps/api/src/managers/RoomManager.ts"
      provides: "Board state storage in room"
      contains: "board:"
  key_links:
    - from: "libs/shared/src/schemas/board.ts"
      to: "libs/shared/src/index.ts"
      via: "exports BoardStateSchema types"
      pattern: "export.*from.*board"
    - from: "libs/shared/src/schemas/messages.ts"
      to: "libs/shared/src/schemas/board.ts"
      via: "imports BoardStateSchema for GameStarted"
      pattern: "import.*BoardStateSchema.*from.*board"
---

<objective>
Define type-safe schemas for board state and extend message protocol to transmit board data from server to clients.

Purpose: Create the shared contracts between server and client for board representation. These schemas ensure type safety across the WebSocket boundary and enable validation of board state during transmission.

Output: Zod schemas for board entities (Hex, Port, BoardState) and updated message types for game start with board data. RoomManager extended to store board state.
</objective>

<execution_context>
@./.github/get-shit-done/workflows/execute-plan.md
@./.github/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-board-generation-and-rendering/02-CONTEXT.md
@.planning/phases/02-board-generation-and-rendering/02-RESEARCH.md
@libs/shared/src/schemas/messages.ts
@libs/shared/src/schemas/player.ts
@libs/shared/src/schemas/room.ts
</context>

<tasks>

<task type="auto">
  <name>Create board state schemas</name>
  <files>libs/shared/src/schemas/board.ts</files>
  <action>
Create Zod schemas for board entities matching the types defined in board-generator.ts:

**Schemas to define:**

```typescript
import { z } from 'zod';

export const TerrainTypeSchema = z.enum(['forest', 'hills', 'fields', 'pasture', 'mountains', 'desert']);

export const PortTypeSchema = z.enum(['generic', 'wood', 'brick', 'sheep', 'wheat', 'ore']);

export const HexSchema = z.object({
  q: z.number(),
  r: z.number(),
  terrain: TerrainTypeSchema,
  number: z.number().nullable(),
});

export const PortSchema = z.object({
  type: PortTypeSchema,
  hexQ: z.number(),
  hexR: z.number(),
  edge: z.number().min(0).max(5), // 0-5 for 6 hex edges
});

export const BoardStateSchema = z.object({
  hexes: z.array(HexSchema).length(19), // Catan always has 19 hexes
  ports: z.array(PortSchema).length(9),  // Catan always has 9 ports
});

export type TerrainType = z.infer<typeof TerrainTypeSchema>;
export type PortType = z.infer<typeof PortTypeSchema>;
export type Hex = z.infer<typeof HexSchema>;
export type Port = z.infer<typeof PortSchema>;
export type BoardState = z.infer<typeof BoardStateSchema>;
```

These schemas provide runtime validation and TypeScript types for all board entities.
  </action>
  <verify>
Check: File compiles without errors: `npx nx build shared`
  </verify>
  <done>
- board.ts created with all schemas and type exports
- Schemas validate array lengths (19 hexes, 9 ports)
- TerrainType and PortType enums match board-generator types
- File compiles successfully
  </done>
</task>

<task type="auto">
  <name>Extend message protocol for game start</name>
  <files>libs/shared/src/schemas/messages.ts, libs/shared/src/index.ts</files>
  <action>
Update message schemas to support game start with board state:

**In messages.ts:**

1. Import BoardStateSchema:
```typescript
import { BoardStateSchema } from './board';
```

2. Replace existing GameStartingMessageSchema with GameStartedMessageSchema:
```typescript
export const GameStartedMessageSchema = z.object({
  type: z.literal('game_started'),
  board: BoardStateSchema,
  countdown: z.number().optional(), // For UI transition (3-2-1 countdown)
});
```

3. Update WebSocketMessageSchema discriminatedUnion to include game_started instead of game_starting

**In index.ts:**

1. Add exports for board types:
```typescript
export * from './schemas/board';
```

2. Ensure GameStartedMessageSchema is exported (should already be included via `export * from './schemas/messages'`)

**Rationale:** Changed from "game_starting" to "game_started" because board is generated and game has actually started at this point. The countdown field is optional for UI countdown animations (3-2-1) but the core message is that the game has begun and here's the board.
  </action>
  <verify>
Check: 
1. `npx nx build shared` succeeds
2. GameStartedMessageSchema appears in shared package exports
3. No TypeScript errors in projects importing from @catan/shared
  </verify>
  <done>
- GameStartedMessageSchema defined with board field
- WebSocketMessageSchema updated to include game_started
- All board types exported from @catan/shared
- Shared package builds successfully
  </done>
</task>

<task type="auto">
  <name>Extend RoomManager with board state</name>
  <files>apps/api/src/managers/RoomManager.ts</files>
  <action>
Add board state storage to ManagedRoom:

**Update ManagedRoom type:**
```typescript
import { BoardState } from '@catan/shared';

export type ManagedRoom = {
  id: Room['id'];
  createdAt: Room['createdAt'];
  players: Map<string, ManagedPlayer>;
  disconnectTimer: NodeJS.Timeout | null;
  board: BoardState | null; // Add board state field
};
```

**Update createRoom method:**
```typescript
createRoom(roomId: string): ManagedRoom {
  const room: ManagedRoom = {
    id: roomId,
    players: new Map(),
    disconnectTimer: null,
    createdAt: new Date(),
    board: null, // Initialize as null, set when game starts
  };

  this.rooms.set(roomId, room);
  return room;
}
```

**Add method to set board:**
```typescript
setBoard(roomId: string, board: BoardState): void {
  const room = this.rooms.get(roomId);
  if (!room) {
    throw new Error('Room not found');
  }
  
  room.board = board;
}
```

**Add method to get board:**
```typescript
getBoard(roomId: string): BoardState | null {
  const room = this.rooms.get(roomId);
  return room?.board ?? null;
}
```

Board state is stored in server memory (not database) and persists for the lifetime of the room.
  </action>
  <verify>
Check: 
1. `npx nx build api` succeeds
2. TypeScript recognizes BoardState import from @catan/shared
3. No type errors in RoomManager
  </verify>
  <done>
- ManagedRoom has board field (BoardState | null)
- createRoom initializes board as null
- setBoard and getBoard methods added
- API builds successfully with no type errors
  </done>
</task>

</tasks>

<verification>
**After all tasks complete:**

1. Build both shared and api: `npx nx build shared && npx nx build api`
2. Verify exports:
   - `import { BoardState, Hex, Port } from '@catan/shared'` works
   - `import { GameStartedMessageSchema } from '@catan/shared'` works
3. Check TypeScript compilation: No errors in any workspace project
4. Verify schema validation: Write quick test parsing a sample BoardState JSON
</verification>

<success_criteria>
- All board-related types exported from @catan/shared
- GameStartedMessageSchema includes BoardState
- RoomManager can store and retrieve board state
- No TypeScript compilation errors
- Schemas validate correctly against sample data
</success_criteria>

<output>
After completion, create `.planning/phases/02-board-generation-and-rendering/02-02-SUMMARY.md`
</output>
