---
phase: 02-board-generation-and-rendering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - libs/shared/src/utils/coordinates.ts
  - apps/api/src/game/board-generator.ts
  - apps/api/src/game/fairness-validator.ts
autonomous: true

must_haves:
  truths:
    - "Board generates 19 hexes in standard Catan layout"
    - "Number tokens follow no adjacent 6/8 rule"
    - "9 ports placed correctly on coast"
    - "Generation completes within reasonable time"
  artifacts:
    - path: "libs/shared/src/utils/coordinates.ts"
      provides: "Cubic coordinate utilities (neighbors, distance)"
      exports: ["getNeighbors", "getCatanHexPositions"]
      min_lines: 50
    - path: "apps/api/src/game/board-generator.ts"
      provides: "Board generation with shuffle-and-validate"
      exports: ["generateBoard"]
      min_lines: 100
    - path: "apps/api/src/game/fairness-validator.ts"
      provides: "Fairness constraint validation"
      exports: ["validateBoardFairness"]
      min_lines: 40
  key_links:
    - from: "apps/api/src/game/board-generator.ts"
      to: "libs/shared/src/utils/coordinates.ts"
      via: "import getNeighbors, getCatanHexPositions"
      pattern: "import.*getNeighbors.*from.*coordinates"
    - from: "apps/api/src/game/board-generator.ts"
      to: "apps/api/src/game/fairness-validator.ts"
      via: "calls validateBoardFairness in retry loop"
      pattern: "validateBoardFairness\\(hexes\\)"
---

<objective>
Implement server-side board generation algorithm that creates randomized Catan boards following official rules.

Purpose: Establish the core logic for generating fair, randomized Catan boards that all players will see. This algorithm runs once when the game starts and produces the board state that will be synced to all clients.

Output: Pure functions that generate board layouts with hexes, number tokens, and ports following Catan constraints (no adjacent 6/8, proper port placement, fair resource distribution).
</objective>

<execution_context>
@./.github/get-shit-done/workflows/execute-plan.md
@./.github/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-board-generation-and-rendering/02-CONTEXT.md
@.planning/phases/02-board-generation-and-rendering/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create cubic coordinate utilities</name>
  <files>libs/shared/src/utils/coordinates.ts</files>
  <action>
Create coordinate utilities file implementing Red Blob Games cubic coordinate system:

**Core types:**
- `AxialCoord` type: `{ q: number, r: number }` (storage format)
- `CubeCoord` type: `{ q: number, r: number, s: number }` (calculation format, q+r+s=0)

**Functions to implement:**
- `axialToCube(coord: AxialCoord): CubeCoord` - Convert axial to cubic (s = -q - r)
- `cubeToAxial(coord: CubeCoord): AxialCoord` - Convert cubic to axial (drop s)
- `getNeighbors(coord: AxialCoord): AxialCoord[]` - Returns 6 neighbors using direction vectors
- `getCatanHexPositions(): AxialCoord[]` - Returns 19 hex positions in standard Catan layout (center + ring 1 + ring 2)

**Direction vectors (pointy-top orientation):**
```typescript
const CUBE_DIRECTIONS = [
  { q: 1, r: 0, s: -1 },
  { q: 1, r: -1, s: 0 },
  { q: 0, r: -1, s: 1 },
  { q: -1, r: 0, s: 1 },
  { q: -1, r: 1, s: 0 },
  { q: 0, r: 1, s: -1 },
];
```

Use algorithms from Red Blob Games (see RESEARCH.md Pattern 4). Ensure all operations preserve q+r+s=0 constraint.
  </action>
  <verify>
Run: `npx nx test shared` (add simple unit tests for getNeighbors, getCatanHexPositions to verify neighbor count and layout)
  </verify>
  <done>
- coordinates.ts exports all required types and functions
- getCatanHexPositions returns exactly 19 coordinates
- getNeighbors returns exactly 6 neighbors for any valid coordinate
- Tests pass
  </done>
</task>

<task type="auto">
  <name>Implement board generation algorithm</name>
  <files>apps/api/src/game/board-generator.ts</files>
  <action>
Create board generation using shuffle-and-validate pattern:

**Types to define:**
```typescript
type TerrainType = 'forest' | 'hills' | 'fields' | 'pasture' | 'mountains' | 'desert';
type PortType = 'generic' | 'wood' | 'brick' | 'sheep' | 'wheat' | 'ore';

interface Hex {
  q: number;
  r: number;
  terrain: TerrainType;
  number: number | null;
}

interface Port {
  type: PortType;
  hexQ: number;
  hexR: number;
  edge: number; // 0-5, direction facing outward
}

interface BoardState {
  hexes: Hex[];
  ports: Port[];
}
```

**Main function:**
```typescript
export function generateBoard(maxRetries = 100): BoardState
```

**Algorithm steps:**
1. Get 19 hex positions from getCatanHexPositions()
2. Shuffle terrain types: 4 wood, 4 wheat, 4 sheep, 3 brick, 3 ore, 1 desert (use crypto.getRandomValues with Fisher-Yates)
3. Assign terrain to positions
4. Shuffle number tokens: [2, 3, 3, 4, 4, 5, 5, 6, 6, 8, 8, 9, 9, 10, 10, 11, 11, 12] (no 7)
5. Assign numbers to non-desert hexes in spiral order from center
6. Validate using validateBoardFairness() from fairness-validator.ts
7. If invalid and retries remaining, goto step 2
8. If retries exhausted, return best attempt (log warning)
9. Generate ports using generatePorts() helper
10. Return { hexes, ports }

**Helper function:**
```typescript
function generatePorts(hexes: Hex[]): Port[]
```
- Shuffle port types: 4 generic, 1 wood, 1 brick, 1 sheep, 1 wheat, 1 ore
- Find edge hexes (ring 2: Math.max(Math.abs(q), Math.abs(r), Math.abs(-q - r)) === 2)
- Distribute 9 ports evenly around perimeter
- Calculate edge direction based on hex position (use atan2 to find outward direction)

**Shuffle using secure randomness:**
```typescript
function shuffle<T>(array: T[]): T[] {
  const result = [...array];
  const randomValues = new Uint32Array(result.length);
  crypto.getRandomValues(randomValues);
  
  for (let i = result.length - 1; i > 0; i--) {
    const j = randomValues[i] % (i + 1);
    [result[i], result[j]] = [result[j], result[i]];
  }
  
  return result;
}
```

Import getNeighbors and getCatanHexPositions from libs/shared/src/utils/coordinates.ts.
  </action>
  <verify>
Run: `npx nx test api` (add test that calls generateBoard() multiple times, verify: 19 hexes, correct terrain counts, numbers valid, no adjacent 6/8)
  </verify>
  <done>
- board-generator.ts exports generateBoard function
- Generated boards have 19 hexes with correct terrain distribution
- No adjacent 6/8 in generated boards (validated by fairness-validator)
- 9 ports generated with correct type distribution
- Tests pass
  </done>
</task>

<task type="auto">
  <name>Implement fairness validation</name>
  <files>apps/api/src/game/fairness-validator.ts</files>
  <action>
Create validation functions for board fairness constraints:

**Main function:**
```typescript
export function validateBoardFairness(hexes: Hex[]): boolean
```

**Validation checks (all must pass):**

1. **No adjacent 6/8** (required by BOARD-02):
   - For each hex with number 6 or 8
   - Get neighbors using getNeighbors() from coordinates.ts
   - Find neighbor hexes in hexes array by matching q, r
   - If any neighbor has number 6 or 8, return false

2. **Resource diversity** (optional but recommended):
   - Ensure each starting position (vertices adjacent to 3 hexes) can access at least 2 different resource types
   - Calculate for a sample of vertex positions around the board

3. **High number distribution** (optional but recommended):
   - Ensure 6s and 8s not all clustered on same resource type
   - Count by terrain, fail if any single terrain has >50% of 6s and 8s

4. **Desert position** (optional but recommended):
   - Desert should not be at exact center (0, 0) more than 30% of the time (makes board too predictable)
   - This check is statistical over multiple generations, not per-board

**Return true if all required checks pass.** Optional checks can be disabled via parameters if causing too many retries.

Import getNeighbors from libs/shared/src/utils/coordinates.ts.
  </action>
  <verify>
Run: `npx nx test api` (add tests for validateBoardFairness with known good and bad boards)
  </verify>
  <done>
- fairness-validator.ts exports validateBoardFairness function
- Validates no adjacent 6/8 correctly
- Additional fairness checks implemented (resource diversity, high number distribution)
- Tests pass with known valid and invalid boards
  </done>
</task>

</tasks>

<verification>
**After all tasks complete:**

1. Run full test suite: `npx nx test shared && npx nx test api`
2. Call generateBoard() 100 times in a test, verify:
   - All boards have exactly 19 hexes
   - Terrain counts: 4 forest, 4 fields, 4 pasture, 3 hills, 3 mountains, 1 desert
   - Number tokens: correct distribution (no 7, two of each 3-6 and 8-11, one each of 2 and 12)
   - No board has adjacent 6/8
   - All boards have exactly 9 ports (4 generic, 5 specific)
3. Check logs for any "retry limit exhausted" warnings during test runs
</verification>

<success_criteria>
- Board generation produces valid Catan layouts following official rules
- No adjacent 6/8 constraint enforced
- Generation completes in <100ms for 99% of cases (measured in tests)
- Coordinate utilities correctly implement cubic coordinate math
- Tests demonstrate consistent, fair board generation
</success_criteria>

<output>
After completion, create `.planning/phases/02-board-generation-and-rendering/02-01-SUMMARY.md`
</output>
