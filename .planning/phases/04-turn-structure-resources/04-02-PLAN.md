---
phase: 04-turn-structure-resources
plan: 02
type: execute
wave: 2
depends_on: ['04-01']
files_modified:
  - apps/api/src/handlers/websocket.ts
  - apps/web/src/stores/gameStore.ts
  - apps/web/src/components/Lobby.tsx
autonomous: true

must_haves:
  truths:
    - 'Client can send roll_dice message and receive dice_rolled response'
    - 'Client can send end_turn message and receive turn_changed response'
    - 'Client store updates turn state from WebSocket messages'
  artifacts:
    - path: 'apps/api/src/handlers/websocket.ts'
      provides: 'roll_dice and end_turn message handlers'
      contains: 'roll_dice'
    - path: 'apps/web/src/stores/gameStore.ts'
      provides: 'Turn state slice with phase, currentPlayerId, turnNumber, lastDiceRoll'
      contains: 'turnPhase'
    - path: 'apps/web/src/components/Lobby.tsx'
      provides: 'dice_rolled and turn_changed message handlers'
      contains: 'dice_rolled'
  key_links:
    - from: 'apps/api/src/handlers/websocket.ts'
      to: 'apps/api/src/game/GameManager.ts'
      via: 'rollDice() and endTurn() method calls'
      pattern: "gameManager\\.rollDice"
    - from: 'apps/web/src/components/Lobby.tsx'
      to: 'apps/web/src/stores/gameStore.ts'
      via: 'setTurnState and updatePlayerResources calls'
      pattern: 'setTurnState'
---

<objective>
Wire backend WebSocket handlers for dice rolling and turn management, and extend frontend store to track turn state.

Purpose: Connect the backend turn logic (from Plan 01) to the WebSocket layer and client state management. This enables the UI components (Plans 03-04) to display and control turn-based gameplay.

Output: Working end-to-end message flow for roll_dice → dice_rolled and end_turn → turn_changed.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-turn-structure-resources/04-01-SUMMARY.md

# Existing code to extend

@apps/api/src/handlers/websocket.ts
@apps/web/src/stores/gameStore.ts
@apps/web/src/components/Lobby.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add backend WebSocket handlers for dice and turn messages</name>
  <files>
    apps/api/src/handlers/websocket.ts
  </files>
  <action>
    In apps/api/src/handlers/websocket.ts, add handlers for new message types:

    1. Add case 'roll_dice':
       - Get room and gameManager from RoomManager
       - Get playerId from client connection
       - Call gameManager.rollDice(playerId)
       - If success:
         - Broadcast dice_rolled message to all room clients: { type: 'dice_rolled', dice1, dice2, total, resourcesDistributed }
       - If error:
         - Send error message to requesting client: { type: 'error', message: result.error }

    2. Add case 'end_turn':
       - Get room and gameManager from RoomManager
       - Get playerId from client connection
       - Call gameManager.endTurn(playerId)
       - If success:
         - Broadcast turn_changed message to all room clients: { type: 'turn_changed', currentPlayerId, turnNumber, phase: 'roll' }
       - If error:
         - Send error message to requesting client

    3. Update 'setup_complete' handling (or add if missing):
       - After sending setup_complete message, also send initial turn_changed message:
         - { type: 'turn_changed', currentPlayerId: firstPlayer, turnNumber: 1, phase: 'roll' }
       - This initializes all clients with the first turn state

    Pattern: Follow existing handler structure (place_settlement, place_road cases).

  </action>
  <verify>
    Run: npx nx build api
    Expected: Build succeeds with no errors
  </verify>
  <done>
    - roll_dice handler calls GameManager.rollDice() and broadcasts dice_rolled
    - end_turn handler calls GameManager.endTurn() and broadcasts turn_changed
    - Setup complete triggers initial turn_changed broadcast
    - Error handling sends error messages to client
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend gameStore with turn state slice</name>
  <files>
    apps/web/src/stores/gameStore.ts
  </files>
  <action>
    Extend the gameStore with turn state management:

    1. Add TurnSlice interface (after PlacementSlice):
       ```typescript
       interface TurnSlice {
         turnPhase: 'roll' | 'main' | null;  // null = not in main game yet
         turnCurrentPlayerId: string | null;
         turnNumber: number;
         lastDiceRoll: { dice1: number; dice2: number; total: number } | null;
         isAnimating: boolean;  // Prevent actions during animations
       }
       ```

    2. Add turn actions to GameStore interface:
       ```typescript
       setTurnState: (state: { phase: 'roll' | 'main'; currentPlayerId: string; turnNumber: number }) => void;
       setDiceRoll: (roll: { dice1: number; dice2: number; total: number }) => void;
       setAnimating: (animating: boolean) => void;
       clearTurnState: () => void;
       ```

    3. Add initial state for turn slice:
       - turnPhase: null
       - turnCurrentPlayerId: null
       - turnNumber: 0
       - lastDiceRoll: null
       - isAnimating: false

    4. Implement actions:
       - setTurnState: updates phase, currentPlayerId, turnNumber, clears lastDiceRoll
       - setDiceRoll: updates lastDiceRoll
       - setAnimating: updates isAnimating
       - clearTurnState: resets all turn state to initial values

    5. Add selector hooks:
       ```typescript
       export const useTurnPhase = () => useGameStore(state => state.turnPhase);
       export const useTurnCurrentPlayer = () => useGameStore(state => state.turnCurrentPlayerId);
       export const useTurnNumber = () => useGameStore(state => state.turnNumber);
       export const useLastDiceRoll = () => useGameStore(state => state.lastDiceRoll);
       export const useIsAnimating = () => useGameStore(state => state.isAnimating);
       export const useIsMyTurn = () => useGameStore(state =>
         state.turnCurrentPlayerId === state.myPlayerId
       );
       export const useCanRollDice = () => useGameStore(state =>
         state.turnPhase === 'roll' &&
         state.turnCurrentPlayerId === state.myPlayerId &&
         !state.isAnimating
       );
       export const useCanEndTurn = () => useGameStore(state =>
         state.turnPhase === 'main' &&
         state.turnCurrentPlayerId === state.myPlayerId &&
         !state.isAnimating
       );
       export const useLastResourcesDistributed = () => useGameStore(state => state.lastResourcesDistributed);
       ```

    6. Add lastResourcesDistributed state for resource distribution notifications:
       - Add to TurnSlice interface: lastResourcesDistributed: Array<{ playerId: string, resources: Array<{ type: string, count: number }> }> | null
       - Add initial state: lastResourcesDistributed: null
       - Add action: setLastResourcesDistributed: (distribution) => set({ lastResourcesDistributed: distribution })

    Note: Keep existing placement state - turn state is separate (null during placement phase).

  </action>
  <verify>
    Run: npx nx build web
    Expected: Build succeeds with no TypeScript errors
  </verify>
  <done>
    - TurnSlice interface added with phase, currentPlayerId, turnNumber, lastDiceRoll, isAnimating, lastResourcesDistributed
    - setTurnState, setDiceRoll, setAnimating, clearTurnState, setLastResourcesDistributed actions implemented
    - Selector hooks for turn state exported (useTurnPhase, useIsMyTurn, useCanRollDice, useLastResourcesDistributed, etc.)
    - Build succeeds
  </done>
</task>

<task type="auto">
  <name>Task 3: Add client message handlers for turn events</name>
  <files>
    apps/web/src/components/Lobby.tsx
  </files>
  <action>
    In Lobby.tsx handleMessage callback, add handlers for new message types:

    1. Add case 'dice_rolled':
       ```typescript
       case 'dice_rolled': {
         const gameStore = useGameStore.getState();
         // Store dice result
         gameStore.setDiceRoll({
           dice1: message.dice1,
           dice2: message.dice2,
           total: message.total
         });
         // Store resource distribution for notification display
         gameStore.setLastResourcesDistributed(message.resourcesDistributed);
         // Update resources for all affected players
         for (const grant of message.resourcesDistributed) {
           gameStore.updatePlayerResources(grant.playerId, grant.resources);
         }
         // Update phase to 'main' (dice has been rolled)
         gameStore.setTurnState({
           phase: 'main',
           currentPlayerId: gameStore.turnCurrentPlayerId || '',
           turnNumber: gameStore.turnNumber
         });
         break;
       }
       ```

    2. Add case 'turn_changed':
       ```typescript
       case 'turn_changed': {
         useGameStore.getState().setTurnState({
           phase: message.phase,
           currentPlayerId: message.currentPlayerId,
           turnNumber: message.turnNumber
         });
         break;
       }
       ```

    3. Note: The 'setup_complete' handler already exists and clears placement state.
       The server will now also send 'turn_changed' after setup_complete to initialize turn state.

    Pattern: Follow existing handler structure (settlement_placed, road_placed cases).

  </action>
  <verify>
    Run: npx nx build web
    Expected: Build succeeds with no TypeScript errors
  </verify>
  <done>
    - dice_rolled handler updates lastDiceRoll, player resources, and turn phase
    - turn_changed handler updates turn state (phase, currentPlayerId, turnNumber)
    - Message flow: roll_dice → dice_rolled → store updated → UI can react
    - Build succeeds
  </done>
</task>

</tasks>

<verification>
1. API builds: `npx nx build api`
2. Web builds: `npx nx build web`
3. Test message flow manually (if dev server running):
   - After setup complete, verify turn_changed message received
   - Send roll_dice, verify dice_rolled response
   - Send end_turn, verify turn_changed response
</verification>

<success_criteria>

- Backend handles roll_dice and end_turn WebSocket messages
- GameStore has turn state slice with all required fields and actions
- Lobby.tsx has handlers for dice_rolled and turn_changed messages
- Message flow connects backend GameManager to frontend store
- Both API and Web build successfully
  </success_criteria>

<output>
After completion, create `.planning/phases/04-turn-structure-resources/04-02-SUMMARY.md`
</output>
