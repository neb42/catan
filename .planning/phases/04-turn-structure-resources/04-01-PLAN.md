---
phase: 04-turn-structure-resources
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - libs/shared/src/schemas/game.ts
  - libs/shared/src/schemas/messages.ts
  - apps/api/src/game/GameManager.ts
  - apps/api/src/game/resource-distributor.ts
autonomous: true

must_haves:
  truths:
    - 'Server can roll dice and return two values 1-6'
    - 'Server calculates which players receive resources from dice roll'
    - 'Server tracks turn number, current player, and turn phase'
  artifacts:
    - path: 'libs/shared/src/schemas/game.ts'
      provides: 'TurnState type with phase, currentPlayerId, turnNumber'
      contains: 'TurnStateSchema'
    - path: 'libs/shared/src/schemas/messages.ts'
      provides: 'RollDice, DiceRolled, EndTurn, TurnChanged message schemas'
      contains: 'RollDiceMessageSchema'
    - path: 'apps/api/src/game/resource-distributor.ts'
      provides: 'distributeResources function'
      exports: ['distributeResources']
    - path: 'apps/api/src/game/GameManager.ts'
      provides: 'rollDice and endTurn methods'
      contains: 'rollDice'
  key_links:
    - from: 'apps/api/src/game/GameManager.ts'
      to: 'apps/api/src/game/resource-distributor.ts'
      via: 'import and function call'
      pattern: 'distributeResources'
---

<objective>
Add turn state management, dice rolling, and resource distribution logic to the backend.

Purpose: Enable the core turn-based gameplay mechanics. Server-authoritative dice rolling prevents cheating and ensures all clients see consistent results. Resource distribution based on settlements/cities adjacent to rolled number is the core Catan mechanic.

Output: GameManager with rollDice() and endTurn() methods, new WebSocket message schemas, and a dedicated resource distribution module.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-turn-structure-resources/04-CONTEXT.md
@.planning/phases/04-turn-structure-resources/04-RESEARCH.md

# Existing code to extend

@apps/api/src/game/GameManager.ts
@libs/shared/src/schemas/game.ts
@libs/shared/src/schemas/messages.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add turn state and message schemas to shared library</name>
  <files>
    libs/shared/src/schemas/game.ts
    libs/shared/src/schemas/messages.ts
  </files>
  <action>
    In libs/shared/src/schemas/game.ts:
    1. Add TurnPhaseSchema enum: 'roll' | 'main' (no 'end' - that's a transition)
    2. Add TurnStateSchema with fields:
       - phase: TurnPhaseSchema
       - currentPlayerId: z.string()
       - turnNumber: z.number() (starts at 1 for first turn)
       - lastDiceRoll: optional object { dice1: number, dice2: number, total: number }
    3. Update GameStateSchema to include turnState: TurnStateSchema.nullable() (null during setup)
    4. Export TurnPhase and TurnState types

    In libs/shared/src/schemas/messages.ts:
    1. Add RollDiceMessageSchema: { type: 'roll_dice' }
    2. Add DiceRolledMessageSchema: { type: 'dice_rolled', dice1: number, dice2: number, total: number, resourcesDistributed: array of { playerId, resources: array of { type, count } } }
    3. Add EndTurnMessageSchema: { type: 'end_turn' }
    4. Add TurnChangedMessageSchema: { type: 'turn_changed', currentPlayerId: string, turnNumber: number, phase: 'roll' | 'main' }
    5. Add all new schemas to WebSocketMessageSchema discriminated union
    6. Export all new types

    Note: resourcesDistributed in DiceRolledMessage allows clients to animate resource distribution for all players, not just themselves.

  </action>
  <verify>
    Run: cd libs/shared && npx tsc --noEmit
    Expected: No TypeScript errors
  </verify>
  <done>
    - TurnStateSchema and TurnPhaseSchema exported from game.ts
    - GameStateSchema includes turnState field
    - RollDice, DiceRolled, EndTurn, TurnChanged message schemas in messages.ts
    - All types exported and TypeScript compiles
  </done>
</task>

<task type="auto">
  <name>Task 2: Create resource distribution module</name>
  <files>
    apps/api/src/game/resource-distributor.ts
    apps/api/src/game/resource-distributor.spec.ts
  </files>
  <action>
    Create apps/api/src/game/resource-distributor.ts:

    1. Export function distributeResources(params):
       - Parameters:
         - diceTotal: number (2-12)
         - hexes: Hex[] (from board state)
         - settlements: Settlement[]
         - vertices: Vertex[] (for adjacency lookup)
         - playerResources: Record<string, PlayerResources> (to mutate)
       - Returns: Array<{ playerId: string, resources: Array<{ type: ResourceType, count: number }> }>

    2. Implementation:
       - Find all hexes where hex.number === diceTotal AND hex.terrain !== 'desert'
       - For each matching hex:
         - Get hex vertices using vertex.adjacentHexes (vertex has list of adjacent hex IDs)
         - For each vertex, check if a settlement exists at that vertexId
         - If settlement exists: award 1 resource (or 2 if isCity)
         - Map terrain to resource: forest→wood, hills→brick, pasture→sheep, fields→wheat, mountains→ore
       - Aggregate resources per player
       - Update playerResources in-place (mutate)
       - Return distribution array for broadcasting

    3. Helper: terrainToResource(terrain: string): ResourceType | null

    Create apps/api/src/game/resource-distributor.spec.ts:
    1. Test case: Dice roll matches hex with adjacent settlement → player receives 1 resource
    2. Test case: Dice roll matches hex with adjacent city → player receives 2 resources
    3. Test case: Dice roll matches desert → no resources distributed
    4. Test case: Dice roll matches hex with no adjacent settlements → empty distribution
    5. Test case: Multiple settlements on same hex → multiple players receive resources

  </action>
  <verify>
    Run: cd apps/api && npx vitest run resource-distributor.spec.ts
    Expected: All tests pass
  </verify>
  <done>
    - resource-distributor.ts exports distributeResources function
    - Function correctly calculates resource distribution based on dice roll
    - All test cases pass
    - Handles edge cases (desert, no settlements, cities)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add turn state and dice rolling to GameManager</name>
  <files>
    apps/api/src/game/GameManager.ts
  </files>
  <action>
    Extend GameManager class:

    1. Update constructor:
       - After setup is complete (when this.gameState.placement becomes null), initialize turnState
       - For now, add a method startMainGame() that initializes turnState:
         - phase: 'roll'
         - currentPlayerId: first player (playerIds[0])
         - turnNumber: 1
         - lastDiceRoll: null

    2. Add rollDice(playerId: string) method:
       - Validate: playerId === getCurrentPlayerId() (use turnState.currentPlayerId)
       - Validate: turnState.phase === 'roll'
       - Generate dice: Math.floor(Math.random() * 6) + 1 for each die
       - Calculate total
       - If total !== 7: call distributeResources() to update playerResources
       - Update turnState.lastDiceRoll = { dice1, dice2, total }
       - Update turnState.phase = 'main'
       - Return { success: true, dice1, dice2, total, resourcesDistributed }
       - On validation failure: return { success: false, error: string }

    3. Add endTurn(playerId: string) method:
       - Validate: playerId === getCurrentPlayerId()
       - Validate: turnState.phase === 'main'
       - Advance to next player: currentPlayerId = playerIds[(currentIndex + 1) % playerIds.length]
       - Increment turnNumber
       - Reset phase to 'roll'
       - Clear lastDiceRoll
       - Return { success: true, nextPlayerId: string, turnNumber: number }

    4. Add getCurrentPlayerId() override for main game:
       - If placement is not null, use placement.currentPlayerIndex
       - If turnState is not null, use turnState.currentPlayerId
       - Otherwise return ''

    5. Update placeRoad to call startMainGame() when setupComplete is true

    Note: Robber logic (when total === 7) is Phase 6 - skip for now, just distribute resources normally.

  </action>
  <verify>
    Run: cd apps/api && npx vitest run GameManager
    Expected: Existing tests pass, and build succeeds
    Run: npx nx build api
    Expected: Build succeeds
  </verify>
  <done>
    - GameManager.rollDice() generates server-side dice values
    - GameManager.endTurn() advances to next player
    - Turn state tracks phase, currentPlayerId, turnNumber, lastDiceRoll
    - Resource distribution called on dice roll (except 7)
    - All existing tests pass, build succeeds
  </done>
</task>

</tasks>

<verification>
1. Shared library compiles: `cd libs/shared && npx tsc --noEmit`
2. API tests pass: `cd apps/api && npx vitest run`
3. API builds: `npx nx build api`
</verification>

<success_criteria>

- TurnState schema exists in shared library with all required fields
- New WebSocket message schemas (RollDice, DiceRolled, EndTurn, TurnChanged) defined
- GameManager has rollDice() and endTurn() methods with server-authoritative logic
- Resource distribution correctly awards resources based on dice roll and board state
- All tests pass, no TypeScript errors
  </success_criteria>

<output>
After completion, create `.planning/phases/04-turn-structure-resources/04-01-SUMMARY.md`
</output>
