---
phase: 08-development-cards
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - libs/shared/src/schemas/game.ts
  - libs/shared/src/constants/index.ts
  - libs/shared/src/schemas/messages.ts
  - libs/shared/src/index.ts
autonomous: true

must_haves:
  truths:
    - 'Dev card types are validated at compile time and runtime'
    - 'Deck composition matches Catan rules (14 Knight, 5 VP, 2 each other)'
    - 'WebSocket messages for dev cards are type-safe'
  artifacts:
    - path: 'libs/shared/src/schemas/game.ts'
      provides: 'DevelopmentCardType, OwnedDevCard schemas'
      contains: 'DevelopmentCardTypeSchema'
    - path: 'libs/shared/src/constants/index.ts'
      provides: 'DEV_CARD_COST, DEV_DECK_COMPOSITION constants'
      contains: 'DEV_CARD_COST'
    - path: 'libs/shared/src/schemas/messages.ts'
      provides: 'Dev card WebSocket message schemas'
      contains: 'BuyDevCardMessageSchema'
  key_links:
    - from: 'libs/shared/src/schemas/messages.ts'
      to: 'libs/shared/src/schemas/game.ts'
      via: 'imports DevelopmentCardTypeSchema'
      pattern: 'DevelopmentCardTypeSchema'
---

<objective>
Add development card type system, deck constants, and WebSocket message schemas to the shared library.

Purpose: Establish type-safe foundation for dev cards that both backend and frontend consume
Output: Zod schemas for card types, owned cards, deck composition constants, and 12+ WebSocket message schemas
</objective>

<execution_context>
@/Users/bmcalindin/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-development-cards/08-RESEARCH.md

@libs/shared/src/schemas/game.ts
@libs/shared/src/schemas/messages.ts
@libs/shared/src/constants/index.ts
@libs/shared/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dev card types and schemas to game.ts</name>
  <files>libs/shared/src/schemas/game.ts</files>
  <action>
Add DevelopmentCardType enum schema and OwnedDevCard schema to game.ts:

1. Create DevelopmentCardTypeSchema as z.enum with 5 values:
   - 'knight'
   - 'victory_point'
   - 'road_building'
   - 'year_of_plenty'
   - 'monopoly'

2. Create OwnedDevCardSchema as z.object with fields:
   - id: z.string() (unique card instance ID, use crypto.randomUUID format)
   - type: DevelopmentCardTypeSchema
   - purchasedOnTurn: z.number() (turn when purchased, for same-turn restriction)

3. Export types: DevelopmentCardType, OwnedDevCard

Pattern: Follow existing ResourceTypeSchema and TurnStateSchema patterns in the file.
</action>
<verify>Run `npx nx build shared` - should compile without errors</verify>
<done>DevelopmentCardTypeSchema and OwnedDevCardSchema exist with correct fields and types exported</done>
</task>

<task type="auto">
  <name>Task 2: Add dev card constants to constants/index.ts</name>
  <files>libs/shared/src/constants/index.ts</files>
  <action>
Add development card constants following existing BUILDING_COSTS pattern:

1. Add DEV_CARD_COST:

```typescript
export const DEV_CARD_COST = {
  ore: 1,
  sheep: 1,
  wheat: 1,
} as const;
```

2. Add DEV_DECK_COMPOSITION (matches Catan rules - 25 total):

```typescript
export const DEV_DECK_COMPOSITION = {
  knight: 14,
  victory_point: 5,
  road_building: 2,
  year_of_plenty: 2,
  monopoly: 2,
} as const;
```

3. Add DEV_DECK_SIZE:

```typescript
export const DEV_DECK_SIZE = 25;
```

Place these after the MAX_PIECES constant for logical grouping.
</action>
<verify>Run `npx nx build shared` - should compile without errors</verify>
<done>DEV_CARD_COST, DEV_DECK_COMPOSITION, and DEV_DECK_SIZE constants exist and are exported</done>
</task>

<task type="auto">
  <name>Task 3: Add dev card WebSocket message schemas</name>
  <files>libs/shared/src/schemas/messages.ts, libs/shared/src/index.ts</files>
  <action>
Add development card WebSocket message schemas to messages.ts. Follow existing robber message patterns.

**Client -> Server messages:**

1. BuyDevCardMessageSchema:
   - type: z.literal('buy_dev_card')

2. PlayDevCardMessageSchema:
   - type: z.literal('play_dev_card')
   - cardId: z.string()

3. YearOfPlentySelectMessageSchema:
   - type: z.literal('year_of_plenty_select')
   - resources: z.tuple([ResourceTypeSchema, ResourceTypeSchema]) // Exactly 2 resources

4. MonopolySelectMessageSchema:
   - type: z.literal('monopoly_select')
   - resourceType: ResourceTypeSchema

5. RoadBuildingPlaceMessageSchema:
   - type: z.literal('road_building_place')
   - edgeId: z.string()

**Server -> Client messages:**

6. DevCardPurchasedMessageSchema (to buyer only - contains card type):
   - type: z.literal('dev_card_purchased')
   - playerId: z.string()
   - card: OwnedDevCardSchema (full card info for buyer)
   - deckRemaining: z.number()

7. DevCardPurchasedPublicMessageSchema (to all others - hides card type):
   - type: z.literal('dev_card_purchased_public')
   - playerId: z.string()
   - deckRemaining: z.number()

8. DevCardPlayedMessageSchema:
   - type: z.literal('dev_card_played')
   - playerId: z.string()
   - cardType: DevelopmentCardTypeSchema
   - cardId: z.string()

9. YearOfPlentyRequiredMessageSchema:
   - type: z.literal('year_of_plenty_required')
   - bankResources: z.record(ResourceTypeSchema, z.number()) // Available bank resources

10. YearOfPlentyCompletedMessageSchema:
    - type: z.literal('year_of_plenty_completed')
    - playerId: z.string()
    - resources: z.tuple([ResourceTypeSchema, ResourceTypeSchema])

11. MonopolyExecutedMessageSchema:
    - type: z.literal('monopoly_executed')
    - playerId: z.string()
    - resourceType: ResourceTypeSchema
    - totalCollected: z.number()
    - fromPlayers: z.record(z.string(), z.number()) // playerId -> amount taken

12. RoadBuildingRequiredMessageSchema:
    - type: z.literal('road_building_required')
    - roadsRemaining: z.number() // 0, 1, or 2

13. RoadBuildingPlacedMessageSchema:
    - type: z.literal('road_building_placed')
    - playerId: z.string()
    - edgeId: z.string()
    - roadsRemaining: z.number()

14. RoadBuildingCompletedMessageSchema:
    - type: z.literal('road_building_completed')
    - playerId: z.string()
    - edgesPlaced: z.array(z.string())

15. DevCardPlayFailedMessageSchema:
    - type: z.literal('dev_card_play_failed')
    - reason: z.string()

**Add all schemas to WebSocketMessageSchema discriminated union.**

**Export all types** at the bottom of the file following existing pattern.

**Update libs/shared/src/index.ts** to export:

- DevelopmentCardTypeSchema, DevelopmentCardType, OwnedDevCardSchema, OwnedDevCard from game.ts (if not auto-exported)
- DEV_CARD_COST, DEV_DECK_COMPOSITION, DEV_DECK_SIZE from constants
- All new message types from messages.ts
  </action>
  <verify>Run `npx nx build shared` - should compile without errors. Types should be importable from @catan/shared.</verify>
  <done>All 15 message schemas added to discriminated union, types exported, shared library builds</done>
  </task>

</tasks>

<verification>
1. `npx nx build shared` passes
2. Types importable: `import { DevelopmentCardType, DEV_CARD_COST, BuyDevCardMessage } from '@catan/shared'`
3. DEV_DECK_COMPOSITION values sum to 25
4. All 15 message schemas in WebSocketMessageSchema discriminated union
</verification>

<success_criteria>

- DevelopmentCardTypeSchema with 5 card types (knight, victory_point, road_building, year_of_plenty, monopoly)
- OwnedDevCardSchema with id, type, purchasedOnTurn fields
- DEV_CARD_COST = { ore: 1, sheep: 1, wheat: 1 }
- DEV_DECK_COMPOSITION totaling 25 cards
- 15 new WebSocket message schemas added and exported
- Shared library compiles successfully
  </success_criteria>

<output>
After completion, create `.planning/phases/08-development-cards/08-01-SUMMARY.md`
</output>
