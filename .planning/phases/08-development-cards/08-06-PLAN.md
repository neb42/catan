---
phase: 08-development-cards
plan: 06
type: execute
wave: 3
depends_on: ['08-02', '08-03']
files_modified:
  - apps/api/src/game/GameManager.ts
  - apps/api/src/websocket/handlers.ts
  - apps/web/src/stores/gameStore.ts
  - apps/web/src/components/CardPlay/ResourcePickerModal.tsx
  - apps/web/src/components/CardPlay/MonopolyModal.tsx
autonomous: true

must_haves:
  truths:
    - 'Year of Plenty grants 2 free resources from bank'
    - 'Resources with 0 in bank are unselectable'
    - 'Monopoly takes all of one resource type from all players'
    - 'All players see Monopoly announcement with total collected'
  artifacts:
    - path: 'apps/api/src/game/GameManager.ts'
      provides: 'playYearOfPlenty, playMonopoly methods'
      contains: 'playYearOfPlenty'
    - path: 'apps/web/src/components/CardPlay/ResourcePickerModal.tsx'
      provides: 'Reusable modal for selecting resources'
      contains: 'ResourcePickerModal'
    - path: 'apps/web/src/components/CardPlay/MonopolyModal.tsx'
      provides: 'Modal for selecting resource type for Monopoly'
      contains: 'MonopolyModal'
  key_links:
    - from: 'apps/web/src/components/CardPlay/ResourcePickerModal.tsx'
      to: 'WebSocket year_of_plenty_select'
      via: 'submits selected resources'
      pattern: 'year_of_plenty_select'
---

<objective>
Implement Year of Plenty and Monopoly card effects with modal UIs.

Purpose: Complete the resource manipulation card effects
Output: Backend logic for both cards, modal UIs for resource selection
</objective>

<execution_context>
@/Users/bmcalindin/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-development-cards/08-02-SUMMARY.md
@.planning/phases/08-development-cards/08-03-SUMMARY.md
@.planning/phases/08-development-cards/08-RESEARCH.md

@apps/api/src/game/GameManager.ts
@apps/web/src/components/Trade/TradeModal.tsx
@apps/web/src/components/Robber/DiscardModal.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Year of Plenty and Monopoly methods to GameManager</name>
  <files>apps/api/src/game/GameManager.ts</files>
  <action>
Add Year of Plenty and Monopoly methods.

**Add private properties:**

```typescript
private yearOfPlentyPending: boolean = false;
private monopolyPending: boolean = false;
private pendingDevCardPlayerId: string | null = null;
```

**Add method: playYearOfPlenty(playerId: string, cardId: string)**

```typescript
playYearOfPlenty(playerId: string, cardId: string): {
  success: boolean;
  error?: string;
  bankResources?: Record<ResourceType, number>;
} {
  // Validate turn, phase, card (same pattern as other cards)
  if (playerId !== this.getCurrentPlayerId()) {
    return { success: false, error: 'Not your turn' };
  }
  if (!this.gameState.turnState || this.gameState.turnState.phase !== 'main') {
    return { success: false, error: 'Can only play during main phase' };
  }

  const playerCards = this.playerDevCards.get(playerId) || [];
  const cardIndex = playerCards.findIndex(c => c.id === cardId);
  if (cardIndex === -1) {
    return { success: false, error: 'Card not found' };
  }

  const card = playerCards[cardIndex];
  if (card.type !== 'year_of_plenty') {
    return { success: false, error: 'Not a Year of Plenty card' };
  }

  const currentTurn = this.gameState.turnState?.turnNumber || 1;
  if (card.purchasedOnTurn === currentTurn) {
    return { success: false, error: 'Cannot play card purchased this turn' };
  }
  if (this.playedDevCardThisTurn) {
    return { success: false, error: 'Already played a dev card this turn' };
  }

  // Remove card
  playerCards.splice(cardIndex, 1);
  this.playerDevCards.set(playerId, playerCards);
  this.playedDevCardThisTurn = true;

  // Enter Year of Plenty mode
  this.yearOfPlentyPending = true;
  this.pendingDevCardPlayerId = playerId;

  // Calculate bank resources (simplified - assume infinite bank for now)
  // In a full implementation, track bank depletion
  const bankResources: Record<ResourceType, number> = {
    wood: 19, brick: 19, sheep: 19, wheat: 19, ore: 19,
  };

  return { success: true, bankResources };
}
```

**Add method: completeYearOfPlenty(playerId: string, resources: [ResourceType, ResourceType])**

```typescript
completeYearOfPlenty(playerId: string, resources: [ResourceType, ResourceType]): {
  success: boolean;
  error?: string;
} {
  if (!this.yearOfPlentyPending || this.pendingDevCardPlayerId !== playerId) {
    return { success: false, error: 'Not in Year of Plenty mode' };
  }

  // Grant resources
  const playerResources = this.gameState.playerResources[playerId];
  resources.forEach(resource => {
    playerResources[resource] = (playerResources[resource] || 0) + 1;
  });

  // Clear pending state
  this.yearOfPlentyPending = false;
  this.pendingDevCardPlayerId = null;

  return { success: true };
}
```

**Add method: playMonopoly(playerId: string, cardId: string)**

```typescript
playMonopoly(playerId: string, cardId: string): {
  success: boolean;
  error?: string;
} {
  // Validate (same pattern)
  if (playerId !== this.getCurrentPlayerId()) {
    return { success: false, error: 'Not your turn' };
  }
  if (!this.gameState.turnState || this.gameState.turnState.phase !== 'main') {
    return { success: false, error: 'Can only play during main phase' };
  }

  const playerCards = this.playerDevCards.get(playerId) || [];
  const cardIndex = playerCards.findIndex(c => c.id === cardId);
  if (cardIndex === -1) {
    return { success: false, error: 'Card not found' };
  }

  const card = playerCards[cardIndex];
  if (card.type !== 'monopoly') {
    return { success: false, error: 'Not a Monopoly card' };
  }

  const currentTurn = this.gameState.turnState?.turnNumber || 1;
  if (card.purchasedOnTurn === currentTurn) {
    return { success: false, error: 'Cannot play card purchased this turn' };
  }
  if (this.playedDevCardThisTurn) {
    return { success: false, error: 'Already played a dev card this turn' };
  }

  // Remove card
  playerCards.splice(cardIndex, 1);
  this.playerDevCards.set(playerId, playerCards);
  this.playedDevCardThisTurn = true;

  // Enter Monopoly mode
  this.monopolyPending = true;
  this.pendingDevCardPlayerId = playerId;

  return { success: true };
}
```

**Add method: completeMonopoly(playerId: string, resourceType: ResourceType)**

```typescript
completeMonopoly(playerId: string, resourceType: ResourceType): {
  success: boolean;
  error?: string;
  totalCollected?: number;
  fromPlayers?: Record<string, number>;
} {
  if (!this.monopolyPending || this.pendingDevCardPlayerId !== playerId) {
    return { success: false, error: 'Not in Monopoly mode' };
  }

  let totalCollected = 0;
  const fromPlayers: Record<string, number> = {};

  // Take from all other players
  this.playerIds.forEach(otherId => {
    if (otherId === playerId) return;

    const otherResources = this.gameState.playerResources[otherId];
    const amount = otherResources[resourceType] || 0;

    if (amount > 0) {
      otherResources[resourceType] = 0;
      totalCollected += amount;
      fromPlayers[otherId] = amount;
    }
  });

  // Give to monopoly player
  const playerResources = this.gameState.playerResources[playerId];
  playerResources[resourceType] = (playerResources[resourceType] || 0) + totalCollected;

  // Clear pending state
  this.monopolyPending = false;
  this.pendingDevCardPlayerId = null;

  return { success: true, totalCollected, fromPlayers };
}
```

  </action>
  <verify>Run `npx nx build api` - should compile without errors</verify>
  <done>playYearOfPlenty, completeYearOfPlenty, playMonopoly, completeMonopoly methods added</done>
</task>

<task type="auto">
  <name>Task 2: Add Year of Plenty and Monopoly WebSocket handlers</name>
  <files>apps/api/src/websocket/handlers.ts</files>
  <action>
Add handlers for Year of Plenty and Monopoly in play_dev_card and completion messages.

**In play_dev_card switch, add cases:**

```typescript
case 'year_of_plenty': {
  const result = room.gameManager.playYearOfPlenty(playerId, cardId);

  if (!result.success) {
    ws.send(JSON.stringify({
      type: 'dev_card_play_failed',
      reason: result.error,
    }));
    return;
  }

  // Broadcast card played
  broadcastToRoom(room, {
    type: 'dev_card_played',
    playerId,
    cardType: 'year_of_plenty',
    cardId,
  });

  // Send resource picker to player
  ws.send(JSON.stringify({
    type: 'year_of_plenty_required',
    bankResources: result.bankResources,
  }));

  break;
}

case 'monopoly': {
  const result = room.gameManager.playMonopoly(playerId, cardId);

  if (!result.success) {
    ws.send(JSON.stringify({
      type: 'dev_card_play_failed',
      reason: result.error,
    }));
    return;
  }

  // Broadcast card played - but don't reveal choice yet
  broadcastToRoom(room, {
    type: 'dev_card_played',
    playerId,
    cardType: 'monopoly',
    cardId,
  });

  // Send resource picker to player (no bank resources needed)
  ws.send(JSON.stringify({
    type: 'monopoly_required',
  }));

  break;
}
```

**Add handler for year_of_plenty_select:**

```typescript
case 'year_of_plenty_select': {
  if (!room.gameManager) {
    sendError(ws, 'Game not started');
    return;
  }

  const { resources } = message;  // [ResourceType, ResourceType]
  const result = room.gameManager.completeYearOfPlenty(playerId, resources);

  if (!result.success) {
    ws.send(JSON.stringify({
      type: 'dev_card_play_failed',
      reason: result.error,
    }));
    return;
  }

  // Broadcast completion
  broadcastToRoom(room, {
    type: 'year_of_plenty_completed',
    playerId,
    resources,
  });

  break;
}
```

**Add handler for monopoly_select:**

```typescript
case 'monopoly_select': {
  if (!room.gameManager) {
    sendError(ws, 'Game not started');
    return;
  }

  const { resourceType } = message;
  const result = room.gameManager.completeMonopoly(playerId, resourceType);

  if (!result.success) {
    ws.send(JSON.stringify({
      type: 'dev_card_play_failed',
      reason: result.error,
    }));
    return;
  }

  // Broadcast to all (public announcement)
  broadcastToRoom(room, {
    type: 'monopoly_executed',
    playerId,
    resourceType,
    totalCollected: result.totalCollected,
    fromPlayers: result.fromPlayers,
  });

  break;
}
```

Add monopoly_required schema if not in 08-01 (add to messages.ts):

```typescript
export const MonopolyRequiredMessageSchema = z.object({
  type: z.literal('monopoly_required'),
});
```

  </action>
  <verify>Run `npx nx build api` - should compile without errors</verify>
  <done>year_of_plenty, monopoly cases added, year_of_plenty_select and monopoly_select handlers complete</done>
</task>

<task type="auto">
  <name>Task 3: Create ResourcePickerModal and MonopolyModal components</name>
  <files>apps/web/src/components/CardPlay/ResourcePickerModal.tsx, apps/web/src/components/CardPlay/MonopolyModal.tsx, apps/web/src/stores/gameStore.ts</files>
  <action>
**Create ResourcePickerModal.tsx** (for Year of Plenty):
```tsx
import { useState } from 'react';
import { Modal, Button, Group, Stack, Text, Badge } from '@mantine/core';
import { ResourceType } from '@catan/shared';
import { useGameStore } from '../../stores/gameStore';

const RESOURCES: ResourceType[] = ['wood', 'brick', 'sheep', 'wheat', 'ore'];

export function ResourcePickerModal() {
const devCardPlayPhase = useGameStore((s) => s.devCardPlayPhase);
const sendMessage = useGameStore((s) => s.sendMessage);
const [selected, setSelected] = useState<ResourceType[]>([]);

const isOpen = devCardPlayPhase === 'year_of_plenty';

const handleSelect = (resource: ResourceType) => {
if (selected.length >= 2) return;
setSelected([...selected, resource]);
};

const handleRemove = (index: number) => {
setSelected(selected.filter((\_, i) => i !== index));
};

const handleSubmit = () => {
if (selected.length !== 2) return;

    sendMessage({
      type: 'year_of_plenty_select',
      resources: selected as [ResourceType, ResourceType],
    });

    setSelected([]);

};

return (
<Modal
opened={isOpen}
onClose={() => {}} // Blocking modal
closeOnClickOutside={false}
closeOnEscape={false}
withCloseButton={false}
title="Year of Plenty"
centered >
<Stack>
<Text>Select 2 resources from the bank:</Text>

        <Group>
          {selected.map((resource, i) => (
            <Badge
              key={i}
              size="lg"
              style={{ cursor: 'pointer' }}
              onClick={() => handleRemove(i)}
            >
              {resource} âœ•
            </Badge>
          ))}
        </Group>

        <Group>
          {RESOURCES.map((resource) => (
            <Button
              key={resource}
              onClick={() => handleSelect(resource)}
              disabled={selected.length >= 2}
              variant={selected.includes(resource) ? 'filled' : 'outline'}
            >
              {resource}
            </Button>
          ))}
        </Group>

        <Button
          onClick={handleSubmit}
          disabled={selected.length !== 2}
          fullWidth
        >
          Take Resources
        </Button>
      </Stack>
    </Modal>

);
}

````

**Create MonopolyModal.tsx:**
```tsx
import { Modal, Button, Stack, Text, SimpleGrid } from '@mantine/core';
import { ResourceType } from '@catan/shared';
import { useGameStore } from '../../stores/gameStore';

const RESOURCES: ResourceType[] = ['wood', 'brick', 'sheep', 'wheat', 'ore'];

export function MonopolyModal() {
  const devCardPlayPhase = useGameStore((s) => s.devCardPlayPhase);
  const sendMessage = useGameStore((s) => s.sendMessage);

  const isOpen = devCardPlayPhase === 'monopoly';

  const handleSelect = (resourceType: ResourceType) => {
    sendMessage({
      type: 'monopoly_select',
      resourceType,
    });
  };

  return (
    <Modal
      opened={isOpen}
      onClose={() => {}}  // Blocking modal
      closeOnClickOutside={false}
      closeOnEscape={false}
      withCloseButton={false}
      title="Monopoly"
      centered
    >
      <Stack>
        <Text>Choose a resource to take from all players:</Text>

        <SimpleGrid cols={3}>
          {RESOURCES.map((resource) => (
            <Button
              key={resource}
              onClick={() => handleSelect(resource)}
              size="lg"
            >
              {resource}
            </Button>
          ))}
        </SimpleGrid>
      </Stack>
    </Modal>
  );
}
````

**In gameStore.ts, add message handlers:**

For `year_of_plenty_required`:

```typescript
case 'year_of_plenty_required': {
  useGameStore.getState().setDevCardPlayPhase('year_of_plenty');
  break;
}
```

For `year_of_plenty_completed`:

```typescript
case 'year_of_plenty_completed': {
  const { playerId, resources } = message;
  useGameStore.getState().setDevCardPlayPhase(null);

  // Update resources for player
  const currentResources = { ...useGameStore.getState().playerResources[playerId] };
  resources.forEach(r => {
    currentResources[r] = (currentResources[r] || 0) + 1;
  });
  useGameStore.getState().updatePlayerResources(playerId, currentResources);

  showGameNotification(`${getPlayerNickname(playerId)} took ${resources.join(' and ')}!`, 'info');
  break;
}
```

For `monopoly_required`:

```typescript
case 'monopoly_required': {
  useGameStore.getState().setDevCardPlayPhase('monopoly');
  break;
}
```

For `monopoly_executed`:

```typescript
case 'monopoly_executed': {
  const { playerId, resourceType, totalCollected, fromPlayers } = message;
  useGameStore.getState().setDevCardPlayPhase(null);

  // Update resources for all affected players
  Object.entries(fromPlayers).forEach(([victimId, amount]) => {
    const resources = { ...useGameStore.getState().playerResources[victimId] };
    resources[resourceType] = 0;
    useGameStore.getState().updatePlayerResources(victimId, resources);
  });

  // Give to monopoly player
  const monopolyResources = { ...useGameStore.getState().playerResources[playerId] };
  monopolyResources[resourceType] = (monopolyResources[resourceType] || 0) + totalCollected;
  useGameStore.getState().updatePlayerResources(playerId, monopolyResources);

  showGameNotification(`${getPlayerNickname(playerId)} collected ${totalCollected} ${resourceType} via Monopoly!`, 'warning');
  break;
}
```

  </action>
  <verify>Run `npx nx build web` - should compile without errors</verify>
  <done>ResourcePickerModal and MonopolyModal created with blocking behavior and WebSocket integration</done>
</task>

</tasks>

<verification>
1. `npx nx build api` passes
2. `npx nx build web` passes
3. Year of Plenty: opens modal, select 2 resources, submit grants resources
4. Monopoly: opens modal, select resource type, all opponents lose that resource, player gains total
5. Both modals are blocking (no close button, no escape)
</verification>

<success_criteria>

- Year of Plenty allows selecting same resource twice
- Monopoly broadcasts total collected to all players
- Resource updates propagate to all clients
- Turn continues after card effect completes
- Modals follow blocking pattern from DiscardModal
  </success_criteria>

<output>
After completion, create `.planning/phases/08-development-cards/08-06-SUMMARY.md`
</output>
