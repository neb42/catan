---
phase: 08-development-cards
plan: 04
type: execute
wave: 3
depends_on: ['08-02', '08-03']
files_modified:
  - apps/api/src/game/GameManager.ts
  - apps/api/src/websocket/handlers.ts
  - apps/web/src/stores/gameStore.ts
autonomous: true

must_haves:
  truths:
    - 'Playing Knight card triggers robber flow (move + steal)'
    - 'Knight count increments when Knight card is played'
    - 'Knight card can be played before or after rolling dice'
    - 'Robber UI is reused - no new components needed'
  artifacts:
    - path: 'apps/api/src/game/GameManager.ts'
      provides: 'playKnight method that enters robber flow'
      contains: 'playKnight'
  key_links:
    - from: 'apps/api/src/game/GameManager.ts'
      to: 'existing robber flow'
      via: "sets robberPhase to 'moving'"
      pattern: 'robberPhase.*moving'
---

<objective>
Implement Knight card play logic that reuses existing robber flow.

Purpose: Knight card triggers robber placement + steal without discard phase
Output: playKnight method in GameManager, WebSocket handlers for play_dev_card (knight), frontend integration
</objective>

<execution_context>
@/Users/bmcalindin/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-development-cards/08-02-SUMMARY.md
@.planning/phases/08-development-cards/08-03-SUMMARY.md
@.planning/phases/08-development-cards/08-RESEARCH.md

@apps/api/src/game/GameManager.ts
@apps/api/src/game/robber-logic.ts
@apps/api/src/websocket/handlers.ts
@apps/web/src/stores/gameStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add playKnight method to GameManager</name>
  <files>apps/api/src/game/GameManager.ts</files>
  <action>
Add method to play Knight card, which enters the robber move/steal flow (skipping discard).

**Add method: playKnight(playerId: string, cardId: string)**

```typescript
playKnight(playerId: string, cardId: string): {
  success: boolean;
  error?: string;
  currentRobberHex?: string | null;
} {
  // 1. Validate it's player's turn
  if (playerId !== this.getCurrentPlayerId()) {
    return { success: false, error: 'Not your turn' };
  }

  // 2. Validate not already in a robber/dev card flow
  if (this.robberPhase !== 'none') {
    return { success: false, error: 'Robber flow already in progress' };
  }

  // 3. Find and validate the card
  const playerCards = this.playerDevCards.get(playerId) || [];
  const cardIndex = playerCards.findIndex(c => c.id === cardId);
  if (cardIndex === -1) {
    return { success: false, error: 'Card not found' };
  }

  const card = playerCards[cardIndex];
  if (card.type !== 'knight') {
    return { success: false, error: 'Not a Knight card' };
  }

  // 4. Check play restrictions (same-turn, one-per-turn)
  const currentTurn = this.gameState.turnState?.turnNumber || 1;
  if (card.purchasedOnTurn === currentTurn) {
    return { success: false, error: 'Cannot play card purchased this turn' };
  }
  if (this.playedDevCardThisTurn) {
    return { success: false, error: 'Already played a dev card this turn' };
  }

  // 5. Remove card from player's hand
  playerCards.splice(cardIndex, 1);
  this.playerDevCards.set(playerId, playerCards);

  // 6. Increment knight count
  const currentKnights = this.knightsPlayed.get(playerId) || 0;
  this.knightsPlayed.set(playerId, currentKnights + 1);

  // 7. Mark dev card played this turn
  this.playedDevCardThisTurn = true;

  // 8. Enter robber move phase (skip discarding)
  this.robberPhase = 'moving';
  this.robberMover = playerId;

  return {
    success: true,
    currentRobberHex: this.gameState.robberHexId,
  };
}
```

**Add getter for knight count (if not added in 08-02):**

```typescript
getAllKnightsPlayed(): Record<string, number> {
  const result: Record<string, number> = {};
  this.knightsPlayed.forEach((count, playerId) => {
    result[playerId] = count;
  });
  return result;
}
```

  </action>
  <verify>Run `npx nx build api` - should compile without errors</verify>
  <done>playKnight method removes card, increments knight count, enters robber 'moving' phase</done>
</task>

<task type="auto">
  <name>Task 2: Add play_dev_card handler for Knight</name>
  <files>apps/api/src/websocket/handlers.ts</files>
  <action>
Add handler for play_dev_card message, initially handling Knight cards.
Other card types will be added in subsequent plans.

**Add case for play_dev_card:**

```typescript
case 'play_dev_card': {
  if (!room.gameManager) {
    sendError(ws, 'Game not started');
    return;
  }

  const { cardId } = message;

  // Get the card to determine type
  const playerCards = room.gameManager.getPlayerDevCards(playerId);
  const card = playerCards.find(c => c.id === cardId);

  if (!card) {
    ws.send(JSON.stringify({
      type: 'dev_card_play_failed',
      reason: 'Card not found',
    }));
    return;
  }

  // Route based on card type
  switch (card.type) {
    case 'knight': {
      const result = room.gameManager.playKnight(playerId, cardId);

      if (!result.success) {
        ws.send(JSON.stringify({
          type: 'dev_card_play_failed',
          reason: result.error,
        }));
        return;
      }

      // Broadcast that Knight was played
      broadcastToRoom(room, {
        type: 'dev_card_played',
        playerId,
        cardType: 'knight',
        cardId,
      });

      // Send robber_move_required to the player
      ws.send(JSON.stringify({
        type: 'robber_move_required',
        currentHexId: result.currentRobberHex,
      }));

      break;
    }

    case 'victory_point': {
      // VP cards are never "played" - they auto-score
      ws.send(JSON.stringify({
        type: 'dev_card_play_failed',
        reason: 'Victory Point cards score automatically',
      }));
      break;
    }

    // road_building, year_of_plenty, monopoly handled in 08-05/08-06
    default: {
      ws.send(JSON.stringify({
        type: 'dev_card_play_failed',
        reason: 'Card type not yet implemented',
      }));
    }
  }

  break;
}
```

Note: The existing robber flow (move_robber, steal_target handlers) will be reused.
When robber_move_required is sent, client enters robber placement mode (existing UI).
</action>
<verify>Run `npx nx build api` - should compile without errors</verify>
<done>play_dev_card handler routes knight to playKnight, broadcasts dev_card_played, sends robber_move_required</done>
</task>

<task type="auto">
  <name>Task 3: Add frontend handlers for dev_card_played (Knight)</name>
  <files>apps/web/src/stores/gameStore.ts</files>
  <action>
Add WebSocket message handlers for dev card play messages.
Find the existing message handler section (likely in Lobby.tsx or a WebSocket hook).

**If handlers are in gameStore, add actions:**

**In the message handling logic (wherever WebSocket messages are processed):**

For `dev_card_played` message:

```typescript
case 'dev_card_played': {
  const { playerId, cardType, cardId } = message;

  // Remove card from hand if it's my card
  const myId = useGameStore.getState().myPlayerId;
  if (playerId === myId) {
    useGameStore.getState().removeMyDevCard(cardId);
  } else {
    // Decrement opponent card count
    const currentCount = useGameStore.getState().opponentDevCardCounts[playerId] || 0;
    useGameStore.getState().setOpponentDevCardCount(playerId, Math.max(0, currentCount - 1));
  }

  // If Knight, increment knights played
  if (cardType === 'knight') {
    useGameStore.getState().incrementKnightsPlayed(playerId);
  }

  // Set has played dev card if it's my turn
  if (playerId === myId) {
    useGameStore.getState().setHasPlayedDevCardThisTurn(true);
  }

  // Show notification
  showGameNotification(`${getPlayerNickname(playerId)} played a ${cardType.replace('_', ' ')}!`, 'info');

  break;
}
```

For `dev_card_play_failed` message:

```typescript
case 'dev_card_play_failed': {
  showGameNotification(message.reason, 'error');
  break;
}
```

**Note:** The robber_move_required message is already handled by existing robber handlers from Phase 7.
When received, it should trigger robberPlacementMode = true, which shows existing RobberPlacement overlay.

**If needed, ensure robber_move_required handler exists and sets:**

```typescript
case 'robber_move_required': {
  useGameStore.getState().setRobberPlacementMode(true);
  // currentHexId can be used to show current robber position
  break;
}
```

  </action>
  <verify>Run `npx nx build web` - should compile without errors</verify>
  <done>dev_card_played handler removes card, increments knight count, shows notification. Robber flow reuses existing UI.</done>
</task>

</tasks>

<verification>
1. `npx nx build api` passes
2. `npx nx build web` passes
3. Playing Knight: removes card from hand, increments knight count, enters robber move phase
4. Client receives dev_card_played, then robber_move_required - existing robber UI activates
5. After robber moved + steal, turn continues normally
</verification>

<success_criteria>

- playKnight validates card ownership, same-turn rule, one-per-turn rule
- playKnight removes card, increments knightsPlayed, sets robberPhase='moving'
- WebSocket broadcasts dev_card_played to all, robber_move_required to player
- Client reuses existing RobberPlacement and StealModal components
- Knight count visible for Largest Army tracking
  </success_criteria>

<output>
After completion, create `.planning/phases/08-development-cards/08-04-SUMMARY.md`
</output>
