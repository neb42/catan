---
phase: 08-development-cards
plan: 05
type: execute
wave: 3
depends_on: ['08-02', '08-03']
files_modified:
  - apps/api/src/game/GameManager.ts
  - apps/api/src/websocket/handlers.ts
  - apps/web/src/stores/gameStore.ts
  - apps/web/src/components/CardPlay/RoadBuildingOverlay.tsx
autonomous: true

must_haves:
  truths:
    - 'Road Building card places 2 free roads sequentially'
    - 'If player has only 1 road piece remaining, places 1 and card is consumed'
    - 'Roads must follow normal placement rules'
    - 'Turn continues after Road Building completes'
  artifacts:
    - path: 'apps/api/src/game/GameManager.ts'
      provides: 'playRoadBuilding, placeRoadBuildingRoad methods'
      contains: 'playRoadBuilding'
    - path: 'apps/web/src/components/CardPlay/RoadBuildingOverlay.tsx'
      provides: 'Sequential road placement overlay'
      contains: 'RoadBuildingOverlay'
  key_links:
    - from: 'apps/web/src/components/CardPlay/RoadBuildingOverlay.tsx'
      to: 'WebSocket road_building_place'
      via: 'sends message on road click'
      pattern: 'road_building_place'
---

<objective>
Implement Road Building card that places 2 free roads sequentially.

Purpose: Allow player to place up to 2 roads without spending resources
Output: Backend logic for Road Building, WebSocket handlers, overlay UI for sequential placement
</objective>

<execution_context>
@/Users/bmcalindin/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-development-cards/08-02-SUMMARY.md
@.planning/phases/08-development-cards/08-03-SUMMARY.md
@.planning/phases/08-development-cards/08-RESEARCH.md

@apps/api/src/game/GameManager.ts
@apps/api/src/game/placement-validator.ts
@apps/web/src/components/Board/PlacementOverlay.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Road Building methods to GameManager</name>
  <files>apps/api/src/game/GameManager.ts</files>
  <action>
Add Road Building state and methods to GameManager.

**Add private property (after roadsPlacedThisCard in dev card section):**

```typescript
private roadBuildingRemaining = 0;  // 0, 1, or 2 roads remaining
private roadBuildingEdges: string[] = [];  // Edges placed during Road Building
```

**Add method: playRoadBuilding(playerId: string, cardId: string)**

```typescript
playRoadBuilding(playerId: string, cardId: string): {
  success: boolean;
  error?: string;
  roadsToPlace?: number;
} {
  // 1. Validate turn, phase, card ownership (similar to playKnight)
  if (playerId !== this.getCurrentPlayerId()) {
    return { success: false, error: 'Not your turn' };
  }
  if (!this.gameState.turnState || this.gameState.turnState.phase !== 'main') {
    return { success: false, error: 'Can only play during main phase' };
  }

  const playerCards = this.playerDevCards.get(playerId) || [];
  const cardIndex = playerCards.findIndex(c => c.id === cardId);
  if (cardIndex === -1) {
    return { success: false, error: 'Card not found' };
  }

  const card = playerCards[cardIndex];
  if (card.type !== 'road_building') {
    return { success: false, error: 'Not a Road Building card' };
  }

  // Check play restrictions
  const currentTurn = this.gameState.turnState?.turnNumber || 1;
  if (card.purchasedOnTurn === currentTurn) {
    return { success: false, error: 'Cannot play card purchased this turn' };
  }
  if (this.playedDevCardThisTurn) {
    return { success: false, error: 'Already played a dev card this turn' };
  }

  // 2. Calculate how many roads player can place
  const playerRoads = this.gameState.roads.filter(r => r.playerId === playerId).length;
  const roadsRemaining = MAX_PIECES.roads - playerRoads;
  const roadsToPlace = Math.min(2, roadsRemaining);

  if (roadsToPlace === 0) {
    return { success: false, error: 'No road pieces remaining' };
  }

  // 3. Remove card and set state
  playerCards.splice(cardIndex, 1);
  this.playerDevCards.set(playerId, playerCards);
  this.playedDevCardThisTurn = true;

  // 4. Enter Road Building mode
  this.roadBuildingRemaining = roadsToPlace;
  this.roadBuildingEdges = [];

  return { success: true, roadsToPlace };
}
```

**Add method: placeRoadBuildingRoad(playerId: string, edgeId: string)**

```typescript
placeRoadBuildingRoad(playerId: string, edgeId: string): {
  success: boolean;
  error?: string;
  roadsRemaining?: number;
  complete?: boolean;
  edgesPlaced?: string[];
} {
  // 1. Validate player and mode
  if (playerId !== this.getCurrentPlayerId()) {
    return { success: false, error: 'Not your turn' };
  }
  if (this.roadBuildingRemaining <= 0) {
    return { success: false, error: 'Not in Road Building mode' };
  }

  // 2. Validate placement using main-game road rules
  const errorReason = getInvalidMainGameRoadReason(
    edgeId,
    playerId,
    this.gameState,
    this.edges,
    this.vertices
  );
  if (errorReason) {
    return { success: false, error: errorReason };
  }

  // 3. Place road (no resource cost)
  this.gameState.roads.push({ edgeId, playerId });
  this.roadBuildingEdges.push(edgeId);
  this.roadBuildingRemaining--;

  // 4. Check if complete
  const complete = this.roadBuildingRemaining === 0;

  if (complete) {
    // Reset Road Building state
    const edgesPlaced = [...this.roadBuildingEdges];
    this.roadBuildingEdges = [];
    return {
      success: true,
      roadsRemaining: 0,
      complete: true,
      edgesPlaced
    };
  }

  return {
    success: true,
    roadsRemaining: this.roadBuildingRemaining,
    complete: false
  };
}
```

**Add getter:**

```typescript
isInRoadBuildingMode(): boolean {
  return this.roadBuildingRemaining > 0;
}

getRoadBuildingRemaining(): number {
  return this.roadBuildingRemaining;
}
```

Import MAX_PIECES if not already imported.
</action>
<verify>Run `npx nx build api` - should compile without errors</verify>
<done>playRoadBuilding and placeRoadBuildingRoad methods handle sequential road placement</done>
</task>

<task type="auto">
  <name>Task 2: Add Road Building WebSocket handlers</name>
  <files>apps/api/src/websocket/handlers.ts</files>
  <action>
Add Road Building handling to play_dev_card and new road_building_place handler.

**In play_dev_card switch, add case for road_building:**

```typescript
case 'road_building': {
  const result = room.gameManager.playRoadBuilding(playerId, cardId);

  if (!result.success) {
    ws.send(JSON.stringify({
      type: 'dev_card_play_failed',
      reason: result.error,
    }));
    return;
  }

  // Broadcast that Road Building was played
  broadcastToRoom(room, {
    type: 'dev_card_played',
    playerId,
    cardType: 'road_building',
    cardId,
  });

  // Send road_building_required to the player
  ws.send(JSON.stringify({
    type: 'road_building_required',
    roadsRemaining: result.roadsToPlace,
  }));

  break;
}
```

**Add new handler for road_building_place:**

```typescript
case 'road_building_place': {
  if (!room.gameManager) {
    sendError(ws, 'Game not started');
    return;
  }

  const { edgeId } = message;
  const result = room.gameManager.placeRoadBuildingRoad(playerId, edgeId);

  if (!result.success) {
    ws.send(JSON.stringify({
      type: 'build_failed',  // Reuse existing error type
      reason: result.error,
    }));
    return;
  }

  // Broadcast road placed
  broadcastToRoom(room, {
    type: 'road_building_placed',
    playerId,
    edgeId,
    roadsRemaining: result.roadsRemaining,
  });

  if (result.complete) {
    // Broadcast completion
    broadcastToRoom(room, {
      type: 'road_building_completed',
      playerId,
      edgesPlaced: result.edgesPlaced,
    });
  } else {
    // Send updated required message to player
    ws.send(JSON.stringify({
      type: 'road_building_required',
      roadsRemaining: result.roadsRemaining,
    }));
  }

  break;
}
```

  </action>
  <verify>Run `npx nx build api` - should compile without errors</verify>
  <done>road_building case in play_dev_card, road_building_place handler with broadcast on completion</done>
</task>

<task type="auto">
  <name>Task 3: Add Road Building frontend state and overlay</name>
  <files>apps/web/src/stores/gameStore.ts, apps/web/src/components/CardPlay/RoadBuildingOverlay.tsx</files>
  <action>
**In gameStore.ts, add message handlers:**

For `road_building_required`:

```typescript
case 'road_building_required': {
  const { roadsRemaining } = message;
  useGameStore.getState().setDevCardPlayPhase('road_building');
  useGameStore.getState().setRoadsPlacedThisCard(2 - roadsRemaining);  // 0 or 1 placed
  break;
}
```

For `road_building_placed`:

```typescript
case 'road_building_placed': {
  const { playerId, edgeId, roadsRemaining } = message;

  // Add road to state
  const roads = [...useGameStore.getState().roads, { edgeId, playerId }];
  useGameStore.getState().setRoads(roads);

  // Update roads placed count
  useGameStore.getState().setRoadsPlacedThisCard(2 - roadsRemaining);

  break;
}
```

For `road_building_completed`:

```typescript
case 'road_building_completed': {
  const { playerId, edgesPlaced } = message;

  // Exit road building mode
  useGameStore.getState().setDevCardPlayPhase(null);
  useGameStore.getState().setRoadsPlacedThisCard(0);

  showGameNotification(`${getPlayerNickname(playerId)} placed ${edgesPlaced.length} free roads!`, 'success');
  break;
}
```

**Create RoadBuildingOverlay.tsx:**

```tsx
import { Box, Text } from '@mantine/core';
import { useGameStore } from '../../stores/gameStore';
import { PlacementOverlay } from '../Board/PlacementOverlay';
import { useValidEdgeIds } from '../../hooks/usePlacement';

export function RoadBuildingOverlay() {
  const devCardPlayPhase = useGameStore((s) => s.devCardPlayPhase);
  const roadsPlaced = useGameStore((s) => s.roadsPlacedThisCard);
  const sendMessage = useGameStore((s) => s.sendMessage);

  if (devCardPlayPhase !== 'road_building') {
    return null;
  }

  const roadsRemaining = 2 - roadsPlaced;

  const handleEdgeClick = (edgeId: string) => {
    sendMessage({
      type: 'road_building_place',
      edgeId,
    });
  };

  return (
    <>
      <Box
        style={{
          position: 'fixed',
          top: 16,
          left: '50%',
          transform: 'translateX(-50%)',
          zIndex: 1000,
          background: 'rgba(0, 0, 0, 0.8)',
          color: 'white',
          padding: '12px 24px',
          borderRadius: 8,
        }}
      >
        <Text size="lg" fw={600}>
          Road Building: Place {roadsRemaining} more road
          {roadsRemaining !== 1 ? 's' : ''}
        </Text>
      </Box>

      {/* Reuse PlacementOverlay or render edge markers */}
      {/* Show valid edge locations for road placement */}
    </>
  );
}
```

Note: The actual edge rendering may reuse PlacementOverlay component or EdgeMarker components from Phase 5.
Integrate RoadBuildingOverlay into the main Game component where PlacementOverlay is rendered.

**Add sendMessage action to store if not exists:**
This should reference the WebSocket send function.
</action>
<verify>Run `npx nx build web` - should compile without errors</verify>
<done>road_building messages handled, RoadBuildingOverlay shows progress and handles edge clicks</done>
</task>

</tasks>

<verification>
1. `npx nx build api` passes
2. `npx nx build web` passes
3. Playing Road Building: enters mode with 2 (or 1) roads to place
4. Each road click: validates, places road, decrements remaining
5. After all roads placed: exits mode, broadcasts completion
6. Edge case: player with 1 road remaining places 1 and completes
</verification>

<success_criteria>

- playRoadBuilding calculates min(2, roads remaining)
- placeRoadBuildingRoad validates placement, places road without cost
- Complete broadcast includes all edges placed
- Overlay shows "Place X more roads" progress
- Turn continues after Road Building completes
  </success_criteria>

<output>
After completion, create `.planning/phases/08-development-cards/08-05-SUMMARY.md`
</output>
