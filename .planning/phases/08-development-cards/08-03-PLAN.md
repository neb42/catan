---
phase: 08-development-cards
plan: 03
type: execute
wave: 2
depends_on: ['08-01']
files_modified:
  - apps/api/src/websocket/handlers.ts
  - apps/web/src/stores/gameStore.ts
  - apps/web/src/hooks/useDevCardState.ts
autonomous: true

must_haves:
  truths:
    - 'Buy dev card message triggers purchase flow'
    - 'Buyer receives full card info, others receive only count update'
    - 'Frontend tracks deck remaining and own dev cards'
  artifacts:
    - path: 'apps/api/src/websocket/handlers.ts'
      provides: 'buy_dev_card message handler'
      contains: 'buy_dev_card'
    - path: 'apps/web/src/stores/gameStore.ts'
      provides: 'DevCardSlice with myDevCards and deckRemaining'
      contains: 'DevCardSlice'
    - path: 'apps/web/src/hooks/useDevCardState.ts'
      provides: 'Hooks for dev card UI state'
      contains: 'useCanBuyDevCard'
  key_links:
    - from: 'apps/web/src/stores/gameStore.ts'
      to: 'WebSocket message handlers'
      via: 'dev_card_purchased message updates store'
      pattern: 'dev_card_purchased'
---

<objective>
Implement WebSocket handler for buying dev cards and frontend state management.

Purpose: Complete the purchase flow from UI click through backend to all clients
Output: WebSocket handler for buy_dev_card, DevCardSlice in gameStore, hooks for UI
</objective>

<execution_context>
@/Users/bmcalindin/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-development-cards/08-01-SUMMARY.md
@.planning/phases/08-development-cards/08-RESEARCH.md

@apps/api/src/websocket/handlers.ts
@apps/web/src/stores/gameStore.ts
@apps/web/src/hooks/usePlacement.ts
@libs/shared/src/schemas/messages.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add buy_dev_card WebSocket handler</name>
  <files>apps/api/src/websocket/handlers.ts</files>
  <action>
Add handler for buy_dev_card message in the existing handlers file.
Follow the existing pattern for build messages (build_road, build_settlement, etc.).

**In the message switch/handler:**

```typescript
case 'buy_dev_card': {
  if (!room.gameManager) {
    sendError(ws, 'Game not started');
    return;
  }

  const result = room.gameManager.buyDevCard(playerId);

  if (!result.success) {
    // Send error only to buyer
    sendToPlayer(ws, {
      type: 'dev_card_play_failed',
      reason: result.error || 'Purchase failed',
    });
    return;
  }

  // Send full card info to buyer
  sendToPlayer(ws, {
    type: 'dev_card_purchased',
    playerId,
    card: result.card,
    deckRemaining: result.deckRemaining,
  });

  // Send hidden info to all other players in room
  broadcastToOthers(room, playerId, {
    type: 'dev_card_purchased_public',
    playerId,
    deckRemaining: result.deckRemaining,
  });

  break;
}
```

**Helper function (if not exists):**
If sendToPlayer doesn't exist, use the ws.send pattern directly:

```typescript
ws.send(JSON.stringify({...}));
```

If broadcastToOthers doesn't exist, iterate room.players and send to each except playerId:

```typescript
room.players.forEach((player) => {
  if (player.id !== playerId && player.ws && player.ws.readyState === WebSocket.OPEN) {
    player.ws.send(JSON.stringify({...}));
  }
});
```

Ensure imports include any new message types needed.
</action>
<verify>Run `npx nx build api` - should compile without errors</verify>
<done>buy_dev_card handler sends dev_card_purchased to buyer, dev_card_purchased_public to others</done>
</task>

<task type="auto">
  <name>Task 2: Add DevCardSlice to gameStore</name>
  <files>apps/web/src/stores/gameStore.ts</files>
  <action>
Add DevCardSlice interface and state to the game store.
Follow the existing RobberSlice pattern.

**Add interface (after RobberSlice):**

```typescript
// Dev card state slice
interface DevCardSlice {
  // Own cards (full info for local player)
  myDevCards: OwnedDevCard[];

  // Opponent card counts (hidden info - just counts)
  opponentDevCardCounts: Record<string, number>;

  // Deck state
  deckRemaining: number;

  // Play state
  hasPlayedDevCardThisTurn: boolean;

  // Card play in progress
  devCardPlayPhase:
    | 'none'
    | 'road_building'
    | 'year_of_plenty'
    | 'monopoly'
    | null;
  cardBeingPlayed: OwnedDevCard | null;
  roadsPlacedThisCard: number; // For Road Building (0, 1, or 2)

  // Knight tracking (for Largest Army - visible to all)
  knightsPlayed: Record<string, number>;
}
```

**Add initial state (in store creation):**

```typescript
// Dev card state
myDevCards: [],
opponentDevCardCounts: {},
deckRemaining: 25,
hasPlayedDevCardThisTurn: false,
devCardPlayPhase: null,
cardBeingPlayed: null,
roadsPlacedThisCard: 0,
knightsPlayed: {},
```

**Add actions:**

```typescript
// Dev card actions
setMyDevCards: (cards: OwnedDevCard[]) => set({ myDevCards: cards }),
addMyDevCard: (card: OwnedDevCard) => set((state) => ({
  myDevCards: [...state.myDevCards, card]
})),
removeMyDevCard: (cardId: string) => set((state) => ({
  myDevCards: state.myDevCards.filter(c => c.id !== cardId)
})),
setDeckRemaining: (count: number) => set({ deckRemaining: count }),
setOpponentDevCardCount: (playerId: string, count: number) => set((state) => ({
  opponentDevCardCounts: { ...state.opponentDevCardCounts, [playerId]: count }
})),
incrementOpponentDevCardCount: (playerId: string) => set((state) => ({
  opponentDevCardCounts: {
    ...state.opponentDevCardCounts,
    [playerId]: (state.opponentDevCardCounts[playerId] || 0) + 1
  }
})),
setHasPlayedDevCardThisTurn: (value: boolean) => set({ hasPlayedDevCardThisTurn: value }),
setDevCardPlayPhase: (phase: DevCardSlice['devCardPlayPhase']) => set({ devCardPlayPhase: phase }),
setCardBeingPlayed: (card: OwnedDevCard | null) => set({ cardBeingPlayed: card }),
setRoadsPlacedThisCard: (count: number) => set({ roadsPlacedThisCard: count }),
setKnightsPlayed: (playerId: string, count: number) => set((state) => ({
  knightsPlayed: { ...state.knightsPlayed, [playerId]: count }
})),
incrementKnightsPlayed: (playerId: string) => set((state) => ({
  knightsPlayed: { ...state.knightsPlayed, [playerId]: (state.knightsPlayed[playerId] || 0) + 1 }
})),
```

**Add to GameStoreState interface** (union with DevCardSlice).

**Import OwnedDevCard from @catan/shared** if not already imported.

**Reset dev card state in turn change handler** (where turn_changed is processed):

- setHasPlayedDevCardThisTurn(false) when turn changes

**Update store type to include dev card actions.**
</action>
<verify>Run `npx nx build web` - should compile without errors</verify>
<done>DevCardSlice integrated into gameStore with all state and actions</done>
</task>

<task type="auto">
  <name>Task 3: Create useDevCardState hooks</name>
  <files>apps/web/src/hooks/useDevCardState.ts</files>
  <action>
Create new hooks file for dev card UI state.
Follow usePlacement.ts pattern for hook structure.

```typescript
import { useGameStore } from '../stores/gameStore';
import { useShallow } from 'zustand/react/shallow';
import { DEV_CARD_COST } from '@catan/shared';

/**
 * Check if current player can buy a dev card
 */
export function useCanBuyDevCard(): { canBuy: boolean; reason?: string } {
  return useGameStore(
    useShallow((s) => {
      const myId = s.myPlayerId;
      if (!myId) return { canBuy: false, reason: 'Not in game' };

      // Must be our turn
      if (s.turnCurrentPlayerId !== myId) {
        return { canBuy: false, reason: 'Not your turn' };
      }

      // Must be in main phase
      if (s.turnPhase !== 'main') {
        return { canBuy: false, reason: 'Must roll dice first' };
      }

      // Check deck has cards
      if (s.deckRemaining === 0) {
        return { canBuy: false, reason: 'Deck is empty' };
      }

      // Check resources
      const resources = s.playerResources[myId];
      if (!resources) return { canBuy: false, reason: 'No resources' };

      if (resources.ore < DEV_CARD_COST.ore) {
        return { canBuy: false, reason: 'Need 1 ore' };
      }
      if (resources.sheep < DEV_CARD_COST.sheep) {
        return { canBuy: false, reason: 'Need 1 sheep' };
      }
      if (resources.wheat < DEV_CARD_COST.wheat) {
        return { canBuy: false, reason: 'Need 1 wheat' };
      }

      return { canBuy: true };
    }),
  );
}

/**
 * Get my dev cards
 */
export function useMyDevCards() {
  return useGameStore((s) => s.myDevCards);
}

/**
 * Get deck remaining count
 */
export function useDeckRemaining() {
  return useGameStore((s) => s.deckRemaining);
}

/**
 * Check if a specific card can be played
 */
export function useCanPlayCard(cardId: string): {
  canPlay: boolean;
  reason?: string;
} {
  return useGameStore(
    useShallow((s) => {
      const myId = s.myPlayerId;
      if (!myId) return { canPlay: false, reason: 'Not in game' };

      // Find the card
      const card = s.myDevCards.find((c) => c.id === cardId);
      if (!card) return { canPlay: false, reason: 'Card not found' };

      // VP cards are never "played" - they're automatic
      if (card.type === 'victory_point') {
        return {
          canPlay: false,
          reason: 'Victory Point cards score automatically',
        };
      }

      // Must be our turn
      if (s.turnCurrentPlayerId !== myId) {
        return { canPlay: false, reason: 'Not your turn' };
      }

      // Knight can be played before or after rolling
      // Other cards require main phase
      if (card.type !== 'knight' && s.turnPhase !== 'main') {
        return { canPlay: false, reason: 'Must roll dice first' };
      }

      // Can't play card bought this turn
      const currentTurn = s.turnNumber;
      if (card.purchasedOnTurn === currentTurn) {
        return {
          canPlay: false,
          reason: 'Cannot play card purchased this turn',
        };
      }

      // Can only play one dev card per turn (except VP)
      if (s.hasPlayedDevCardThisTurn) {
        return {
          canPlay: false,
          reason: 'Already played a dev card this turn',
        };
      }

      return { canPlay: true };
    }),
  );
}

/**
 * Get knights played for a player
 */
export function useKnightsPlayed(playerId: string) {
  return useGameStore((s) => s.knightsPlayed[playerId] || 0);
}

/**
 * Get dev card play phase
 */
export function useDevCardPlayPhase() {
  return useGameStore((s) => s.devCardPlayPhase);
}
```

Export all hooks.
</action>
<verify>Run `npx nx build web` - should compile without errors</verify>
<done>useDevCardState.ts exists with useCanBuyDevCard, useMyDevCards, useCanPlayCard hooks</done>
</task>

</tasks>

<verification>
1. `npx nx build api` passes
2. `npx nx build web` passes
3. buy_dev_card handler differentiates messages to buyer vs others
4. DevCardSlice has all required state and actions
5. Hooks correctly check turn, phase, resources, and deck
</verification>

<success_criteria>

- buy_dev_card sends dev_card_purchased (with card) to buyer
- buy_dev_card sends dev_card_purchased_public (no card) to others
- DevCardSlice tracks myDevCards, opponentDevCardCounts, deckRemaining
- useCanBuyDevCard checks turn, phase, resources (ore, sheep, wheat), and deck
- useCanPlayCard enforces same-turn and one-per-turn restrictions
- Both apps build successfully
  </success_criteria>

<output>
After completion, create `.planning/phases/08-development-cards/08-03-SUMMARY.md`
</output>
