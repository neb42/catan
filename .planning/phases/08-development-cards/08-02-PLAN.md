---
phase: 08-development-cards
plan: 02
type: execute
wave: 2
depends_on: ['08-01']
files_modified:
  - apps/api/src/game/dev-card-logic.ts
  - apps/api/src/game/GameManager.ts
autonomous: true

must_haves:
  truths:
    - 'Deck is shuffled using Fisher-Yates algorithm for uniform distribution'
    - 'Player can buy dev card when they have sufficient resources'
    - 'Purchased cards are tracked with turn number for same-turn restriction'
    - 'Knight count is tracked per player for Largest Army'
  artifacts:
    - path: 'apps/api/src/game/dev-card-logic.ts'
      provides: 'Deck creation, shuffle, card validation functions'
      contains: 'createShuffledDeck'
    - path: 'apps/api/src/game/GameManager.ts'
      provides: 'Dev card state and methods (buyDevCard, playDevCard)'
      contains: 'buyDevCard'
  key_links:
    - from: 'apps/api/src/game/GameManager.ts'
      to: 'apps/api/src/game/dev-card-logic.ts'
      via: 'import functions'
      pattern: 'import.*dev-card-logic'
---

<objective>
Implement deck management and purchase system in the backend GameManager.

Purpose: Enable server-side dev card deck with secure shuffle, purchase validation, and player card tracking
Output: dev-card-logic.ts with pure functions, GameManager extended with deck state and buyDevCard method
</objective>

<execution_context>
@/Users/bmcalindin/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-development-cards/08-01-SUMMARY.md
@.planning/phases/08-development-cards/08-RESEARCH.md

@apps/api/src/game/GameManager.ts
@apps/api/src/game/robber-logic.ts
@libs/shared/src/constants/index.ts
@libs/shared/src/schemas/game.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dev-card-logic.ts with deck and validation functions</name>
  <files>apps/api/src/game/dev-card-logic.ts</files>
  <action>
Create new file apps/api/src/game/dev-card-logic.ts with pure functions for dev card logic.
Follow robber-logic.ts pattern for structure.

**Functions to implement:**

1. `createShuffledDeck(): DevelopmentCardType[]`
   - Build array from DEV_DECK_COMPOSITION (14 knight, 5 VP, etc.)
   - Fisher-Yates shuffle (CRITICAL - use correct bounds):

   ```typescript
   for (let i = deck.length - 1; i > 0; i--) {
     const j = Math.floor(Math.random() * (i + 1)); // 0 to i inclusive
     [deck[i], deck[j]] = [deck[j], deck[i]];
   }
   ```

   - Return shuffled array

2. `canBuyDevCard(playerId: string, playerResources: PlayerResources, deckRemaining: number): { canBuy: boolean; reason?: string }`
   - Check if deck has cards remaining
   - Check if player has >= 1 ore, >= 1 sheep, >= 1 wheat
   - Return { canBuy: true } or { canBuy: false, reason: "..." }

3. `canPlayDevCard(card: OwnedDevCard, currentTurn: number, hasPlayedThisTurn: boolean): { canPlay: boolean; reason?: string }`
   - Check card.purchasedOnTurn !== currentTurn (DEV-03)
   - If card.type !== 'victory_point', check !hasPlayedThisTurn (DEV-04)
   - VP cards can always be "played" (they're auto-counted)
   - Return { canPlay: true } or { canPlay: false, reason: "..." }

4. `drawCard(deck: DevelopmentCardType[], deckIndex: number): { card: DevelopmentCardType | null; newIndex: number }`
   - If deckIndex >= deck.length, return { card: null, newIndex: deckIndex }
   - Return { card: deck[deckIndex], newIndex: deckIndex + 1 }

Import from @catan/shared:

- DevelopmentCardType, OwnedDevCard, PlayerResources
- DEV_DECK_COMPOSITION, DEV_CARD_COST

Export all functions.
</action>
<verify>Run `npx nx build api` - should compile without errors</verify>
<done>dev-card-logic.ts exists with createShuffledDeck, canBuyDevCard, canPlayDevCard, drawCard functions</done>
</task>

<task type="auto">
  <name>Task 2: Add dev card state and methods to GameManager</name>
  <files>apps/api/src/game/GameManager.ts</files>
  <action>
Extend GameManager with dev card state tracking and purchase method.

**Add private properties (after robberMover):**

```typescript
// Development card state
private devCardDeck: DevelopmentCardType[] = [];
private deckIndex = 0;
private playerDevCards: Map<string, OwnedDevCard[]> = new Map();  // playerId -> owned cards
private playedDevCardThisTurn = false;
private knightsPlayed: Map<string, number> = new Map();  // playerId -> count
```

**In constructor:**

1. Import createShuffledDeck from './dev-card-logic'
2. Initialize deck: `this.devCardDeck = createShuffledDeck();`
3. Initialize player cards map: for each playerId, set empty array
4. Initialize knights played: for each playerId, set 0

**Add method: getDeckRemaining(): number**

```typescript
getDeckRemaining(): number {
  return this.devCardDeck.length - this.deckIndex;
}
```

**Add method: getPlayerDevCards(playerId: string): OwnedDevCard[]**

```typescript
getPlayerDevCards(playerId: string): OwnedDevCard[] {
  return this.playerDevCards.get(playerId) || [];
}
```

**Add method: getKnightsPlayed(playerId: string): number**

```typescript
getKnightsPlayed(playerId: string): number {
  return this.knightsPlayed.get(playerId) || 0;
}
```

**Add method: buyDevCard(playerId: string)**

```typescript
buyDevCard(playerId: string): {
  success: boolean;
  error?: string;
  card?: OwnedDevCard;
  deckRemaining?: number;
} {
  // 1. Validate it's player's turn and main phase
  if (playerId !== this.getCurrentPlayerId()) {
    return { success: false, error: 'Not your turn' };
  }
  if (!this.gameState.turnState || this.gameState.turnState.phase !== 'main') {
    return { success: false, error: 'Can only buy during main phase' };
  }

  // 2. Validate can buy (resources + deck)
  const resources = this.gameState.playerResources[playerId];
  const check = canBuyDevCard(playerId, resources, this.getDeckRemaining());
  if (!check.canBuy) {
    return { success: false, error: check.reason };
  }

  // 3. Draw card from deck
  const { card: cardType, newIndex } = drawCard(this.devCardDeck, this.deckIndex);
  if (!cardType) {
    return { success: false, error: 'Deck is empty' };
  }
  this.deckIndex = newIndex;

  // 4. Deduct resources
  const cost = DEV_CARD_COST;
  resources.ore -= cost.ore;
  resources.sheep -= cost.sheep;
  resources.wheat -= cost.wheat;

  // 5. Create owned card with current turn
  const currentTurn = this.gameState.turnState?.turnNumber || 1;
  const ownedCard: OwnedDevCard = {
    id: crypto.randomUUID(),
    type: cardType,
    purchasedOnTurn: currentTurn,
  };

  // 6. Add to player's hand
  const playerCards = this.playerDevCards.get(playerId) || [];
  playerCards.push(ownedCard);
  this.playerDevCards.set(playerId, playerCards);

  return {
    success: true,
    card: ownedCard,
    deckRemaining: this.getDeckRemaining(),
  };
}
```

**Modify endTurn() method** (find existing endTurn):

- Add: `this.playedDevCardThisTurn = false;` when turn ends (reset for next turn)

Import from '@catan/shared':

- OwnedDevCard, DevelopmentCardType, DEV_CARD_COST

Import from './dev-card-logic':

- createShuffledDeck, canBuyDevCard, drawCard
  </action>
  <verify>Run `npx nx build api` - should compile without errors</verify>
  <done>GameManager has devCardDeck, buyDevCard method, knightsPlayed tracking, and endTurn resets playedDevCardThisTurn</done>
  </task>

</tasks>

<verification>
1. `npx nx build api` passes
2. GameManager initializes shuffled deck of 25 cards in constructor
3. buyDevCard validates turn, phase, resources, and deck
4. Purchased cards have unique IDs and purchasedOnTurn tracking
5. endTurn resets playedDevCardThisTurn flag
</verification>

<success_criteria>

- dev-card-logic.ts has Fisher-Yates shuffle (correct bounds: Math.random() \* (i + 1))
- GameManager tracks deck state (array + index pointer, not mutating)
- buyDevCard returns card with id, type, purchasedOnTurn
- knightsPlayed map initialized for all players
- API builds successfully
  </success_criteria>

<output>
After completion, create `.planning/phases/08-development-cards/08-02-SUMMARY.md`
</output>
