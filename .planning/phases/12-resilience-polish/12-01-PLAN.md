---
phase: 12-resilience-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/handlers/websocket.ts
  - apps/api/src/managers/RoomManager.ts
  - libs/shared/src/schemas/messages.ts
autonomous: true

must_haves:
  truths:
    - 'Game pauses when any player disconnects'
    - 'Disconnected player can rejoin with same nickname'
    - 'Game resumes automatically when player reconnects'
  artifacts:
    - path: 'apps/api/src/handlers/websocket.ts'
      provides: 'Heartbeat ping/pong and disconnect detection'
      min_lines: 150
    - path: 'apps/api/src/managers/RoomManager.ts'
      provides: 'Game pause/resume and session restoration'
      exports: ['pauseGame', 'resumeGame', 'restoreSession']
    - path: 'libs/shared/src/schemas/messages.ts'
      provides: 'Pause/resume message schemas'
      contains: 'game_paused'
  key_links:
    - from: 'apps/api/src/handlers/websocket.ts'
      to: "ws.on('pong')"
      via: 'heartbeat tracking'
      pattern: 'isAlive.*true'
    - from: 'apps/api/src/handlers/websocket.ts'
      to: 'roomManager.pauseGame'
      via: 'on disconnect'
      pattern: "pauseGame\\(roomId\\)"
---

<objective>
Implement server-side WebSocket resilience with heartbeat detection, game pause on disconnect, and session restoration for reconnecting players.

Purpose: Make multiplayer games reliable in real-world network conditions by detecting dead connections quickly and preserving game state for reconnection.

Output: Backend can detect silent disconnects within 30 seconds, pause games when players disconnect, and restore full game state when players rejoin with the same nickname.
</objective>

<execution_context>
@/Users/bmcalindin/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-resilience-polish/12-CONTEXT.md
@.planning/phases/12-resilience-polish/12-RESEARCH.md
@apps/api/src/handlers/websocket.ts
@apps/api/src/managers/RoomManager.ts
@libs/shared/src/schemas/messages.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add heartbeat ping/pong and disconnect detection</name>
  <files>
    apps/api/src/handlers/websocket.ts
    libs/shared/src/schemas/messages.ts
  </files>
  <action>
Add server-side heartbeat mechanism to detect dead WebSocket connections and trigger game pause.

**In websocket.ts:**

1. Add interface for ExtendedWebSocket with isAlive property (boolean)
2. In handleWebSocketConnection, set ws.isAlive = true on connection
3. Add ws.on('pong', () => ws.isAlive = true) handler
4. Create setInterval (30 seconds) that:
   - Iterates all clients in room
   - For clients where isAlive === false: trigger disconnect (call existing removePlayer + broadcast pause message)
   - For clients where isAlive === true: set isAlive = false, send ws.ping()
5. Clear interval on ws.close
6. When player disconnects (onclose), call roomManager.pauseGame(roomId) if game is active

**In messages.ts:**
Add message schemas:

```typescript
game_paused: z.object({
  type: z.literal('game_paused'),
  disconnectedPlayerId: z.string(),
  disconnectedPlayerNickname: z.string(),
});

game_resumed: z.object({
  type: z.literal('game_resumed'),
  reconnectedPlayerId: z.string(),
  reconnectedPlayerNickname: z.string(),
});
```

Use 30-second ping interval (industry standard from research). Do NOT use shorter intervals to avoid network spam.
</action>
<verify>
npx nx test api
Check websocket.ts contains setInterval with ping/pong logic
Check messages.ts exports game_paused and game_resumed schemas
</verify>
<done>
Heartbeat mechanism sends pings every 30 seconds, tracks isAlive per connection, detects dead connections, and defines pause/resume message schemas.
</done>
</task>

<task type="auto">
  <name>Task 2: Add game pause/resume and session restoration</name>
  <files>
    apps/api/src/managers/RoomManager.ts
    apps/api/src/handlers/lobby-handlers.ts
  </files>
  <action>
Implement game pause when player disconnects and session restoration when player rejoins.

**In RoomManager.ts:**

1. Add isPaused: boolean field to ManagedRoom (default false)
2. Add disconnectedPlayers: Map<string, ManagedPlayer> field to ManagedRoom (stores disconnected players by nickname)
3. Add method pauseGame(roomId: string, playerId: string):
   - Get room, set isPaused = true
   - Move player from players to disconnectedPlayers (keyed by nickname)
   - Broadcast game_paused message with disconnectedPlayerId and nickname
4. Add method resumeGame(roomId: string, playerId: string):
   - Get room, set isPaused = false
   - Broadcast game_resumed message with reconnectedPlayerId and nickname
5. Modify addPlayer to check disconnectedPlayers:
   - If nickname exists in disconnectedPlayers, this is a reconnection
   - Restore player with new WebSocket connection, keep same playerId
   - Move from disconnectedPlayers back to players
   - Call resumeGame(roomId, playerId)
   - Send full game state to rejoining player (room_state message)

**In lobby-handlers.ts (handleJoinRoom):**
Modify to support reconnection:

- If RoomManager detects reconnection (nickname in disconnectedPlayers), allow join even if game started
- Existing validation (max players, nickname taken by active player) still applies
- New player vs reconnecting player handled by RoomManager.addPlayer logic

No timeout on disconnect â€” wait indefinitely (per user decision). Room cleanup only happens when ALL players leave.
</action>
<verify>
npx nx test api
Check RoomManager has pauseGame, resumeGame methods
Check addPlayer handles disconnectedPlayers map
Check lobby-handlers allows rejoins for disconnected players
</verify>
<done>
Game pauses when player disconnects (isPaused flag set, broadcast sent), disconnected player can rejoin with same nickname to restore session, and game resumes automatically on successful reconnection.
</done>
</task>

</tasks>

<verification>
Run backend tests to ensure:
- Heartbeat mechanism doesn't crash server
- Pause/resume methods work correctly
- Session restoration handles reconnection flow
</verification>

<success_criteria>

- WebSocket connections tracked with isAlive flag
- Ping/pong sent every 30 seconds
- Dead connections detected and removed
- Game pauses when player disconnects (isPaused = true)
- Disconnected players stored in disconnectedPlayers map
- Rejoining with same nickname restores session and resumes game
- Pause/resume messages broadcast to all players in room
  </success_criteria>

<output>
After completion, create `.planning/phases/12-resilience-polish/12-01-SUMMARY.md`
</output>
