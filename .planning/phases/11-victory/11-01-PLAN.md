---
phase: 11-victory
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - libs/shared/src/schemas/game.ts
  - libs/shared/src/schemas/messages.ts
  - apps/api/src/game/victory-logic.ts
  - apps/api/src/game/victory-logic.spec.ts
autonomous: true

must_haves:
  truths:
    - 'VP calculation produces correct totals for all VP sources'
    - 'Victory check returns winner when any player reaches 10 VP'
    - 'VP breakdown shows settlements, cities, longest road, largest army, VP cards'
  artifacts:
    - path: 'apps/api/src/game/victory-logic.ts'
      provides: 'calculateVictoryPoints and checkForVictory pure functions'
      exports:
        [
          'calculateVictoryPoints',
          'checkForVictory',
          'VPBreakdown',
          'VictoryResult',
        ]
    - path: 'apps/api/src/game/victory-logic.spec.ts'
      provides: 'TDD tests covering all VP calculation edge cases'
      min_lines: 100
    - path: 'libs/shared/src/schemas/messages.ts'
      provides: 'VictoryMessageSchema for game end announcement'
      contains: 'VictoryMessageSchema'
  key_links:
    - from: 'victory-logic.ts'
      to: '@catan/shared types'
      via: 'Settlement, OwnedDevCard imports'
      pattern: "import.*from '@catan/shared'"
---

<objective>
Create VP calculation logic using TDD and add victory message schema.

Purpose: Establish the core VP calculation algorithm and victory message contract that all other victory features depend on.
Output: Pure functions for VP calculation with comprehensive test coverage, plus Zod schemas for victory WebSocket messages.
</objective>

<execution_context>
@/Users/bmcalindin/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-victory/11-RESEARCH.md

# Existing patterns to follow

@libs/shared/src/schemas/messages.ts
@apps/api/src/game/longest-road-logic.ts
@apps/api/src/game/largest-army-logic.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create victory-logic.ts with TDD tests</name>
  <files>
    apps/api/src/game/victory-logic.ts
    apps/api/src/game/victory-logic.spec.ts
  </files>
  <action>
Create victory-logic.ts with pure functions following the longest-road-logic.ts pattern.

**RED phase - Write failing tests first in victory-logic.spec.ts:**

Test cases for calculateVictoryPoints():

1. Empty player (0 settlements, no awards, no VP cards) = 0 VP
2. 2 settlements only = 2 VP
3. 1 city only = 2 VP (city replaces settlement slot)
4. 2 settlements + 1 city = 4 VP
5. Has longest road = +2 VP
6. Has largest army = +2 VP
7. Has 2 VP cards = +2 VP
8. Full combination (2 settlements, 1 city, longest road, largest army, 1 VP card) = 2+2+2+2+1 = 9 VP

Test cases for checkForVictory():

1. No player at 10 VP = gameEnded: false, winnerId: null
2. One player exactly at 10 VP = gameEnded: true, winnerId set
3. Multiple players above 10 VP (edge case) = first player in order wins
4. Winner with VP cards = revealedVPCards populated
5. Winner without VP cards = revealedVPCards empty array

**GREEN phase - Implement functions:**

```typescript
export interface VPBreakdown {
  settlements: number;    // Count of non-city settlements
  cities: number;         // Count * 2
  longestRoad: number;    // 2 if holder, 0 otherwise
  largestArmy: number;    // 2 if holder, 0 otherwise
  victoryPointCards: number; // Count of VP dev cards
  total: number;
}

export interface VictoryResult {
  gameEnded: boolean;
  winnerId: string | null;
  winnerVP: VPBreakdown | null;
  allPlayerVP: Record<string, VPBreakdown>;
  revealedVPCards: Array<{ playerId: string; cardCount: number }>;
}

export const VICTORY_POINT_THRESHOLD = 10;

export function calculateVictoryPoints(
  playerId: string,
  settlements: Settlement[],
  longestRoadHolderId: string | null,
  largestArmyHolderId: string | null,
  playerDevCards: OwnedDevCard[],
): VPBreakdown { ... }

export function checkForVictory(
  playerIds: string[],
  settlements: Settlement[],
  longestRoadHolderId: string | null,
  largestArmyHolderId: string | null,
  getPlayerDevCards: (playerId: string) => OwnedDevCard[],
): VictoryResult { ... }
```

Import Settlement and OwnedDevCard from @catan/shared.
</action>
<verify>npm run test -- --filter victory-logic --run</verify>
<done>All TDD tests pass, calculateVictoryPoints returns correct VP breakdown, checkForVictory detects winners at 10+ VP</done>
</task>

<task type="auto">
  <name>Task 2: Add VictoryMessageSchema and GameState gamePhase field</name>
  <files>
    libs/shared/src/schemas/messages.ts
    libs/shared/src/schemas/game.ts
  </files>
  <action>
**In game.ts:**

Add gamePhase field to GameStateSchema:

```typescript
gamePhase: z.enum(['setup', 'playing', 'ended']).default('setup'),
winnerId: z.string().nullable().default(null),
```

Export VPBreakdownSchema for reuse:

```typescript
export const VPBreakdownSchema = z.object({
  settlements: z.number(),
  cities: z.number(),
  longestRoad: z.number(),
  largestArmy: z.number(),
  victoryPointCards: z.number(),
  total: z.number(),
});
```

**In messages.ts:**

Add VictoryMessageSchema following existing patterns:

```typescript
export const VictoryMessageSchema = z.object({
  type: z.literal('victory'),
  winnerId: z.string(),
  winnerNickname: z.string(), // For display
  winnerVP: VPBreakdownSchema,
  allPlayerVP: z.record(z.string(), VPBreakdownSchema),
  revealedVPCards: z.array(
    z.object({
      playerId: z.string(),
      cardCount: z.number(),
    }),
  ),
});
```

Add to WebSocketMessageSchema discriminated union.
Export VictoryMessage type.
</action>
<verify>npm run build:shared && npm run typecheck</verify>
<done>VictoryMessageSchema added to discriminated union, VPBreakdownSchema exported, GameState has gamePhase and winnerId fields</done>
</task>

</tasks>

<verification>
- [ ] npm run test -- --filter victory-logic --run passes all tests
- [ ] npm run build:shared succeeds
- [ ] npm run typecheck succeeds across all packages
- [ ] VictoryMessage type is importable from @catan/shared
</verification>

<success_criteria>

- Pure VP calculation function with correct arithmetic for all sources
- 10+ test cases covering edge cases
- VictoryMessageSchema follows existing message patterns
- GameState schema supports ended game phase
  </success_criteria>

<output>
After completion, create `.planning/phases/11-victory/11-01-SUMMARY.md`
</output>
