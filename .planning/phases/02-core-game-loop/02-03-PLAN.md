---
phase: 02-core-game-loop
plan: 03
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - apps/web/src/game/Board/HexGrid.tsx
  - apps/web/src/game/Board/HexTile.tsx
  - apps/web/src/game/Board/Settlement.tsx
  - apps/web/src/game/Board/Road.tsx
  - apps/web/src/stores/gameStore.ts
  - apps/web/src/app/app.tsx
autonomous: true

must_haves:
  truths:
    - "User sees hexagonal game board with 19 terrain tiles"
    - "Each hex displays terrain type (illustrated SVG) and number token"
    - "Number tokens show probability pips (dots)"
    - "Settlements and roads render on board in player colors"
    - "Board animates entrance when first generated"
  artifacts:
    - path: "apps/web/src/game/Board/HexGrid.tsx"
      provides: "Board container with react-hexgrid"
      exports: ["HexGrid"]
      min_lines: 60
    - path: "apps/web/src/game/Board/HexTile.tsx"
      provides: "Individual hex rendering"
      exports: ["HexTile"]
      min_lines: 40
    - path: "apps/web/src/stores/gameStore.ts"
      provides: "Zustand store for game state"
      exports: ["useGameStore"]
      min_lines: 30
  key_links:
    - from: "apps/web/src/game/Board/HexGrid.tsx"
      to: "apps/web/src/stores/gameStore.ts"
      via: "reads game state from store"
      pattern: "useGameStore.*gameState"
    - from: "apps/web/src/game/Board/HexTile.tsx"
      to: "apps/web/src/assets/tiles"
      via: "imports terrain SVGs"
      pattern: "import.*tiles/.*(forest|mountains|hills|fields|pasture|desert)"
---

<objective>
Render interactive hexagonal game board using react-hexgrid with terrain tiles, number tokens, and game pieces. Display SVG terrain illustrations from existing assets, show number probability pips, and render settlements/roads in player colors. Animate board entrance when first generated.

Purpose: Provide visual representation of game state. After this plan, users can see the board generated in Plan 02 and watch placements appear in real-time.

Output: Working hex board component that syncs with game state via Zustand, displays all terrain types and numbers, and renders player pieces.
</objective>

<execution_context>
@./.github/get-shit-done/workflows/execute-plan.md
@./.github/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-game-loop/02-CONTEXT.md
@.planning/phases/02-core-game-loop/02-RESEARCH.md
@libs/shared/src/schemas/game.ts
@libs/shared/src/utils/coordinates.ts
@apps/web/src/services/websocket.ts
@apps/web/src/hooks/useWebSocket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zustand game store with WebSocket sync</name>
  <files>apps/web/src/stores/gameStore.ts</files>
  <action>
Create `apps/web/src/stores/gameStore.ts` with Zustand store for game state following RESEARCH.md Pattern 5:

```typescript
import { create } from 'zustand';
import { GameState, AxialCoord } from '@catan/shared';

interface GameStore {
  gameState: GameState | null;
  selectedVertex: string | null;
  selectedEdge: string | null;
  updateGameState: (state: GameState) => void;
  selectVertex: (vertexId: string | null) => void;
  selectEdge: (edgeId: string | null) => void;
}

export const useGameStore = create<GameStore>((set) => ({
  gameState: null,
  selectedVertex: null,
  selectedEdge: null,
  updateGameState: (state) => set({ gameState: state }),
  selectVertex: (vertexId) => set({ selectedVertex: vertexId }),
  selectEdge: (edgeId) => set({ selectedEdge: edgeId }),
}));
```

Wire up WebSocket sync in `apps/web/src/hooks/useWebSocket.ts` or `apps/web/src/services/websocket.ts`:

**Add to WebSocket message handler**:
```typescript
// In existing WebSocket onmessage handler
if (message.type === 'game_state') {
  useGameStore.getState().updateGameState(message.gameState);
}
```

**Specific file**: Update `apps/web/src/hooks/useWebSocket.ts` in the message handling switch/if statement. Add case for 'game_state' that calls the store's updateGameState action.

Store is lightweight - just game state and UI selections. No complex logic here. All game logic remains server-authoritative.
  </action>
  <verify>
Test store: `const state = useGameStore.getState(); state.updateGameState({...mockGameState}); console.log(state.gameState);` - Should log updated state.

Test WebSocket sync: Send mock 'game_state' message through WebSocket, verify gameStore.gameState updates automatically.
  </verify>
  <done>
gameStore.ts exists with Zustand store. WebSocket message handler calls updateGameState. Store syncs game state from server.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create hex tile component with terrain SVGs and number tokens</name>
  <files>apps/web/src/game/Board/HexTile.tsx</files>
  <action>
Create `apps/web/src/game/Board/HexTile.tsx` that renders individual hex with terrain and number:

**Component props**: `{ hex: HexTile, onClick?: () => void }`

**Rendering**:
- Use existing SVG terrain tiles from `apps/web/src/assets/tiles/{terrain}.svg`
- Map terrain types: wood→forest.svg, wheat→fields.svg, sheep→pasture.svg, brick→hills.svg, ore→mountains.svg, desert→desert.svg
- Import SVGs as React components or use img tags
- Render terrain as hexagon background/fill
- Render number token as circular overlay with number text
- Add probability pips (dots) below number: 2/12=1 dot, 3/11=2 dots, 4/10=3 dots, 5/9=4 dots, 6/8=5 dots (classic Catan style)
- Highlight 6 and 8 in red or bold (high probability)
- Show robber icon if hex.hasRobber is true (simple ⛔ or black circle for now)

**Styling**:
- Hex should be approximately 80-100px wide
- Number token: white circle with black border, centered on hex
- Pips: small circles below number
- Use SVG patterns or CSS for hexagon shape if needed

Follow CONTEXT.md: "Use existing SVG tiles in `./apps/web/src/assets/tiles`". Desktop-first responsive design (mobile is v2).
  </action>
  <verify>
Test rendering by creating mock HexTile data with each terrain type. Verify all 6 terrain SVGs load correctly. Check number tokens display with correct pip counts.
  </verify>
  <done>
HexTile.tsx component exists. All terrain types render with SVG assets. Number tokens show with probability pips. Robber icon displays on desert hex.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create HexGrid container with react-hexgrid and entrance animation</name>
  <files>apps/web/src/game/Board/HexGrid.tsx</files>
  <action>
Create `apps/web/src/game/Board/HexGrid.tsx` as board container using react-hexgrid following RESEARCH.md Pattern 5:

```typescript
import { HexGrid as ReactHexGrid, Layout, Hexagon } from 'react-hexgrid';
import { motion } from 'motion/react';
import { useGameStore } from '../../stores/gameStore';
import { HexTile } from './HexTile';

export function HexGrid() {
  const gameState = useGameStore((s) => s.gameState);
  
  if (!gameState) return <div>Loading game...</div>;
  
  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.95 }}
      animate={{ opacity: 1, scale: 1 }}
      transition={{ duration: 0.6, ease: 'easeOut' }}
    >
      <ReactHexGrid width={900} height={700} viewBox="-50 -50 100 100">
        <Layout size={{ x: 10, y: 10 }} flat={false} spacing={1.05}>
          {gameState.board.hexes.map((hex) => (
            <Hexagon
              key={`${hex.coord.q},${hex.coord.r}`}
              q={hex.coord.q}
              r={hex.coord.r}
              s={-hex.coord.q - hex.coord.r}
            >
              <HexTile hex={hex} />
            </Hexagon>
          ))}
        </Layout>
      </ReactHexGrid>
    </motion.div>
  );
}
```

**Layout settings**:
- `flat={false}` for pointy-top hexagons (standard Catan orientation)
- `spacing={1.05}` for slight gap between hexes (clean look)
- Adjust size and viewBox for optimal rendering

**Entrance animation** (CONTEXT.md requirement): Use Framer Motion to fade in and slightly scale up when board first mounts (~600ms duration).

Handle null gameState gracefully (show loading or return to lobby).
  </action>
  <verify>
Test by rendering HexGrid with mock game state containing 19 hexes. Verify all hexes appear in correct positions. Check entrance animation plays on mount.
  </verify>
  <done>
HexGrid.tsx component exists using react-hexgrid. All 19 hexes render in spiral layout. Entrance animation works. Component syncs with gameStore.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create Settlement and Road piece components</name>
  <files>apps/web/src/game/Board/Settlement.tsx, apps/web/src/game/Board/Road.tsx, apps/web/src/game/Board/HexGrid.tsx</files>
  <action>
Create game piece components and integrate into HexGrid:

**apps/web/src/game/Board/Settlement.tsx**:
- Props: `{ vertexId: string, color: string, isCity: boolean }`
- Render simple SVG shape: house icon for settlement (square with triangle roof), larger building for city
- Color fill based on player color
- Position at vertex coordinates (derive from vertexId)

**apps/web/src/game/Board/Road.tsx**:
- Props: `{ edgeId: string, color: string }`
- Render SVG rect/line as road
- Color based on player color
- Position along edge between two hexes

**Update HexGrid.tsx**:
- After rendering hexes, render all settlements and roads from gameState.players
- Loop through each player's settlements/cities/roads arrays
- Render Settlement/Road components with player's color
- Use SVG layer ordering so pieces appear on top of hexes

**Vertex/edge positioning**:
- Parse vertexId "q:r:v" to get hex coord and vertex index (0-5)
- Calculate vertex position: hexes have 6 vertices, compute pixel coordinates
- Parse edgeId "q1:r1-q2:r2" to get edge position between two hexes
- Use react-hexgrid's coordinate system or custom calculations

Pieces should be small and not obstruct hex details. Use player colors from PLAYER_COLORS constant (established in Phase 1).
  </action>
  <verify>
Test by placing settlements and roads in gameStore state. Verify pieces render at correct positions in player colors. Check layering (pieces on top of hexes).
  </verify>
  <done>
Settlement.tsx and Road.tsx components exist. Pieces render in player colors at correct vertex/edge positions. HexGrid displays all pieces from game state.
  </done>
</task>

<task type="auto">
  <name>Task 5: Integrate HexGrid into app navigation</name>
  <files>apps/web/src/app/app.tsx</files>
  <action>
Update main App component to show HexGrid when game starts:

Add conditional rendering based on gameStore.gameState:
- If gameState is null: show existing lobby components (LandingForm, Lobby)
- If gameState exists and phase is 'initial_placement' or 'gameplay': show HexGrid

Simple approach:
```typescript
const gameState = useGameStore((s) => s.gameState);

if (gameState) {
  return <HexGrid />;
}

// Existing lobby UI
return <LandingForm /> or <Lobby />
```

This replaces lobby UI when game starts. In Phase 3 we'll add turn indicators and resource UI alongside the board.

Import HexGrid component and ensure WebSocket connection persists when switching views.
  </action>
  <verify>
Test flow: Create room → Start game → Board appears. Verify board renders when 'game_state' message received. Check WebSocket stays connected.
  </verify>
  <done>
App.tsx conditionally renders HexGrid when gameState exists. Board displays after game start. Lobby→Game transition works smoothly.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Store syncs**: Send mock 'game_state' WebSocket message, verify gameStore updates
2. **Hexes render**: All 19 hexes display with correct terrain SVGs and number tokens
3. **Pips display**: Number tokens show correct pip counts (1-5 dots based on probability)
4. **Animation works**: Board fades in with scale animation on first render
5. **Pieces render**: Settlements and roads appear in player colors at correct positions
6. **Navigation works**: Lobby→Board transition when game starts
</verification>

<success_criteria>
- Zustand game store syncs with WebSocket game_state messages
- HexGrid component renders 19-hex board using react-hexgrid
- Each hex displays terrain SVG from existing assets and number token with pips
- Board entrance animation plays when first generated (fade + scale ~600ms)
- Settlement and Road components render in player colors at vertex/edge positions
- App transitions from lobby to board view when game state exists
- All terrain types (wood, wheat, sheep, brick, ore, desert) render correctly
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-game-loop/02-03-SUMMARY.md` documenting:
- react-hexgrid integration approach and layout configuration
- Terrain SVG asset mapping and rendering strategy
- Number token and pip rendering approach
- Settlement/Road positioning calculations (vertex/edge coordinate system)
- Game store and WebSocket synchronization pattern
- Any rendering challenges or deviations from plan
</output>
