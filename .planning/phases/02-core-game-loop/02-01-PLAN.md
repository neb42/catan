---
phase: 02-core-game-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - libs/shared/src/schemas/game.ts
  - libs/shared/src/index.ts
  - apps/api/src/game/BoardGenerator.ts
  - apps/api/src/game/GameState.ts
  - libs/shared/src/utils/coordinates.ts
  - libs/shared/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Game can generate random 19-hex Catan board"
    - "Generated board follows Catan rules (no adjacent 6/8)"
    - "Board includes terrain types, number tokens, and ports"
    - "Hex coordinate system supports neighbor finding"
  artifacts:
    - path: "libs/shared/src/schemas/game.ts"
      provides: "Game state Zod schemas"
      exports: ["GameStateSchema", "BoardSchema", "HexTileSchema"]
      min_lines: 80
    - path: "apps/api/src/game/BoardGenerator.ts"
      provides: "Board generation algorithm"
      exports: ["generateBoard"]
      min_lines: 100
    - path: "libs/shared/src/utils/coordinates.ts"
      provides: "Hex coordinate utilities"
      exports: ["axialToCube", "cubeToAxial", "getNeighbors"]
      min_lines: 40
  key_links:
    - from: "apps/api/src/game/BoardGenerator.ts"
      to: "libs/shared/src/schemas/game.ts"
      via: "imports Board type"
      pattern: "import.*Board.*from.*@catan/shared"
    - from: "apps/api/src/game/BoardGenerator.ts"
      to: "libs/shared/src/utils/coordinates.ts"
      via: "imports and uses hex coordinate functions"
      pattern: "import.*(getNeighbors|axialToCube).*from.*@catan/shared"
---

<objective>
Establish game foundation with board generation algorithm, hex coordinate system, and game state schemas. Install hex libraries (react-hexgrid, honeycomb-grid, motion) and create server-side board generator that produces valid Catan layouts with terrain distribution, number tokens, and ports.

Purpose: Provide the data structures and algorithms needed for all subsequent game features. Board generation is the root dependency for initial placement, rendering, and gameplay.

Output: Working board generator that creates random Catan boards following all standard rules, plus shared game state schemas and hex coordinate utilities.
</objective>

<execution_context>
@./.github/get-shit-done/workflows/execute-plan.md
@./.github/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-game-loop/02-CONTEXT.md
@.planning/phases/02-core-game-loop/02-RESEARCH.md
@libs/shared/src/schemas/messages.ts
@libs/shared/src/schemas/room.ts
@libs/shared/src/schemas/player.ts
@libs/shared/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install hex grid libraries and animation library</name>
  <files>package.json</files>
  <action>
Install three npm packages for hex grid rendering, hex math, and animations:

```bash
npm install react-hexgrid honeycomb-grid motion
```

Versions:
- react-hexgrid: ^2.0.1 (SVG hex rendering for React)
- honeycomb-grid: ^4.1.5 (hex coordinate math utilities)
- motion: ^12.27.5 (Framer Motion for animations)

These are standard libraries identified in RESEARCH.md. react-hexgrid provides SVG hexagon rendering with cubic coordinates, honeycomb-grid provides hex math (neighbors, distance), and motion (Framer Motion) provides hardware-accelerated React animations for dice rolls and resource cards.
  </action>
  <verify>
Run `npm list react-hexgrid honeycomb-grid motion` to confirm installation. All three packages should appear in dependency tree.
  </verify>
  <done>
package.json contains react-hexgrid, honeycomb-grid, and motion in dependencies. npm list shows all three packages installed successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create game state Zod schemas with board, hex, player resources</name>
  <files>libs/shared/src/schemas/game.ts, libs/shared/src/index.ts</files>
  <action>
Create `libs/shared/src/schemas/game.ts` with comprehensive Zod schemas for game state:

**HexCoordSchema**: Axial coordinates (q, r)
**HexTileSchema**: Individual hex with coord, terrain ('wood'|'wheat'|'sheep'|'brick'|'ore'|'desert'), number (2-12 or null), hasRobber boolean
**PortSchema**: Port with position (edge identifier string), type ('3:1' or '2:1-{resource}')
**BoardSchema**: hexes array, ports array
**PlayerResourcesSchema**: {wood, wheat, sheep, brick, ore} all numbers
**GamePlayerSchema**: Extends PlayerSchema from player.ts with resources, settlements (vertex ID strings), cities, roads (edge ID strings), victoryPoints
**GameStateSchema**: roomId, phase ('initial_placement'|'gameplay'|'game_over'), turnPhase ('roll'|'main'|'end' or null), currentPlayer (player ID), board, players array, placementRound (1-8 or null), lastDiceRoll (tuple [number, number] or null)

Export all schemas plus inferred TypeScript types. Use terrain distribution from RESEARCH.md (4 wood, 4 wheat, 4 sheep, 3 brick, 3 ore, 1 desert).

Add to `libs/shared/src/index.ts`: `export * from './schemas/game';`

Reference existing PlayerSchema pattern from player.ts for consistency.
  </action>
  <verify>
Run `npx tsc --noEmit -p libs/shared/tsconfig.json` to verify schemas compile without errors. Check that GameStateSchema exports include all required fields from RESEARCH.md Pattern 1.
  </verify>
  <done>
libs/shared/src/schemas/game.ts exists with complete Zod schemas for game state. All types export successfully. TypeScript compilation passes with no errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create hex coordinate utility functions in shared library</name>
  <files>libs/shared/src/utils/coordinates.ts, libs/shared/src/index.ts</files>
  <action>
Create `libs/shared/src/utils/coordinates.ts` with cubic coordinate system utilities following Red Blob Games patterns from RESEARCH.md Pattern 2:

**Types**: CubeCoord {q, r, s}, AxialCoord {q, r}

**Functions**:
- `axialToCube(hex: AxialCoord): CubeCoord` - converts axial to cubic (s = -q - r)
- `cubeToAxial(cube: CubeCoord): AxialCoord` - converts cubic to axial
- `cubeNeighbor(cube: CubeCoord, direction: number): CubeCoord` - gets neighbor in direction 0-5
- `cubeDistance(a: CubeCoord, b: CubeCoord): number` - Manhattan distance in hex grid
- `getNeighbors(coord: AxialCoord): AxialCoord[]` - returns all 6 neighbors

Use the 6 direction vectors from RESEARCH.md: [{q:+1,r:0,s:-1}, {q:+1,r:-1,s:0}, {q:0,r:-1,s:+1}, {q:-1,r:0,s:+1}, {q:-1,r:+1,s:0}, {q:0,r:+1,s:-1}]

Place in shared library since BoardGenerator (API) needs these functions. Both frontend and backend can import from @catan/shared.

Add to `libs/shared/src/index.ts`: `export * from './utils/coordinates';`
  </action>
  <verify>
Create simple test: verify getNeighbors({q:0, r:0}) returns 6 distinct coordinates. Verify cubeDistance({q:0,r:0,s:0}, {q:2,r:0,s:-2}) === 2.

Test import from both apps: `import { getNeighbors } from '@catan/shared'` in api and web.
  </verify>
  <done>
Hex coordinate utilities exist in shared library with all 5 functions implemented. Both API and web can import from @catan/shared. Manual verification confirms neighbor finding and distance calculations work correctly.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create board generation algorithm with validation</name>
  <files>apps/api/src/game/BoardGenerator.ts, apps/api/src/game/GameState.ts</files>
  <action>
Create `apps/api/src/game/BoardGenerator.ts` implementing board generation following RESEARCH.md Pattern 3:

**Terrain distribution** (19 tiles): 4 wood, 4 wheat, 4 sheep, 3 brick, 3 ore, 1 desert
**Number tokens** (18 tokens): [2, 3, 3, 4, 4, 5, 5, 6, 6, 8, 8, 9, 9, 10, 10, 11, 11, 12]
**Ports** (9 total): 4 generic (3:1), 5 specific (2:1-wood, 2:1-wheat, 2:1-sheep, 2:1-brick, 2:1-ore)

**Functions**:
- `shuffle<T>(array: T[]): T[]` - Fisher-Yates shuffle (correct, not Array.sort(Math.random))
- `spiralCoordinates(): AxialCoord[]` - generates 19 hex coords in spiral (center, ring1 6 hexes, ring2 12 hexes)
- `validateNoAdjacent68(hexes: HexTile[]): boolean` - checks no adjacent 6/8 using getNeighbors
- `generatePorts(hexes: HexTile[]): Port[]` - places 9 ports on coast edges
- `generateBoard(mode: 'balanced' | 'natural'): Board` - main function, shuffles terrain+numbers, assigns to spiral coords, validates, retries if invalid, generates ports

Create `apps/api/src/game/GameState.ts` with `createInitialGameState(roomId: string, players: Player[]): GameState` that calls generateBoard and returns initial state with phase='initial_placement', placementRound=1, currentPlayer=players[0].id

Import coordinate functions from @catan/shared: `import { getNeighbors } from '@catan/shared';`. Use mode from env var `BOARD_GEN_MODE` (default 'balanced').

Desert hex gets no number token (number: null) and starts with hasRobber: true. All other hexes hasRobber: false.
  </action>
  <verify>
Run `node -e "const {generateBoard} = require('./apps/api/src/game/BoardGenerator.ts'); const board = generateBoard('balanced'); console.log(board.hexes.length, board.ports.length);"` (using ts-node if needed). Should output "19 9".

Verify no adjacent 6/8: generate 10 boards, check all pass validation.
  </verify>
  <done>
BoardGenerator.ts and GameState.ts exist. generateBoard produces 19 hexes and 9 ports. Validation ensures no adjacent 6/8. createInitialGameState returns complete initial game state structure.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Dependencies installed**: `npm list` shows react-hexgrid, honeycomb-grid, motion
2. **Schemas compile**: `npx tsc --noEmit -p libs/shared/tsconfig.json` passes
3. **Board generation works**: Call generateBoard, verify 19 hexes, 9 ports, no adjacent 6/8
4. **Coordinates work**: getNeighbors returns 6 neighbors, distance calculation correct
5. **Initial state creates**: createInitialGameState returns valid GameState object
</verification>

<success_criteria>
- react-hexgrid, honeycomb-grid, and motion are installed as dependencies
- GameState Zod schemas exist in shared library with complete type definitions
- Board generator produces valid 19-hex Catan boards with balanced terrain distribution
- Generated boards never have adjacent 6/8 number tokens
- Hex coordinate utilities provide neighbor finding and distance calculations
- Initial game state factory function creates complete game state objects
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-game-loop/02-01-SUMMARY.md` documenting:
- Libraries installed and why each was chosen
- Game state schema structure and key design decisions
- Board generation algorithm approach and validation strategy
- Any deviations from planned approach
</output>
