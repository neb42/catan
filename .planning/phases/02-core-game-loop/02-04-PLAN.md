---
phase: 02-core-game-loop
plan: 04
type: execute
wave: 3
depends_on: [02-02]
files_modified:
  - apps/api/src/managers/GameManager.ts
  - apps/api/src/game/TurnManager.ts
  - apps/api/src/handlers/websocket.ts
  - libs/shared/src/schemas/messages.ts
  - apps/web/src/game/UI/DiceRoller.tsx
autonomous: true

must_haves:
  truths:
    - "Players take turns in consistent round-robin order (P1→P2→P3→P4→P1...)"
    - "Current player can roll dice to generate random number 2-12"
    - "Dice roll distributes resources to players with settlements/cities on matching hexes"
    - "Turn progresses through phases: roll → main → end"
    - "Players see dice animation and results immediately"
  artifacts:
    - path: "apps/api/src/game/TurnManager.ts"
      provides: "Turn structure and dice rolling logic"
      exports: ["rollDice", "distributeResources", "advanceTurn"]
      min_lines: 80
    - path: "apps/web/src/game/UI/DiceRoller.tsx"
      provides: "Dice roll animation component"
      exports: ["DiceRoller"]
      min_lines: 40
  key_links:
    - from: "apps/api/src/managers/GameManager.ts"
      to: "apps/api/src/game/TurnManager.ts"
      via: "calls rollDice and advanceTurn"
      pattern: "(rollDice|advanceTurn)\\("
    - from: "apps/web/src/game/UI/DiceRoller.tsx"
      to: "apps/web/src/stores/gameStore.ts"
      via: "reads lastDiceRoll from game state"
      pattern: "useGameStore.*lastDiceRoll"
---

<objective>
Implement turn structure with dice rolling, resource distribution, and turn phase progression. Server generates random dice rolls, distributes resources to players with settlements/cities on matching hexes, and enforces round-robin turn order. Client displays animated dice roll results.

Purpose: Make the game playable with basic turn mechanics. After this plan, games can progress from initial placement through multiple turns with resource generation.

Output: Working turn system where players roll dice, see animations, receive resources from matching hexes, and advance to next player.
</objective>

<execution_context>
@./.github/get-shit-done/workflows/execute-plan.md
@./.github/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-game-loop/02-CONTEXT.md
@.planning/phases/02-core-game-loop/02-RESEARCH.md
@libs/shared/src/schemas/game.ts
@apps/api/src/managers/GameManager.ts
@apps/api/src/game/PlacementValidator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TurnManager with dice rolling and resource distribution</name>
  <files>apps/api/src/game/TurnManager.ts</files>
  <action>
Create `apps/api/src/game/TurnManager.ts` with turn mechanics following RESEARCH.md Patterns 1 and resource distribution code example:

**rollDice(gameState: GameState, playerId: string): { die1: number, die2: number }**:
- Validate: currentPlayer === playerId and turnPhase === 'roll'
- Generate random dice: `Math.floor(Math.random() * 6) + 1` for each die
- Update gameState.lastDiceRoll = [die1, die2]
- Set gameState.turnPhase = 'main'
- Call distributeResources(gameState, die1 + die2)
- Return dice values

**distributeResources(gameState: GameState, roll: number): void**:
- Find all hexes where hex.number === roll and hex.hasRobber === false
- For each matching hex:
  - Get hex vertices (6 vertices per hex, compute vertex IDs)
  - Check each vertex for settlements/cities from any player
  - If player has settlement on vertex: +1 resource of hex.terrain type
  - If player has city on vertex: +2 resources of hex.terrain type
  - Update player.resources[terrain] accordingly
- Skip desert hexes (terrain === 'desert')
- Use vertex ID format from PlacementValidator (q:r:v)

**advanceTurn(gameState: GameState): void**:
- Find currentPlayer index in players array
- Increment index (mod players.length for wrap-around)
- Set gameState.currentPlayer = players[nextIndex].id
- Set gameState.turnPhase = 'roll'
- Clear gameState.lastDiceRoll = null (ready for next roll)

**getHexVertices(hexCoord: AxialCoord): string[]**:
- Helper function that returns 6 vertex IDs for a hex
- Format: "q:r:v" where v is 0-5 for each of 6 vertices
- Example: hex at (0,0) has vertices ["0:0:0", "0:0:1", "0:0:2", "0:0:3", "0:0:4", "0:0:5"]

Follow CONTEXT.md: "Server-authoritative rolls", "Resource distribution feedback: show both explicit text log AND animated cards", "Zero-resource rolls: Display 'No resources this roll' message".

Server is authoritative - client never calculates dice or resources locally.
  </action>
  <verify>
Test resource distribution:
- Create game state with settlements at known positions
- Roll matching number, verify correct resources granted
- Test edge cases: robber blocking, desert, no settlements on number
  </verify>
  <done>
TurnManager.ts exists with rollDice, distributeResources, and advanceTurn functions. Dice generation is server-authoritative. Resource distribution correctly grants resources based on settlements/cities and hex numbers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate turn mechanics into GameManager</name>
  <files>apps/api/src/managers/GameManager.ts</files>
  <action>
Extend GameManager with turn methods:

**Add methods**:
- `rollDice(roomId: string, playerId: string): GameState` - calls TurnManager.rollDice, returns updated state
- `endTurn(roomId: string, playerId: string): GameState` - calls TurnManager.advanceTurn, returns updated state

**Update createGame**:
- After initial placement completes (phase transitions to 'gameplay'), set turnPhase='roll' and currentPlayer=players[0].id

**Phase transition logic**:
- When advanceInitialPlacement detects round 8 complete:
  - Set phase = 'gameplay'
  - Set turnPhase = 'roll'
  - Set currentPlayer = players[0].id (first player in regular turn order)

Import TurnManager functions. All turn operations return full game state for broadcasting. Validate player identity and turn phase before allowing actions.

Error handling:
- "Not your turn" if playerId !== currentPlayer
- "Wrong phase" if action doesn't match turnPhase (e.g., rolling during 'main' phase)
  </action>
  <verify>
Test turn flow:
1. Complete initial placement (8 rounds)
2. Verify phase='gameplay', turnPhase='roll'
3. Call rollDice for currentPlayer
4. Verify turnPhase='main', resources distributed
5. Call endTurn
6. Verify next player is currentPlayer, turnPhase='roll'
  </verify>
  <done>
GameManager extended with rollDice and endTurn methods. Phase transition from initial placement to gameplay works correctly. Turn mechanics integrated and functional.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire WebSocket handlers for turn actions</name>
  <files>apps/api/src/handlers/websocket.ts, libs/shared/src/schemas/messages.ts</files>
  <action>
Add turn action messages to WebSocket protocol:

**Add to libs/shared/src/schemas/messages.ts**:
```typescript
export const RollDiceMessageSchema = z.object({
  type: z.literal('roll_dice'),
  playerId: z.string(),
});

export const EndTurnMessageSchema = z.object({
  type: z.literal('end_turn'),
  playerId: z.string(),
});
```

Add to WebSocketMessageSchema discriminated union.

**In apps/api/src/handlers/websocket.ts**:
- Add handler for 'roll_dice': calls gameManager.rollDice, broadcasts game_state
- Add handler for 'end_turn': calls gameManager.endTurn, broadcasts game_state
- Wrap in try-catch, send error messages for validation failures ("Not your turn", "Wrong phase", etc.)

Broadcast full game state to all players in room after each action. Use same broadcast pattern from initial placement handlers.

Follow CONTEXT.md: "Server-authoritative rolls: Dice roll calculated on server, instant broadcast of final result to all clients (everyone sees same numbers simultaneously)".
  </action>
  <verify>
Test WebSocket flow:
1. Send 'roll_dice' from currentPlayer
2. Receive 'game_state' with lastDiceRoll filled, turnPhase='main', resources updated
3. Send 'roll_dice' from non-currentPlayer
4. Receive 'error' message "Not your turn"
5. Send 'end_turn' from currentPlayer
6. Receive 'game_state' with new currentPlayer
  </verify>
  <done>
WebSocket handlers for roll_dice and end_turn added. Error handling validates player identity and turn phase. State broadcasts work correctly after turn actions.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create DiceRoller UI component with animation</name>
  <files>apps/web/src/game/UI/DiceRoller.tsx</files>
  <action>
Create `apps/web/src/game/UI/DiceRoller.tsx` following RESEARCH.md Pattern 6 (Framer Motion animations):

**Component**: Display dice roll results with animation

```typescript
import { motion } from 'motion/react';
import { useGameStore } from '../../stores/gameStore';

export function DiceRoller() {
  const lastRoll = useGameStore((s) => s.gameState?.lastDiceRoll);
  const currentPlayer = useGameStore((s) => s.gameState?.currentPlayer);
  const myPlayerId = useGameStore((s) => s.myPlayerId); // Add to store if needed
  const turnPhase = useGameStore((s) => s.gameState?.turnPhase);
  
  const canRoll = currentPlayer === myPlayerId && turnPhase === 'roll';
  
  return (
    <div style={{ padding: '1rem' }}>
      {lastRoll && (
        <div style={{ display: 'flex', gap: '1rem', marginBottom: '1rem' }}>
          <motion.div
            initial={{ scale: 0, rotate: 0 }}
            animate={{ scale: 1, rotate: 360 }}
            transition={{ duration: 0.5, ease: 'easeOut' }}
            className="die"
          >
            {lastRoll[0]}
          </motion.div>
          <motion.div
            initial={{ scale: 0, rotate: 0 }}
            animate={{ scale: 1, rotate: 360 }}
            transition={{ duration: 0.5, ease: 'easeOut', delay: 0.1 }}
            className="die"
          >
            {lastRoll[1]}
          </motion.div>
          <div>Total: {lastRoll[0] + lastRoll[1]}</div>
        </div>
      )}
      
      {canRoll && (
        <button onClick={handleRollDice}>Roll Dice</button>
      )}
    </div>
  );
  
  function handleRollDice() {
    // Send 'roll_dice' WebSocket message
    websocket.send({ type: 'roll_dice', playerId: myPlayerId });
  }
}
```

**Styling**:
- Dice: 60x60px white squares with black border, rounded corners
- Number: Large bold text, centered
- Animation: ~500ms total (spin + scale from RESEARCH.md)
- Roll button: Only show when it's player's turn and turnPhase='roll'

Follow CONTEXT.md: "Animation timing: Quick and efficient (~500ms total) — not dramatic/suspenseful".

Add myPlayerId to gameStore if not present (set when joining room). Access WebSocket send function from websocket service.
  </action>
  <verify>
Test dice roller:
1. Player whose turn it is sees "Roll Dice" button
2. Click button sends WebSocket message
3. After roll, dice animate with spin + scale
4. Numbers display correctly
5. Other players see same dice results simultaneously
  </verify>
  <done>
DiceRoller.tsx component exists with Framer Motion animations. Roll button appears for current player during roll phase. Dice animate when results received. WebSocket integration functional.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Turn order enforces**: Progress through multiple turns, verify round-robin order P1→P2→P3→P4→P1...
2. **Dice rolls work**: Server generates random 2-12, broadcasts to all clients
3. **Resources distribute**: Place settlements, roll matching numbers, verify correct resources granted
4. **Animations play**: Dice spin and scale in ~500ms when roll received
5. **Phase transitions**: roll→main (after dice), main→roll (after end turn, next player)
6. **Validation works**: Non-current player cannot roll, wrong phase rejected
</verification>

<success_criteria>
- TurnManager generates server-authoritative dice rolls (2-12 range)
- Resource distribution grants resources to players with settlements/cities on matching hexes
- Robber blocks resource distribution on its hex
- Turn phases progress: roll → main → end turn → next player's roll phase
- Round-robin turn order enforced across all players
- DiceRoller component displays animated dice results (~500ms)
- WebSocket handlers accept roll_dice and end_turn actions
- State broadcasts after each turn action update all clients
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-game-loop/02-04-SUMMARY.md` documenting:
- TurnManager architecture and turn phase state machine
- Resource distribution algorithm and vertex adjacency logic
- Dice roll randomness approach (server RNG)
- Animation implementation with Framer Motion
- Any edge cases discovered (robber, desert, zero-resource rolls)
</output>
