---
phase: 02-core-game-loop
plan: 08
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/src/game/Board/Port.tsx
  - apps/web/src/game/Board/HexGrid.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "9 ports are visible on the game board"
    - "Port type is visually distinguishable (3:1 generic vs 2:1 resource-specific)"
    - "Port position matches server-generated port placement"
  artifacts:
    - path: "apps/web/src/game/Board/Port.tsx"
      provides: "Port rendering component"
      min_lines: 50
      exports: ["Port"]
    - path: "apps/web/src/game/Board/HexGrid.tsx"
      provides: "Port rendering integration"
      contains: "gameState.board.ports"
  key_links:
    - from: "apps/web/src/game/Board/HexGrid.tsx"
      to: "apps/web/src/game/Board/Port.tsx"
      via: "Port component import and mapping"
      pattern: "import.*Port.*from.*\\.Port"
    - from: "apps/web/src/game/Board/Port.tsx"
      to: "gameState.board.ports"
      via: "Port data props"
      pattern: "port.*type.*position"
---

<objective>
Fix UAT Issue #1: Render ports on the game board.

Purpose: Ports are generated server-side and included in game state, but HexGrid.tsx has no rendering logic for them. This prevents players from seeing port locations needed for 2:1 and 3:1 trading mechanics.

Output: Working port rendering with visual distinction between generic (3:1) and resource-specific (2:1) ports at correct coastal positions.
</objective>

<execution_context>
@./.github/get-shit-done/workflows/execute-plan.md
@./.github/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-game-loop/02-UAT.md
@.planning/phases/02-core-game-loop/02-03-SUMMARY.md
@apps/web/src/game/Board/HexGrid.tsx
@libs/shared/src/schemas/game.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Port.tsx Component</name>
  <files>apps/web/src/game/Board/Port.tsx</files>
  <action>
Create a new Port component that renders port visuals on the board.

**Component structure:**
- Accept port prop with fields: `{ type: string, position: string, hexCoord: { q: number, r: number }, direction: string }`
- Parse `position` string (format: "q,r-direction") to extract hex coordinates and direction
- Use same geometry calculations as Settlement.tsx and Road.tsx to convert cubic coordinates to pixel positions
- Calculate port icon placement on the coast edge based on direction
- Render appropriate port icon/indicator based on type:
  - Generic "3:1" ports: Use a `?` symbol or generic icon with "3:1" label
  - Resource-specific "2:1" ports: Use resource icon/emoji (wood, brick, sheep, wheat, ore) with "2:1" label
- Style with SVG elements (rect/circle for background, text for labels)
- Position port indicator outside the hex at coastal edge
- Use consistent sizing (~20x20 pixel box for icon)

**Port type mapping:**
- `"3:1"` → generic port (any resource)
- `"wood"`, `"brick"`, `"sheep"`, `"wheat"`, `"ore"` → resource-specific 2:1 ports

**Reference existing components:**
- apps/web/src/game/Board/Settlement.tsx for cubic-to-pixel coordinate conversion pattern
- apps/web/src/game/Board/geometry.ts for coordinate utilities

**Why not hand-roll:** Use existing geometry utilities from geometry.ts to maintain coordinate system consistency. Do not create new conversion functions.
  </action>
  <verify>
1. Run `npx nx build web` - should compile without errors
2. Check that Port.tsx exports a Port component
3. Verify component accepts port prop with correct TypeScript types
  </verify>
  <done>Port.tsx component exists, compiles, and has logic to render port icons based on type and position</done>
</task>

<task type="auto">
  <name>Task 2: Integrate Port Rendering into HexGrid</name>
  <files>apps/web/src/game/Board/HexGrid.tsx</files>
  <action>
Add port rendering to HexGrid component.

**Changes needed:**
1. Import Port component: `import { Port } from './Port';`
2. After the settlements rendering loop (around line 164), add a port rendering loop:
   ```tsx
   {gameState.board.ports?.map((port, index) => (
     <Port key={`port-${index}`} port={port} />
   ))}
   ```
3. Place port rendering AFTER hex tiles but BEFORE roads/settlements so ports appear in background layer

**Rendering order (bottom to top):**
- Hex tiles (terrain)
- Ports (coastal indicators)
- Roads (player pieces)
- Settlements (player pieces)

**Why this order:** Ports are board features (like terrain), player pieces should render on top. This maintains visual hierarchy.
  </action>
  <verify>
1. Run `npx nx build web` - should compile without errors
2. Run `npx nx serve web` and open game
3. Start a new game with 4 players
4. Verify 9 ports appear on the board around coast edges
5. Verify ports show correct type labels (3:1 or 2:1 with resource icon)
6. Verify ports don't overlap with hex tiles or block placement clicks
  </verify>
  <done>Ports render on the game board at coastal positions with visible type indicators, UAT Test 1 passes</done>
</task>

</tasks>

<verification>
**Manual Testing:**
1. Start a game with 4 players
2. Verify 9 ports visible around board edges
3. Check port type distribution: 4 generic (3:1) + 5 resource-specific (2:1)
4. Verify each port has appropriate icon/label
5. Confirm ports don't interfere with hex clicking or placement

**Expected Result:** UAT Test 1 "Board Generation" changes from ❌ Failed to ✅ Passed
</verification>

<success_criteria>
- [ ] Port.tsx component created with rendering logic
- [ ] HexGrid.tsx maps over gameState.board.ports and renders Port components
- [ ] 9 ports visible on board in browser
- [ ] Generic (3:1) ports show "?" or generic indicator
- [ ] Resource-specific (2:1) ports show appropriate resource icon
- [ ] Ports positioned at coastal edges, not overlapping hexes
- [ ] Build succeeds with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-game-loop/02-08-SUMMARY.md`
</output>
