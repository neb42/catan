---
phase: 02-core-game-loop
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - apps/api/src/managers/GameManager.ts
  - apps/api/src/game/PlacementValidator.ts
  - apps/api/src/handlers/websocket.ts
  - libs/shared/src/schemas/messages.ts
autonomous: true

must_haves:
  truths:
    - "Game progresses through 8-round snake draft (P1→P2→P3→P4→P4→P3→P2→P1)"
    - "Players can place settlements on valid vertices (2-vertex distance rule)"
    - "Players can place roads on valid edges (connected to own settlement/road)"
    - "Second settlement placement grants starting resources from adjacent hexes"
  artifacts:
    - path: "apps/api/src/managers/GameManager.ts"
      provides: "Game lifecycle management"
      exports: ["GameManager"]
      min_lines: 150
    - path: "apps/api/src/game/PlacementValidator.ts"
      provides: "Settlement and road placement validation"
      exports: ["validateSettlementPlacement", "validateRoadPlacement"]
      min_lines: 60
  key_links:
    - from: "apps/api/src/handlers/websocket.ts"
      to: "apps/api/src/managers/GameManager.ts"
      via: "handles place_settlement, place_road actions"
      pattern: "gameManager\\.(placeSettlement|placeRoad)"
    - from: "apps/api/src/managers/GameManager.ts"
      to: "apps/api/src/game/PlacementValidator.ts"
      via: "validates placements before accepting"
      pattern: "validate(Settlement|Road)Placement"
---

<objective>
Implement initial placement state machine with snake draft order (8 rounds), settlement and road placement validation, and starting resource distribution. Players take turns placing settlements and roads following Catan rules, with second settlement granting resources from adjacent hexes.

Purpose: Complete the setup phase of Catan games. After this plan, games can transition from lobby to board with initial placements, setting up the game state for regular turns.

Output: Working initial placement flow where 3-4 players complete snake draft setup, placements are validated server-side, and players receive starting resources.
</objective>

<execution_context>
@./.github/get-shit-done/workflows/execute-plan.md
@./.github/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-game-loop/02-CONTEXT.md
@.planning/phases/02-core-game-loop/02-RESEARCH.md
@libs/shared/src/schemas/game.ts
@apps/api/src/game/BoardGenerator.ts
@apps/api/src/managers/RoomManager.ts
@apps/api/src/handlers/websocket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create placement validation utilities</name>
  <files>apps/api/src/game/PlacementValidator.ts</files>
  <action>
Create `apps/api/src/game/PlacementValidator.ts` with validation functions for Catan placement rules:

**Vertex/Edge Identifiers**: Use string format "q:r:v" for vertices (where v is 0-5 for 6 vertices per hex) and "q1:r1-q2:r2" for edges (between two hexes)

**validateSettlementPlacement(gameState: GameState, playerId: string, vertexId: string): {valid: boolean, error?: string}**
- Initial placement rules:
  - Vertex must not have any existing settlement/city
  - Vertex must be at least 2 vertices away from any other settlement (distance rule)
  - During initial placement: no adjacency requirement
- Post-setup rules (Phase 4+):
  - Must be adjacent to player's own road
  - Same distance rule applies

**validateRoadPlacement(gameState: GameState, playerId: string, edgeId: string): {valid: boolean, error?: string}**
- Edge must not have existing road
- Initial placement: Must connect to settlement just placed in same turn
- Post-setup: Must connect to player's existing road or settlement

**Helper functions**:
- `getVertexNeighbors(vertexId: string): string[]` - returns adjacent vertex IDs (2-distance check)
- `getAdjacentVertices(hexCoord: AxialCoord, vertexIndex: number): string[]` - gets 3 vertices adjacent to given vertex
- `getEdgeVertices(edgeId: string): [string, string]` - gets the 2 vertices an edge connects
- `isVertexAdjacentToRoad(vertexId: string, roads: string[]): boolean` - checks if any player road touches vertex

Return validation results with descriptive error messages for UI feedback.
  </action>
  <verify>
Create test cases:
- Valid initial settlement (no nearby settlements)
- Invalid settlement (too close to another)
- Valid road (connects to own settlement)
- Invalid road (not connected)

Test with simple game state manually constructed.
  </verify>
  <done>
PlacementValidator.ts exists with validateSettlementPlacement and validateRoadPlacement functions. Helper functions for vertex/edge topology implemented. Test cases pass validation logic.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GameManager with initial placement state machine</name>
  <files>apps/api/src/managers/GameManager.ts</files>
  <action>
Create `apps/api/src/managers/GameManager.ts` to manage game lifecycle:

**Class GameManager**:
- `private games = new Map<string, GameState>()`
- `createGame(roomId: string, players: Player[]): GameState` - creates game with board, sets phase='initial_placement', placementRound=1, currentPlayer=players[0]
- `placeSettlement(roomId: string, playerId: string, vertexId: string): GameState` - validates, adds to player.settlements, tracks "settlement just placed" for road requirement
- `placeRoad(roomId: string, playerId: string, edgeId: string): GameState` - validates, adds to player.roads, advances turn
- `advanceInitialPlacement(): void` - handles turn advancement and snake draft

**Snake draft logic** (8 rounds total):
- Rounds 1-4: Player order [P1, P2, P3, P4]
- Rounds 5-8: Reverse order [P4, P3, P2, P1]
- Each round: place settlement, then place road
- After road placed: advance to next player
- After round 8 complete: transition to phase='gameplay'

**Starting resources** (BOARD-05 requirement):
- When placing second settlement (rounds 5-8), call `grantStartingResources(playerId, vertexId)`
- Find all hexes adjacent to vertex (3 hexes meet at each vertex)
- For each hex with a number token, grant 1 of that terrain's resource to player
- Example: settlement on vertex touching wood(4), wheat(9), sheep(5) grants 1 wood, 1 wheat, 1 sheep

**State transitions**:
- After settlement placed: expect road from same player
- After road placed: advance to next player per snake draft
- After 8 rounds complete: set phase='gameplay', turnPhase='roll', currentPlayer=players[0]

Import GameState from game/GameState.ts, use PlacementValidator for all placement checks. Broadcast full game state after each action.
  </action>
  <verify>
Test snake draft order manually:
- Create game with 4 players
- Place 8 settlements (one per round)
- Verify order: P1,P2,P3,P4,P4,P3,P2,P1
- Verify currentPlayer advances correctly
- Verify phase transitions to 'gameplay' after round 8
  </verify>
  <done>
GameManager.ts exists with createGame, placeSettlement, placeRoad, and snake draft logic. Starting resources grant on second settlement placement. Phase transitions work correctly. Full state management functional.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire WebSocket handlers for placement actions</name>
  <files>apps/api/src/handlers/websocket.ts, libs/shared/src/schemas/messages.ts</files>
  <action>
Extend WebSocket handler to support game actions:

**Add to libs/shared/src/schemas/messages.ts**:
```typescript
export const PlaceSettlementMessageSchema = z.object({
  type: z.literal('place_settlement'),
  playerId: z.string(),
  vertexId: z.string(),
});

export const PlaceRoadMessageSchema = z.object({
  type: z.literal('place_road'),
  playerId: z.string(),
  edgeId: z.string(),
});

export const GameStateMessageSchema = z.object({
  type: z.literal('game_state'),
  gameState: GameStateSchema, // from game.ts
});

export const StartGameMessageSchema = z.object({
  type: z.literal('start_game'),
  roomId: z.string(),
});
```

Add these to WebSocketMessageSchema discriminated union.

**In apps/api/src/handlers/websocket.ts**:
- Import GameManager (create singleton instance)
- Add handler for 'start_game': calls gameManager.createGame with room players, broadcasts game_state
- Add handler for 'place_settlement': calls gameManager.placeSettlement, broadcasts game_state
- Add handler for 'place_road': calls gameManager.placeRoad, broadcasts game_state
- Wrap in try-catch, send error messages on validation failures

Broadcast full game state to all players in room after each successful action using existing room broadcast pattern from RoomManager.
  </action>
  <verify>
Test WebSocket flow manually or with a client script:
1. Create room
2. Send 'start_game' message
3. Receive 'game_state' with initial board and placementRound=1
4. Send 'place_settlement' for currentPlayer
5. Receive updated 'game_state' with settlement placed
6. Send 'place_road' for same player
7. Receive 'game_state' with road placed and next player's turn
  </verify>
  <done>
WebSocket handlers extended with game action messages. GameManager integrated into websocket.ts. Full state broadcasts working. Error handling sends descriptive error messages. Initial placement flow functional end-to-end.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Placement validation works**: Test validateSettlementPlacement and validateRoadPlacement with various scenarios (valid/invalid placements, distance rule violations)
2. **Snake draft order correct**: Verify 8-round sequence P1→P2→P3→P4→P4→P3→P2→P1
3. **Starting resources granted**: Confirm second settlements grant resources from adjacent hexes
4. **WebSocket integration**: Test complete placement flow from client message to state broadcast
5. **Phase transition**: Verify game transitions from 'initial_placement' to 'gameplay' after 8 rounds
</verification>

<success_criteria>
- GameManager handles game creation and initial placement state machine
- Snake draft progresses through 8 rounds in correct order (forward then reverse)
- Settlement placement validates 2-vertex distance rule and prevents overlaps
- Road placement validates connectivity to player's settlements/roads
- Second settlement placement grants starting resources from adjacent hexes
- WebSocket handlers accept placement actions and broadcast updated game state
- Game transitions to 'gameplay' phase after initial placement completes
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-game-loop/02-02-SUMMARY.md` documenting:
- GameManager architecture and state machine design
- Placement validation approach and vertex/edge identifier format
- Snake draft implementation details
- Starting resources logic
- Any edge cases discovered during implementation
</output>
