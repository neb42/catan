---
phase: 01-websocket-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - apps/api/src/websocket/schemas/index.ts
  - apps/api/src/websocket/schemas/client-messages.ts
  - apps/api/src/websocket/schemas/server-messages.ts
autonomous: true

must_haves:
  truths:
    - "Server can validate incoming WebSocket messages using Zod schemas"
    - "Invalid messages are rejected with clear error messages"
    - "TypeScript types are automatically inferred from schemas"
  artifacts:
    - path: "package.json"
      provides: "Zod dependency installed"
      contains: '"zod"'
    - path: "apps/api/src/websocket/schemas/client-messages.ts"
      provides: "Client->Server message schemas (HANDSHAKE, JOIN_ROOM)"
      exports: ["ClientMessageSchema", "HandshakeMessage", "JoinRoomMessage"]
      min_lines: 30
    - path: "apps/api/src/websocket/schemas/server-messages.ts"
      provides: "Server->Client message schemas (CLIENT_ID, ERROR, ROOM_JOINED)"
      exports: ["ServerMessageSchema", "ClientIdMessage", "ErrorMessage"]
      min_lines: 40
    - path: "apps/api/src/websocket/schemas/index.ts"
      provides: "Exported schema types for use in other modules"
      exports: ["ClientMessageSchema", "ServerMessageSchema"]
      min_lines: 5
  key_links:
    - from: "apps/api/src/websocket/schemas/client-messages.ts"
      to: "zod"
      via: "import { z } from 'zod'"
      pattern: "import.*zod"
    - from: "apps/api/src/websocket/schemas/server-messages.ts"
      to: "zod discriminatedUnion"
      via: "z.discriminatedUnion for type safety"
      pattern: "z\\.discriminatedUnion"
---

<objective>
Establish type-safe message validation foundation using Zod schemas for WebSocket communication.

Purpose: All WebSocket messages (client->server and server->client) must be validated at runtime to prevent malformed data from crashing the server or client. Zod provides both runtime validation and automatic TypeScript type inference, ensuring messages are type-safe end-to-end.

Output: Installed Zod dependency and complete message schema definitions following the type+payload pattern from CONTEXT.md, ready for use by message router and connection manager.
</objective>

<execution_context>
@/Users/bmcalindin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/bmcalindin/workspace/catan/.planning/PROJECT.md
@/Users/bmcalindin/workspace/catan/.planning/ROADMAP.md
@/Users/bmcalindin/workspace/catan/.planning/STATE.md
@/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-CONTEXT.md
@/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-RESEARCH.md
@/Users/bmcalindin/workspace/catan/apps/api/src/types/index.ts
@/Users/bmcalindin/workspace/catan/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Zod dependency</name>
  <files>package.json</files>
  <action>
Install Zod 3.x for runtime schema validation:

```bash
npm install zod
```

Verify installation by checking package.json contains `"zod": "^3.x"` in dependencies.

**Why Zod:** Industry standard for TypeScript runtime validation (2kb gzipped, zero dependencies), provides automatic type inference from schemas (avoids duplicate type definitions), and has excellent error messages for debugging invalid data.
  </action>
  <verify>
```bash
# Verify Zod is installed
grep '"zod"' package.json

# Verify it can be imported
node -e "require('zod')"
```
  </verify>
  <done>package.json contains Zod dependency and `require('zod')` succeeds without error.</done>
</task>

<task type="auto">
  <name>Task 2: Define Zod message schemas for client and server messages</name>
  <files>
apps/api/src/websocket/schemas/client-messages.ts
apps/api/src/websocket/schemas/server-messages.ts
apps/api/src/websocket/schemas/index.ts
  </files>
  <action>
Create three schema files following the architecture from RESEARCH.md:

**apps/api/src/websocket/schemas/client-messages.ts:**
- Define `HandshakeMessage` schema:
  - `type: z.literal('HANDSHAKE')`
  - `payload: { clientId: z.string().uuid().nullable() }` (null = new connection, UUID = reconnection attempt)
- Define `JoinRoomMessage` schema:
  - `type: z.literal('JOIN_ROOM')`
  - `payload: { roomId: z.string() }`
- Create `ClientMessageSchema` using `z.discriminatedUnion('type', [HandshakeMessage, JoinRoomMessage])`
- Export type: `export type ClientMessage = z.infer<typeof ClientMessageSchema>`

**apps/api/src/websocket/schemas/server-messages.ts:**
- Define `ClientIdMessage` schema:
  - `type: z.literal('CLIENT_ID')`
  - `payload: { clientId: z.string().uuid() }`
  - `messageId: z.string()`
  - `timestamp: z.number()`
- Define `ErrorMessage` schema:
  - `type: z.literal('ERROR')`
  - `payload: { code: z.string(), message: z.string(), details: z.unknown().optional() }`
  - `messageId: z.string()`
  - `timestamp: z.number()`
- Define `RoomJoinedMessage` schema:
  - `type: z.literal('ROOM_JOINED')`
  - `payload: { roomId: z.string(), clientId: z.string().uuid() }`
  - `messageId: z.string()`
  - `timestamp: z.number()`
- Create `ServerMessageSchema` using `z.discriminatedUnion('type', [ClientIdMessage, ErrorMessage, RoomJoinedMessage])`
- Export type: `export type ServerMessage = z.infer<typeof ServerMessageSchema>`

**apps/api/src/websocket/schemas/index.ts:**
- Re-export all schemas and types:
  ```typescript
  export { ClientMessageSchema, HandshakeMessage, JoinRoomMessage } from './client-messages';
  export type { ClientMessage } from './client-messages';
  export { ServerMessageSchema, ClientIdMessage, ErrorMessage, RoomJoinedMessage } from './server-messages';
  export type { ServerMessage } from './server-messages';
  ```

**Pattern rationale:** Using `z.discriminatedUnion('type', [...])` enables TypeScript to narrow types in switch statements automatically (no type guards needed). The `messageId` and `timestamp` fields are server-generated (not validated from client input), allowing server to add correlation IDs and timing data.

**Error handling pattern:** All schemas should use `.parse()` not `.safeParse()` - let Zod throw ZodError, which will be caught by message router and converted to ERROR response.
  </action>
  <verify>
```bash
# Verify schemas can be imported and parsed
node -e "
const { ClientMessageSchema, ServerMessageSchema } = require('./apps/api/src/websocket/schemas');
const valid = ClientMessageSchema.parse({ type: 'HANDSHAKE', payload: { clientId: null } });
console.log('Valid message parsed:', valid.type);
"

# Verify TypeScript types are correct
npx tsc --noEmit -p apps/api/tsconfig.app.json
```
  </verify>
  <done>
- Schema files exist and export correct types
- TypeScript compilation succeeds
- Valid messages parse successfully
- Invalid messages throw ZodError when parsed
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Zod is installed:** `npm list zod` shows installed version
2. **Schemas are defined:** All three schema files exist in `apps/api/src/websocket/schemas/`
3. **TypeScript types inferred:** No type errors when importing `ClientMessage` or `ServerMessage` types
4. **Validation works:** Test messages can be parsed successfully with `ClientMessageSchema.parse()`
5. **Invalid messages rejected:** Malformed messages throw ZodError with clear error details
</verification>

<success_criteria>
**Measurable completion:**

- [ ] `package.json` contains `"zod": "^3.x"`
- [ ] `npm list zod` shows installed version
- [ ] Schema files exist: `client-messages.ts`, `server-messages.ts`, `index.ts`
- [ ] TypeScript compilation succeeds: `npx tsc --noEmit -p apps/api/tsconfig.app.json`
- [ ] Valid HANDSHAKE message parses: `ClientMessageSchema.parse({ type: 'HANDSHAKE', payload: { clientId: null } })`
- [ ] Invalid message throws ZodError: `ClientMessageSchema.parse({ type: 'INVALID' })` throws error
- [ ] Types are exported: Can import `ClientMessage` and `ServerMessage` types from `schemas/index`
</success_criteria>

<output>
After completion, create `/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-01-SUMMARY.md`
</output>
