---
phase: 01-websocket-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - apps/api/src/websocket/connection-manager.ts
  - apps/api/src/websocket/room-manager.ts
  - apps/api/src/websocket/types.ts
autonomous: true

must_haves:
  truths:
    - "Server assigns unique UUID client IDs on connection"
    - "Server detects and cleans up stale connections within 30 seconds"
    - "Server maintains 30-second grace period for reconnection"
    - "Server enforces room capacity limits (4 players)"
    - "Server can broadcast messages to all clients in a room"
  artifacts:
    - path: "apps/api/src/websocket/types.ts"
      provides: "TypeScript interfaces for connection and room state"
      exports: ["ClientConnection", "Room", "RoomMetadata"]
      min_lines: 30
    - path: "apps/api/src/websocket/connection-manager.ts"
      provides: "Connection lifecycle and heartbeat management"
      exports: ["ConnectionManager"]
      min_lines: 120
    - path: "apps/api/src/websocket/room-manager.ts"
      provides: "Room-based architecture with capacity enforcement"
      exports: ["RoomManager"]
      min_lines: 100
  key_links:
    - from: "apps/api/src/websocket/connection-manager.ts"
      to: "crypto.randomUUID()"
      via: "Native Node.js UUID generation"
      pattern: "crypto\\.randomUUID"
    - from: "apps/api/src/websocket/connection-manager.ts"
      to: "ws.ping/pong"
      via: "Heartbeat detection with ping/pong frames"
      pattern: "ws\\.ping|ws\\.on\\('pong'"
    - from: "apps/api/src/websocket/room-manager.ts"
      to: "connection-manager"
      via: "Room manager sends messages via connection manager"
      pattern: "connectionManager\\.(send|broadcast)"
---

<objective>
Build core infrastructure for connection lifecycle management and room-based architecture.

Purpose: Manage WebSocket client connections with stable IDs, heartbeat detection, and graceful handling of disconnects/reconnects. Implement room-based message routing from the start to avoid refactoring later (even though v0.1 has single lobby).

Output: ConnectionManager class handling client lifecycle with ping/pong heartbeats and 30-second grace period, plus RoomManager class handling room membership and targeted broadcasts with capacity enforcement.
</objective>

<execution_context>
@/Users/bmcalindin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/bmcalindin/workspace/catan/.planning/PROJECT.md
@/Users/bmcalindin/workspace/catan/.planning/ROADMAP.md
@/Users/bmcalindin/workspace/catan/.planning/STATE.md
@/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-CONTEXT.md
@/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-RESEARCH.md
@/Users/bmcalindin/workspace/catan/apps/api/src/websocket/index.ts
@/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build connection manager with heartbeat detection</name>
  <files>
apps/api/src/websocket/types.ts
apps/api/src/websocket/connection-manager.ts
  </files>
  <action>
Create TypeScript types and ConnectionManager class following patterns from RESEARCH.md.

**apps/api/src/websocket/types.ts:**
Define core interfaces:
- `ClientConnection`: `{ id: string; ws: WebSocket; isAlive: boolean; joinedAt: number; roomId?: string; disconnectedAt?: number }`
- `Room`: `{ id: string; clients: Set<string>; createdAt: number; metadata: RoomMetadata }`
- `RoomMetadata`: `{ capacity: number; state: 'waiting' | 'active' | 'finished' }`

**apps/api/src/websocket/connection-manager.ts:**
Implement ConnectionManager class with:

1. **Private state:**
   - `connections: Map<string, ClientConnection>` - active connections
   - `disconnectedConnections: Map<string, ClientConnection>` - grace period tracking
   - `heartbeatInterval: NodeJS.Timeout | null` - ping interval timer

2. **Constructor:** Initialize maps and start heartbeat interval (30 seconds)

3. **addConnection(ws: WebSocket, clientId?: string):**
   - If clientId provided (reconnection): Check `disconnectedConnections`, restore if within grace period, otherwise generate new UUID
   - If no clientId (new connection): Generate UUID v4 using `crypto.randomUUID()`
   - Create ClientConnection object with `isAlive: true`, `joinedAt: Date.now()`
   - Set up pong handler: `ws.on('pong', () => { conn.isAlive = true })`
   - Add to connections Map
   - Return clientId

4. **removeConnection(clientId: string):**
   - Move from `connections` to `disconnectedConnections` with `disconnectedAt: Date.now()`
   - After 30 seconds: Remove from `disconnectedConnections` entirely (grace period expired)

5. **getConnection(clientId: string):** Lookup in connections Map

6. **sendToClient(clientId: string, message: object):**
   - Look up connection, check `ws.readyState === WebSocket.OPEN`
   - Send JSON.stringify(message)

7. **broadcastToAll(message: object, excludeClientId?: string):**
   - Iterate connections, skip excludeClientId, send to OPEN sockets

8. **startHeartbeat():** (private)
   - Every 30 seconds: Iterate connections
   - If `isAlive === false`: Call `ws.terminate()`, remove connection
   - If `isAlive === true`: Set to false, call `ws.ping()`

9. **cleanup():** Clear heartbeat interval

**Use crypto.randomUUID() NOT uuid package:** RESEARCH.md confirms native crypto is 3x faster, zero dependencies, already available in Node.js 14.17+.

**Grace period implementation:** When connection closes, move to disconnectedConnections with timestamp. Reconnection attempts within 30 seconds restore the connection. After 30 seconds, treat as new client (session lost).

**Heartbeat rationale:** WebSocket 'close' event doesn't fire for half-closed TCP connections or network partitions. Ping/pong protocol-level detection ensures zombie connections are terminated.
  </action>
  <verify>
```bash
# Verify TypeScript compilation
npx tsc --noEmit -p apps/api/tsconfig.app.json

# Verify ConnectionManager exports
node -e "
const { ConnectionManager } = require('./apps/api/src/websocket/connection-manager');
console.log('ConnectionManager imported:', typeof ConnectionManager);
"
```
  </verify>
  <done>
- types.ts defines ClientConnection, Room, RoomMetadata interfaces
- ConnectionManager class exports with all required methods
- TypeScript compilation succeeds
- Uses crypto.randomUUID() for client IDs (grep confirms, no uuid import)
- Heartbeat interval set to 30 seconds
- Grace period implemented with disconnectedConnections Map
  </done>
</task>

<task type="auto">
  <name>Task 2: Build room manager with capacity enforcement</name>
  <files>apps/api/src/websocket/room-manager.ts</files>
  <action>
Create RoomManager class for room-based architecture from RESEARCH.md patterns.

**apps/api/src/websocket/room-manager.ts:**
Implement RoomManager class with:

1. **Private state:**
   - `rooms: Map<string, Room>` - room registry
   - `clientRooms: Map<string, string>` - reverse lookup (clientId -> roomId)
   - `connectionManager: ConnectionManager` - dependency injected

2. **Constructor(connectionManager: ConnectionManager):** Store reference

3. **createRoom(roomId: string, capacity: number = 4):**
   - Create Room object: `{ id: roomId, clients: new Set(), createdAt: Date.now(), metadata: { capacity, state: 'waiting' } }`
   - Add to rooms Map
   - Return room

4. **joinRoom(clientId: string, roomId: string):**
   - Get or create room
   - Check capacity: `room.clients.size >= room.metadata.capacity` returns false
   - Add clientId to room.clients Set
   - Update clientRooms reverse lookup
   - Update connection's roomId field via connectionManager
   - Return true (success)

5. **leaveRoom(clientId: string):**
   - Lookup roomId via clientRooms
   - Remove clientId from room.clients
   - Delete from clientRooms
   - If room.clients.size === 0: Delete room (cleanup empty rooms immediately)

6. **getRoom(roomId: string):** Return room or undefined

7. **getClientRoom(clientId: string):** Lookup via clientRooms, return Room or undefined

8. **broadcastToRoom(roomId: string, message: object, excludeClientId?: string):**
   - Get room, iterate room.clients
   - For each clientId (except excludeClientId): Call `connectionManager.sendToClient(clientId, message)`

9. **getRoomClients(roomId: string):** Return array of clientIds in room

10. **getRoomState(roomId: string):** Return room metadata (capacity, state, client count)

**Room architecture rationale:** Even though v0.1 has single lobby, implementing room-based architecture now prevents refactoring later. Rooms are cheap to create/destroy (just Map entries). The pattern scales naturally to multiple concurrent games.

**Capacity enforcement:** CONTEXT.md specifies 4-player capacity. Enforce at joinRoom() - reject if room is full. This becomes critical in Phase 3 (Lobby State Management).

**Empty room cleanup:** Delete rooms immediately when last player leaves. Rooms are stateless for now (no game state), so recreating is trivial. If reconnection-to-room is needed later, add grace period similar to connection manager.

**Dependency on ConnectionManager:** Room manager doesn't talk to WebSocket directly - delegates to ConnectionManager for all message sending. This keeps concerns separated (rooms manage membership, connections manage transport).
  </action>
  <verify>
```bash
# Verify TypeScript compilation
npx tsc --noEmit -p apps/api/tsconfig.app.json

# Verify RoomManager exports
node -e "
const { RoomManager } = require('./apps/api/src/websocket/room-manager');
console.log('RoomManager imported:', typeof RoomManager);
"
```
  </verify>
  <done>
- RoomManager class exports with all required methods
- TypeScript compilation succeeds
- Room capacity enforced (checks size >= capacity)
- Empty rooms deleted on last player leave
- Broadcasts delegate to ConnectionManager (no direct ws.send calls in RoomManager)
- clientRooms reverse lookup maintained
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Types defined:** ClientConnection, Room, RoomMetadata interfaces exist
2. **ConnectionManager functional:** Can add connections, send messages, run heartbeat
3. **RoomManager functional:** Can create rooms, enforce capacity, broadcast to room
4. **Dependencies correct:** RoomManager uses ConnectionManager, not direct WebSocket
5. **TypeScript clean:** No compilation errors in types, connection-manager, or room-manager
6. **Heartbeat configured:** 30-second interval for ping/pong
7. **Grace period implemented:** disconnectedConnections Map with 30-second cleanup
</verification>

<success_criteria>
**Measurable completion:**

- [ ] `types.ts` defines ClientConnection, Room, RoomMetadata
- [ ] `connection-manager.ts` exports ConnectionManager class
- [ ] `room-manager.ts` exports RoomManager class
- [ ] TypeScript compilation succeeds: `npx tsc --noEmit -p apps/api/tsconfig.app.json`
- [ ] ConnectionManager uses `crypto.randomUUID()` (grep confirms, no uuid package)
- [ ] ConnectionManager starts heartbeat on interval (30000ms)
- [ ] ConnectionManager implements grace period with disconnectedConnections Map
- [ ] RoomManager enforces capacity (rejects when `clients.size >= capacity`)
- [ ] RoomManager deletes empty rooms (no room persists with 0 clients)
- [ ] RoomManager broadcasts via ConnectionManager (no `ws.send` in room-manager.ts)
</success_criteria>

<output>
After completion, create `/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-02-SUMMARY.md`
</output>
