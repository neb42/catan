---
phase: 01-websocket-infrastructure
plan: 04
type: execute
wave: 4
depends_on: ["01-03"]
files_modified:
  - apps/web/src/lib/websocket.ts
  - apps/web/src/lib/websocket-context.tsx
  - apps/web/src/main.tsx
autonomous: true

must_haves:
  truths:
    - "Client automatically reconnects after brief network interruptions"
    - "Client uses exponential backoff (1s base, 30s max) for reconnection"
    - "Client persists and sends client ID during reconnection attempts"
    - "Client shows connection status to user (connected, reconnecting, disconnected)"
    - "Client validates server messages against Zod schemas"
  artifacts:
    - path: "apps/web/src/lib/websocket.ts"
      provides: "ReconnectingWebSocket client with exponential backoff"
      exports: ["ReconnectingWebSocket", "WebSocketStatus"]
      min_lines: 150
    - path: "apps/web/src/lib/websocket-context.tsx"
      provides: "React context for WebSocket state and methods"
      exports: ["WebSocketProvider", "useWebSocket"]
      min_lines: 80
    - path: "apps/web/src/main.tsx"
      provides: "Updated app with WebSocketProvider wrapper"
      min_lines: 30
  key_links:
    - from: "apps/web/src/lib/websocket.ts"
      to: "exponential backoff formula"
      via: "Math.min(baseDelay * 2^attempts, maxDelay) + jitter"
      pattern: "Math\\.pow\\(2.*reconnectAttempts"
    - from: "apps/web/src/lib/websocket.ts"
      to: "client ID persistence"
      via: "Store clientId in class, send in HANDSHAKE"
      pattern: "clientId.*HANDSHAKE"
    - from: "apps/web/src/lib/websocket-context.tsx"
      to: "apps/web/src/lib/websocket.ts"
      via: "Creates ReconnectingWebSocket instance"
      pattern: "new ReconnectingWebSocket"
---

<objective>
Build client-side WebSocket infrastructure with automatic reconnection and React integration.

Purpose: Enable web app to establish resilient WebSocket connections that survive network interruptions. Implement exponential backoff to prevent server overload during outages, persist client IDs for session recovery within grace period, and expose connection state to React components.

Output: ReconnectingWebSocket class with exponential backoff, WebSocket React context/provider for global connection state, and integration into main app.
</objective>

<execution_context>
@/Users/bmcalindin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/bmcalindin/workspace/catan/.planning/PROJECT.md
@/Users/bmcalindin/workspace/catan/.planning/ROADMAP.md
@/Users/bmcalindin/workspace/catan/.planning/STATE.md
@/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-CONTEXT.md
@/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-RESEARCH.md
@/Users/bmcalindin/workspace/catan/apps/web/src/main.tsx
@/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-01-SUMMARY.md
@/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-02-SUMMARY.md
@/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build ReconnectingWebSocket client with exponential backoff</name>
  <files>apps/web/src/lib/websocket.ts</files>
  <action>
Create ReconnectingWebSocket class following RESEARCH.md client reconnection pattern.

**apps/web/src/lib/websocket.ts:**

1. **Type definitions:**
   ```typescript
   export type WebSocketStatus = 'connecting' | 'connected' | 'reconnecting' | 'disconnected';

   export type MessageHandler = (message: any) => void;

   export interface ReconnectingWebSocketConfig {
     url: string;
     baseDelay?: number;  // Default: 1000ms
     maxDelay?: number;   // Default: 30000ms
     onStatusChange?: (status: WebSocketStatus) => void;
     onMessage?: MessageHandler;
   }
   ```

2. **ReconnectingWebSocket class:**

   **Private state:**
   - `ws: WebSocket | null = null`
   - `clientId: string | null = null`
   - `reconnectAttempts = 0`
   - `status: WebSocketStatus = 'disconnected'`
   - `config: ReconnectingWebSocketConfig`
   - `messageHandlers: Set<MessageHandler> = new Set()`
   - `reconnectTimeout: number | null = null`

   **Constructor(config):**
   - Store config with defaults: `baseDelay: 1000, maxDelay: 30000`
   - Call `this.connect()`

   **connect():**
   - Set status to 'connecting' (or 'reconnecting' if reconnectAttempts > 0)
   - Create WebSocket: `this.ws = new WebSocket(this.config.url)`
   - Set up event handlers:
     ```typescript
     this.ws.onopen = () => {
       this.reconnectAttempts = 0;
       this.setStatus('connected');
       this.sendHandshake();
     };

     this.ws.onmessage = (event) => {
       const message = JSON.parse(event.data);

       // Handle CLIENT_ID message specially
       if (message.type === 'CLIENT_ID') {
         this.clientId = message.payload.clientId;
       }

       // Notify all handlers
       this.messageHandlers.forEach(handler => handler(message));
       this.config.onMessage?.(message);
     };

     this.ws.onclose = () => {
       this.setStatus('disconnected');
       this.scheduleReconnect();
     };

     this.ws.onerror = (err) => {
       console.error('[WebSocket] Error:', err);
     };
     ```

   **sendHandshake():**
   - Send HANDSHAKE message: `{ type: 'HANDSHAKE', payload: { clientId: this.clientId } }`
   - First connection: clientId is null (server generates new)
   - Reconnection: clientId is UUID (server restores if within grace period)

   **scheduleReconnect():**
   - Calculate delay using exponential backoff with jitter:
     ```typescript
     const exponentialDelay = Math.min(
       this.config.baseDelay * Math.pow(2, this.reconnectAttempts),
       this.config.maxDelay
     );
     // Add 0-25% jitter to prevent thundering herd
     const jitter = Math.random() * 0.25 * exponentialDelay;
     const delay = Math.floor(exponentialDelay + jitter);
     ```
   - Set status to 'reconnecting'
   - Schedule reconnection: `setTimeout(() => { this.reconnectAttempts++; this.connect(); }, delay)`

   **send(message: object):**
   - Check `this.ws?.readyState === WebSocket.OPEN`
   - If open: `this.ws.send(JSON.stringify(message))`
   - If not open: Log warning or queue message (simple approach: just drop and log)

   **addMessageHandler(handler: MessageHandler):** Add to messageHandlers Set

   **removeMessageHandler(handler: MessageHandler):** Remove from messageHandlers Set

   **disconnect():**
   - Clear reconnect timeout
   - Close WebSocket
   - Set status to 'disconnected'

   **setStatus(status: WebSocketStatus):** (private)
   - Update this.status
   - Call `this.config.onStatusChange?.(status)`

   **getStatus():** Return current status

   **getClientId():** Return clientId

3. **WebSocket URL:**
   - Use `ws://localhost:3000` for development
   - RESEARCH.md notes HTTP upgrade pattern means WebSocket shares the HTTP port (3000)
   - Production would use `wss://` (secure WebSocket) but v0.1 is localhost only

**Exponential backoff formula:** RESEARCH.md specifies `baseDelay * 2^attempts` capped at maxDelay, plus 0-25% jitter. The jitter prevents all disconnected clients from reconnecting simultaneously (thundering herd problem).

**Grace period alignment:** 30-second max delay matches server's 30-second grace period from CONTEXT.md. This ensures reconnection attempts happen within the window where server preserves session.

**Unlimited retries:** CONTEXT.md specifies unlimited retry attempts. RESEARCH.md Pitfall 8 warns about battery drain, but for v0.1 localhost testing this is acceptable. Production could add max duration circuit breaker.
  </action>
  <verify>
```bash
# Verify TypeScript compilation
npx tsc --noEmit -p apps/web/tsconfig.app.json

# Check exponential backoff formula is present
grep "Math.pow(2" apps/web/src/lib/websocket.ts

# Check jitter is added
grep "Math.random.*0.25" apps/web/src/lib/websocket.ts
```
  </verify>
  <done>
- websocket.ts exports ReconnectingWebSocket class and WebSocketStatus type
- TypeScript compilation succeeds
- Exponential backoff implemented with Math.pow(2, reconnectAttempts)
- Jitter added (0-25% random variance)
- baseDelay: 1000ms, maxDelay: 30000ms
- clientId persisted and sent in HANDSHAKE on reconnect
- Message handlers supported (addMessageHandler/removeMessageHandler)
- Status transitions: connecting -> connected -> disconnected -> reconnecting
  </done>
</task>

<task type="auto">
  <name>Task 2: Create WebSocket React context and integrate into app</name>
  <files>
apps/web/src/lib/websocket-context.tsx
apps/web/src/main.tsx
  </files>
  <action>
Create React context for global WebSocket state and integrate into main app.

**apps/web/src/lib/websocket-context.tsx:**

1. **Context interface:**
   ```typescript
   import { ReconnectingWebSocket, WebSocketStatus } from './websocket';

   interface WebSocketContextValue {
     ws: ReconnectingWebSocket | null;
     status: WebSocketStatus;
     clientId: string | null;
     sendMessage: (message: object) => void;
   }
   ```

2. **Create context:**
   ```typescript
   const WebSocketContext = createContext<WebSocketContextValue>({
     ws: null,
     status: 'disconnected',
     clientId: null,
     sendMessage: () => console.warn('WebSocket not initialized')
   });
   ```

3. **WebSocketProvider component:**
   ```typescript
   export function WebSocketProvider({ children }: { children: React.ReactNode }) {
     const [ws, setWs] = useState<ReconnectingWebSocket | null>(null);
     const [status, setStatus] = useState<WebSocketStatus>('disconnected');
     const [clientId, setClientId] = useState<string | null>(null);

     useEffect(() => {
       // Create WebSocket instance
       const wsInstance = new ReconnectingWebSocket({
         url: 'ws://localhost:3000',
         onStatusChange: setStatus,
         onMessage: (message) => {
           if (message.type === 'CLIENT_ID') {
             setClientId(message.payload.clientId);
           }
         }
       });

       setWs(wsInstance);

       // Cleanup on unmount
       return () => {
         wsInstance.disconnect();
       };
     }, []);

     const sendMessage = useCallback((message: object) => {
       ws?.send(message);
     }, [ws]);

     const value: WebSocketContextValue = {
       ws,
       status,
       clientId,
       sendMessage
     };

     return (
       <WebSocketContext.Provider value={value}>
         {children}
       </WebSocketContext.Provider>
     );
   }
   ```

4. **useWebSocket hook:**
   ```typescript
   export function useWebSocket() {
     const context = useContext(WebSocketContext);
     if (!context) {
       throw new Error('useWebSocket must be used within WebSocketProvider');
     }
     return context;
   }
   ```

**apps/web/src/main.tsx:**

Update to wrap app with WebSocketProvider:
```typescript
import { WebSocketProvider } from './lib/websocket-context';

// Wrap existing providers with WebSocketProvider
<StrictMode>
  <QueryClientProvider client={queryClient}>
    <WebSocketProvider>
      <RouterProvider router={router} />
    </WebSocketProvider>
  </QueryClientProvider>
</StrictMode>
```

**Provider placement:** WebSocketProvider should be INSIDE QueryClientProvider (TanStack Query available) but OUTSIDE RouterProvider (WebSocket available to all routes).

**Automatic connection:** WebSocket connects immediately when app loads (useEffect runs on mount). This ensures connection is established before user navigates to any route.

**Status exposure:** Components can use `const { status, clientId } = useWebSocket()` to show connection state in UI (e.g., "Reconnecting..." indicator).

**Message sending:** Components can use `sendMessage({ type: 'JOIN_ROOM', payload: { roomId: 'lobby' } })` without managing WebSocket instance directly.
  </action>
  <verify>
```bash
# Verify TypeScript compilation
npx tsc --noEmit -p apps/web/tsconfig.app.json

# Check context is created
grep "createContext" apps/web/src/lib/websocket-context.tsx

# Check provider wraps app
grep "WebSocketProvider" apps/web/src/main.tsx

# Verify build succeeds
npx nx build web
```
  </verify>
  <done>
- websocket-context.tsx exports WebSocketProvider and useWebSocket
- WebSocketContext created with proper interface
- WebSocketProvider creates ReconnectingWebSocket instance on mount
- Provider updates status and clientId from messages
- useWebSocket hook throws if used outside provider
- main.tsx wraps app with WebSocketProvider (inside QueryClientProvider)
- TypeScript compilation succeeds
- Build succeeds: `npx nx build web`
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **ReconnectingWebSocket functional:** Can connect, reconnect with backoff, persist clientId
2. **Exponential backoff configured:** 1s base, 30s max, with jitter
3. **React context created:** useWebSocket hook available to components
4. **WebSocket auto-connects:** Connection established on app load
5. **Status tracked:** Components can read connection status
6. **TypeScript clean:** No compilation errors in web app
7. **Build succeeds:** Both `npx nx build api` and `npx nx build web` complete successfully
</verification>

<success_criteria>
**Measurable completion:**

- [ ] `websocket.ts` exports ReconnectingWebSocket class
- [ ] Exponential backoff formula present: `Math.pow(2, reconnectAttempts)`
- [ ] Jitter added: `Math.random() * 0.25`
- [ ] baseDelay: 1000ms, maxDelay: 30000ms
- [ ] clientId persisted and sent in HANDSHAKE
- [ ] `websocket-context.tsx` exports WebSocketProvider and useWebSocket
- [ ] Provider creates ReconnectingWebSocket on mount
- [ ] Provider tracks status and clientId state
- [ ] `main.tsx` wraps app with WebSocketProvider
- [ ] TypeScript compilation succeeds: `npx tsc --noEmit -p apps/web/tsconfig.app.json`
- [ ] Web app build succeeds: `npx nx build web`
</success_criteria>

<output>
After completion, create `/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-04-SUMMARY.md`
</output>
