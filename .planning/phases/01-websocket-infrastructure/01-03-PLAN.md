---
phase: 01-websocket-infrastructure
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - apps/api/src/websocket/message-router.ts
  - apps/api/src/websocket/index.ts
autonomous: true

must_haves:
  truths:
    - "Server validates all incoming messages against Zod schemas"
    - "Invalid messages trigger ERROR response to sender"
    - "HANDSHAKE messages assign or restore client IDs"
    - "JOIN_ROOM messages add clients to rooms with capacity checks"
    - "Server adds messageId and timestamp to all outbound messages"
  artifacts:
    - path: "apps/api/src/websocket/message-router.ts"
      provides: "Type-safe message routing with Zod validation"
      exports: ["MessageRouter"]
      min_lines: 100
    - path: "apps/api/src/websocket/index.ts"
      provides: "Updated WebSocket server initialization using new infrastructure"
      exports: ["initializeWebSocket"]
      min_lines: 60
  key_links:
    - from: "apps/api/src/websocket/message-router.ts"
      to: "apps/api/src/websocket/schemas"
      via: "import ClientMessageSchema for validation"
      pattern: "import.*ClientMessageSchema"
    - from: "apps/api/src/websocket/message-router.ts"
      to: "connection-manager and room-manager"
      via: "Delegates to managers for state changes"
      pattern: "connectionManager\\.|roomManager\\."
    - from: "apps/api/src/websocket/index.ts"
      to: "message-router"
      via: "Routes all messages through MessageRouter"
      pattern: "messageRouter\\.route"
---

<objective>
Integrate message validation, routing, and state management into WebSocket server.

Purpose: Connect all infrastructure components (schemas, connection manager, room manager) into a cohesive message processing pipeline. Route validated messages to appropriate handlers, enforce business logic (capacity, reconnection), and send type-safe responses.

Output: MessageRouter class handling validation and routing, plus updated WebSocket server initialization that wires everything together.
</objective>

<execution_context>
@/Users/bmcalindin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/bmcalindin/workspace/catan/.planning/PROJECT.md
@/Users/bmcalindin/workspace/catan/.planning/ROADMAP.md
@/Users/bmcalindin/workspace/catan/.planning/STATE.md
@/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-CONTEXT.md
@/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-RESEARCH.md
@/Users/bmcalindin/workspace/catan/apps/api/src/websocket/index.ts
@/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-01-SUMMARY.md
@/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build message router with validation and handler dispatch</name>
  <files>apps/api/src/websocket/message-router.ts</files>
  <action>
Create MessageRouter class for type-safe message processing following RESEARCH.md patterns.

**apps/api/src/websocket/message-router.ts:**
Implement MessageRouter class with:

1. **Dependencies (constructor-injected):**
   - `connectionManager: ConnectionManager`
   - `roomManager: RoomManager`

2. **Constructor(connectionManager, roomManager):** Store references

3. **routeMessage(clientId: string, data: Buffer):**
   - Parse JSON: `const raw = JSON.parse(data.toString())`
   - Validate with Zod: `const message = ClientMessageSchema.parse(raw)`
   - Use discriminated union for type-safe routing:
     ```typescript
     switch (message.type) {
       case 'HANDSHAKE':
         return this.handleHandshake(clientId, message.payload);
       case 'JOIN_ROOM':
         return this.handleJoinRoom(clientId, message.payload);
       default:
         return this.sendError(clientId, 'UNKNOWN_MESSAGE_TYPE', 'Unrecognized message type');
     }
     ```
   - If ZodError caught: Call `sendError(clientId, 'INVALID_MESSAGE', zodError.errors)`
   - If JSON.parse fails: Call `sendError(clientId, 'MALFORMED_JSON', parseError.message)`

4. **handleHandshake(clientId: string, payload: { clientId: string | null }):**
   - If `payload.clientId` is null (new connection):
     - Generate new client ID via connectionManager (already done on connection)
     - Send CLIENT_ID message: `{ type: 'CLIENT_ID', payload: { clientId }, messageId, timestamp }`
   - If `payload.clientId` is UUID (reconnection attempt):
     - Check if connection exists in grace period
     - If yes: Restore connection, send CLIENT_ID with restored ID
     - If no (past grace period): Treat as new connection, send CLIENT_ID with new ID
   - Use `crypto.randomUUID()` for messageId generation

5. **handleJoinRoom(clientId: string, payload: { roomId: string }):**
   - Call `roomManager.joinRoom(clientId, payload.roomId)`
   - If success (capacity available):
     - Send ROOM_JOINED message: `{ type: 'ROOM_JOINED', payload: { roomId, clientId }, messageId, timestamp }`
     - Broadcast to room (excluding sender): "Player joined" notification
   - If failure (room full):
     - Send ERROR message: `{ type: 'ERROR', payload: { code: 'ROOM_FULL', message: 'Room capacity reached' }, messageId, timestamp }`

6. **sendError(clientId: string, code: string, details: unknown):**
   - Create ErrorMessage: `{ type: 'ERROR', payload: { code, message: getErrorMessage(code), details }, messageId: crypto.randomUUID(), timestamp: Date.now() }`
   - Send via `connectionManager.sendToClient(clientId, errorMessage)`

7. **sendMessage(clientId: string, type: string, payload: object):** (private helper)
   - Add messageId and timestamp to every message
   - Delegate to connectionManager.sendToClient

**Message ID generation:** Use `crypto.randomUUID()` for all messageIds (consistent with client ID generation). RESEARCH.md notes ULID is only needed if message ordering by timestamp is required - CONTEXT.md doesn't specify this need.

**Error handling philosophy:** Invalid messages don't crash the server - they trigger ERROR responses back to the sender. This allows debugging malformed messages from clients without server restarts.

**Type safety benefit:** Using `ClientMessageSchema.parse()` means TypeScript automatically narrows types in the switch statement. No manual type guards needed.
  </action>
  <verify>
```bash
# Verify TypeScript compilation
npx tsc --noEmit -p apps/api/tsconfig.app.json

# Verify MessageRouter exports
node -e "
const { MessageRouter } = require('./apps/api/src/websocket/message-router');
console.log('MessageRouter imported:', typeof MessageRouter);
"
```
  </verify>
  <done>
- MessageRouter class exports with routeMessage, handleHandshake, handleJoinRoom methods
- TypeScript compilation succeeds
- Uses ClientMessageSchema.parse() for validation (import confirmed)
- ZodError caught and converted to ERROR message
- Uses crypto.randomUUID() for messageId (no uuid package import)
- All outbound messages include messageId and timestamp
  </done>
</task>

<task type="auto">
  <name>Task 2: Update WebSocket server initialization to use new infrastructure</name>
  <files>apps/api/src/websocket/index.ts</files>
  <action>
Replace the basic connection handlers in `apps/api/src/websocket/index.ts` with full infrastructure wiring.

**Updated apps/api/src/websocket/index.ts:**

1. **Imports:**
   - Import ConnectionManager, RoomManager, MessageRouter
   - Keep existing WebSocketServer, WebSocket, HttpServer imports
   - Import config

2. **Module-level state:**
   - `let wss: WebSocketServer | null = null`
   - `let connectionManager: ConnectionManager | null = null`
   - `let roomManager: RoomManager | null = null`
   - `let messageRouter: MessageRouter | null = null`

3. **initializeWebSocket(httpServer?: HttpServer):**
   - Create WebSocketServer with options:
     ```typescript
     wss = new WebSocketServer({
       server: httpServer,
       maxPayload: 1024 * 1024, // 1MB limit (not 100MB default - DoS prevention)
       clientTracking: true
     });
     ```
   - Initialize managers:
     ```typescript
     connectionManager = new ConnectionManager();
     roomManager = new RoomManager(connectionManager);
     messageRouter = new MessageRouter(connectionManager, roomManager);
     ```
   - Set up connection handler:
     ```typescript
     wss.on('connection', (ws: WebSocket) => {
       const clientId = connectionManager.addConnection(ws);

       ws.on('message', (data: Buffer) => {
         messageRouter.routeMessage(clientId, data);
       });

       ws.on('close', () => {
         connectionManager.removeConnection(clientId);
         roomManager.leaveRoom(clientId);
       });

       ws.on('error', (err) => {
         console.error(`[WebSocket] Client ${clientId} error:`, err.message);
       });

       // Send initial handshake prompt (optional - client can initiate)
       // Client will send HANDSHAKE message to get their ID
     });
     ```
   - Start heartbeat: `connectionManager.startHeartbeat()` (called in constructor, verify it's running)
   - Log startup: `console.log('[WebSocket] Server initialized with connection/room management')`

4. **closeWebSocket():**
   - Clean up managers: `connectionManager?.cleanup()`
   - Close server: `wss?.close()`
   - Set all to null

5. **getWebSocketServer():** Return wss (keep existing)

**maxPayload rationale:** Default 100MB is a DoS vector. RESEARCH.md recommends 1MB limit (sufficient for text messages, prevents abuse).

**Connection flow:**
1. Client connects -> addConnection generates UUID
2. Client sends HANDSHAKE -> server responds with CLIENT_ID
3. Client sends JOIN_ROOM -> server validates, adds to room
4. All messages validated through messageRouter

**Cleanup on close:** When client disconnects, remove from both connectionManager (with grace period) and roomManager (immediate). This ensures room membership doesn't include disconnected clients.

**Remove old logging:** Delete the sequential connectionCount logging from existing code - ConnectionManager now tracks this properly with UUIDs.
  </action>
  <verify>
```bash
# Verify TypeScript compilation
npx tsc --noEmit -p apps/api/tsconfig.app.json

# Verify server can start (doesn't crash on initialization)
npx nx build api

# Check imports are correct
grep "MessageRouter" apps/api/src/websocket/index.ts
grep "ConnectionManager" apps/api/src/websocket/index.ts
grep "RoomManager" apps/api/src/websocket/index.ts
```
  </verify>
  <done>
- index.ts updated with ConnectionManager, RoomManager, MessageRouter initialization
- TypeScript compilation succeeds
- maxPayload set to 1MB (grep confirms "1024 \* 1024")
- Connection handler uses messageRouter.routeMessage for all messages
- Close handler calls both connectionManager.removeConnection and roomManager.leaveRoom
- Old sequential connectionCount logging removed
- Build succeeds: `npx nx build api` completes without errors
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **MessageRouter functional:** Can validate and route HANDSHAKE and JOIN_ROOM messages
2. **Server initialization updated:** Uses all new infrastructure components
3. **Message flow works:** Connection -> HANDSHAKE -> CLIENT_ID response
4. **Room joining works:** JOIN_ROOM -> capacity check -> ROOM_JOINED or ERROR
5. **Error handling works:** Invalid messages trigger ERROR responses
6. **TypeScript clean:** No compilation errors across all WebSocket modules
7. **Build succeeds:** `npx nx build api` completes successfully
</verification>

<success_criteria>
**Measurable completion:**

- [ ] `message-router.ts` exports MessageRouter class
- [ ] MessageRouter.routeMessage validates with ClientMessageSchema (import confirmed)
- [ ] MessageRouter handles HANDSHAKE and JOIN_ROOM message types
- [ ] All outbound messages include messageId (crypto.randomUUID()) and timestamp
- [ ] Invalid messages caught and converted to ERROR messages
- [ ] `index.ts` initializes ConnectionManager, RoomManager, MessageRouter
- [ ] WebSocketServer configured with maxPayload: 1MB
- [ ] Connection handler routes messages through MessageRouter
- [ ] Close handler calls both removeConnection and leaveRoom
- [ ] TypeScript compilation succeeds: `npx tsc --noEmit -p apps/api/tsconfig.app.json`
- [ ] Build succeeds: `npx nx build api`
</success_criteria>

<output>
After completion, create `/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-03-SUMMARY.md`
</output>
