---
phase: 13-deployment
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - terraform/backend.tf
  - terraform/variables.tf
  - terraform/main.tf
  - terraform/outputs.tf
  - terraform/iam.tf
  - terraform/terraform.tfvars.example
  - .gitignore
autonomous: true

must_haves:
  truths:
    - Terraform configuration creates Cloud Run service
    - Service is publicly accessible without authentication
    - Service configured for WebSocket support (3600s timeout)
    - Single instance constraint enforced
    - Service scales to zero when idle
  artifacts:
    - path: terraform/backend.tf
      provides: GCS state backend configuration
      min_lines: 10
    - path: terraform/main.tf
      provides: Cloud Run v2 service resource
      min_lines: 40
      contains: google_cloud_run_v2_service
    - path: terraform/variables.tf
      provides: Input variables
      min_lines: 30
    - path: terraform/iam.tf
      provides: Public access configuration
      min_lines: 5
  key_links:
    - from: terraform/main.tf
      to: google_cloud_run_v2_service
      via: Cloud Run service definition
      pattern: resource.*google_cloud_run_v2_service
    - from: terraform/main.tf
      to: timeout.*3600s
      via: WebSocket timeout configuration
      pattern: timeout.*=.*"3600s"
---

<objective>
Create Terraform infrastructure configuration for Google Cloud Run deployment.

Purpose: Define Cloud Run service with WebSocket support, cost optimization settings, and public access using Infrastructure-as-Code.

Output: Terraform configuration files (backend, variables, main service, IAM, outputs) ready for deployment to GCP.
</objective>

<execution_context>
@/Users/bmcalindin/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-deployment/13-CONTEXT.md
@.planning/phases/13-deployment/13-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Terraform backend and variables files</name>
  <files>terraform/backend.tf, terraform/variables.tf, terraform/terraform.tfvars.example</files>
  <action>
Create terraform/ directory and three foundational files:

**terraform/backend.tf:**

```hcl
terraform {
  backend "gcs" {
    bucket = "catan-terraform-state"
    prefix = "prod"
  }

  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 6.0"
    }
  }

  required_version = ">= 1.0"
}

provider "google" {
  project = var.project_id
  region  = var.region
}
```

**terraform/variables.tf:**

```hcl
variable "project_id" {
  description = "GCP project ID"
  type        = string
}

variable "region" {
  description = "GCP region for Cloud Run deployment"
  type        = string
  default     = "europe-west1"
}

variable "service_name" {
  description = "Cloud Run service name"
  type        = string
  default     = "catan-game"
}

variable "image_url" {
  description = "Container image URL from Artifact Registry or GCR"
  type        = string
}

variable "min_instances" {
  description = "Minimum number of instances (0 = scale to zero)"
  type        = number
  default     = 0
}

variable "max_instances" {
  description = "Maximum number of instances"
  type        = number
  default     = 1
}

variable "cpu_limit" {
  description = "CPU limit per instance"
  type        = string
  default     = "1"
}

variable "memory_limit" {
  description = "Memory limit per instance"
  type        = string
  default     = "512Mi"
}

variable "max_concurrency" {
  description = "Maximum concurrent requests per instance"
  type        = number
  default     = 20
}
```

**terraform/terraform.tfvars.example:**

```hcl
# Copy this file to terraform.tfvars and fill in your values
# terraform.tfvars is gitignored

project_id = "your-gcp-project-id"
image_url  = "gcr.io/your-gcp-project-id/catan:latest"
region     = "europe-west1"

# Optional overrides
# service_name = "catan-game"
# min_instances = 0
# max_instances = 1
# cpu_limit = "1"
# memory_limit = "512Mi"
# max_concurrency = 20
```

Follow research Pattern 3 (Terraform Modular Structure) from 13-RESEARCH.md:175-314.
</action>
<verify>
cd terraform && terraform init (should initialize without errors, though backend bucket may not exist yet)
terraform validate (should pass validation)
</verify>
<done>Terraform backend, variables, and example tfvars files created with correct structure</done>
</task>

<task type="auto">
  <name>Task 2: Create Cloud Run v2 service configuration</name>
  <files>terraform/main.tf</files>
  <action>
Create terraform/main.tf with google_cloud_run_v2_service resource:

```hcl
resource "google_cloud_run_v2_service" "api" {
  name     = var.service_name
  location = var.region

  template {
    timeout = "3600s"  # 1 hour for full game sessions

    scaling {
      min_instance_count = var.min_instances  # Scale to zero
      max_instance_count = var.max_instances  # Single instance constraint
    }

    max_instance_request_concurrency = var.max_concurrency

    containers {
      image = var.image_url

      resources {
        limits = {
          cpu    = var.cpu_limit
          memory = var.memory_limit
        }
        cpu_idle = false  # Instance-based billing for WebSocket
      }

      ports {
        name           = "http1"
        container_port = 8080
      }

      env {
        name  = "NODE_ENV"
        value = "production"
      }

      startup_probe {
        http_get {
          path = "/api"
        }
        initial_delay_seconds = 10
        timeout_seconds       = 3
        period_seconds        = 10
        failure_threshold     = 3
      }

      liveness_probe {
        http_get {
          path = "/api"
        }
        initial_delay_seconds = 30
        timeout_seconds       = 3
        period_seconds        = 30
        failure_threshold     = 3
      }
    }

    session_affinity = true  # Best-effort WebSocket connection stickiness
  }

  traffic {
    type    = "TRAFFIC_TARGET_ALLOCATION_TYPE_LATEST"
    percent = 100
  }

  # Enable public access (no authentication required)
  ingress = "INGRESS_TRAFFIC_ALL"
}
```

Key configuration decisions from 13-CONTEXT.md:

- timeout = "3600s" for full game sessions (maximum allowed)
- min_instance_count = 0 for scale to zero
- max_instance_count = 1 for cost control
- cpu_idle = false for WebSocket stability (instance-based billing)
- session_affinity = true for WebSocket connection stickiness
- max_concurrency = 20 (conservative for WebSocket)

Follow research Pattern 3 from 13-RESEARCH.md:199-250.
</action>
<verify>
cd terraform && terraform validate
terraform fmt -check (should pass formatting)
</verify>
<done>Cloud Run v2 service resource defined with WebSocket-optimized configuration</done>
</task>

<task type="auto">
  <name>Task 3: Create IAM and outputs configuration</name>
  <files>terraform/iam.tf, terraform/outputs.tf, .gitignore</files>
  <action>
Create three files for IAM policy, outputs, and gitignore updates:

**terraform/iam.tf:**

```hcl
# Allow unauthenticated access to Cloud Run service
resource "google_cloud_run_v2_service_iam_member" "public_invoker" {
  location = google_cloud_run_v2_service.api.location
  name     = google_cloud_run_v2_service.api.name
  role     = "roles/run.invoker"
  member   = "allUsers"
}
```

**terraform/outputs.tf:**

```hcl
output "service_url" {
  value       = google_cloud_run_v2_service.api.uri
  description = "Cloud Run service URL"
}

output "service_name" {
  value       = google_cloud_run_v2_service.api.name
  description = "Cloud Run service name"
}

output "service_location" {
  value       = google_cloud_run_v2_service.api.location
  description = "Cloud Run service location (region)"
}
```

**Update .gitignore** (add to end of file):

```
# Terraform
terraform/.terraform/
terraform/.terraform.lock.hcl
terraform/terraform.tfstate
terraform/terraform.tfstate.backup
terraform/terraform.tfvars
*.tfplan
```

Follow research Pattern 3 from 13-RESEARCH.md:252-314.
</action>
<verify>
cd terraform && terraform validate
git check-ignore terraform/terraform.tfvars (should be ignored)
</verify>
<done>IAM policy for public access, Terraform outputs, and gitignore rules created</done>
</task>

</tasks>

<verification>
1. Terraform files follow modular structure (separate files for concerns)
2. terraform validate passes without errors
3. Cloud Run v2 service configured for WebSocket (3600s timeout, instance-based billing)
4. Scaling configured for cost optimization (0-1 instances)
5. Public access IAM policy allows unauthenticated requests
6. terraform.tfvars is gitignored
7. Outputs provide service URL for deployment verification
</verification>

<success_criteria>

- All Terraform files created with valid HCL syntax
- terraform init and terraform validate succeed
- Service configuration matches 13-CONTEXT.md decisions:
  - Scale to zero enabled
  - Maximum 1 instance
  - 3600s timeout for game sessions
  - Instance-based billing (cpu_idle = false)
  - Session affinity enabled
  - Conservative concurrency (20)
- Public access configured via IAM policy
- Sensitive files gitignored
  </success_criteria>

<output>
After completion, create `.planning/phases/13-deployment/13-02-SUMMARY.md`
</output>
