---
phase: 13-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile
  - .dockerignore
  - apps/api/src/main.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - Docker build completes successfully for both web and api apps
    - Production image excludes development dependencies
    - Image size is minimized through multi-stage build
    - Container can serve both WebSocket and static frontend files
  artifacts:
    - path: Dockerfile
      provides: Multi-stage build configuration
      min_lines: 60
    - path: .dockerignore
      provides: Build context optimization
      min_lines: 20
    - path: apps/api/src/main.ts
      provides: Static file serving via Express
      contains: express.static
  key_links:
    - from: Dockerfile
      to: dist/apps/web
      via: COPY built frontend artifacts
      pattern: COPY.*dist/apps/web
    - from: apps/api/src/main.ts
      to: express.static
      via: Serve frontend from API
      pattern: express\.static
---

<objective>
Create Docker multi-stage build and configure API to serve frontend static files.

Purpose: Enable single-container deployment where Express API serves both WebSocket connections and frontend static content, optimized for minimal image size.

Output: Dockerfile with 3-stage build (deps, build, runtime), .dockerignore for context optimization, and Express static middleware configuration.
</objective>

<execution_context>
@/Users/bmcalindin/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-deployment/13-CONTEXT.md
@.planning/phases/13-deployment/13-RESEARCH.md
@apps/api/src/main.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create multi-stage Dockerfile for NX monorepo</name>
  <files>Dockerfile</files>
  <action>
Create multi-stage Dockerfile at project root with three stages following Node.js Alpine best practices:

**Stage 1 (deps):** Install all dependencies including dev dependencies

- FROM node:20-alpine AS deps
- WORKDIR /app
- COPY package\*.json ./
- RUN npm ci --production=false

**Stage 2 (build):** Build both web and api apps using NX

- FROM node:20-alpine AS build
- WORKDIR /app
- COPY --from=deps /app/node_modules ./node_modules
- COPY . .
- RUN npx nx build api --prod
- RUN npx nx build web --prod

**Stage 3 (runtime):** Production runtime with minimal dependencies

- FROM node:20-alpine AS runtime
- WORKDIR /app
- Install production dependencies only: RUN npm ci --production --ignore-scripts
- Copy built artifacts from build stage (dist/apps/api and dist/apps/web)
- Create non-root user: addgroup -g 1001 -S nodejs && adduser -S nodejs -u 1001
- Switch to nodejs user: USER nodejs
- EXPOSE 8080 (Cloud Run convention)
- CMD ["node", "dist/apps/api/main.js"]

Follow research Pattern 1 (Multi-Stage Docker Build for NX Monorepo) from 13-RESEARCH.md:150-200.
</action>
<verify>
docker build -t catan-test . (should complete successfully)
docker images | grep catan-test (check image size, should be < 400MB)
</verify>
<done>Dockerfile exists with 3 stages, builds successfully, creates runtime image with non-root user</done>
</task>

<task type="auto">
  <name>Task 2: Create .dockerignore for build optimization</name>
  <files>.dockerignore</files>
  <action>
Create .dockerignore at project root to exclude unnecessary files from Docker build context:

**Exclude patterns:**

- \*\*/node_modules/ (reinstalled in container)
- .nx/ (NX cache)
- dist/ (rebuilt in container)
- .git/ .gitignore
- .vscode/ .idea/
- coverage/ **/\*.test.ts **/\*.spec.ts
- .github/ .circleci/
- .env\* !.env.example
- logs/ _.log npm-debug.log_
- \*.md !README.md
- .planning/ (planning docs not needed in container)
- screenshots/ mockups/ .designs/

Follow research Pattern 4 (.dockerignore for NX Monorepo) from 13-RESEARCH.md:316-364.
</action>
<verify>
docker build --progress=plain -t catan-test . 2>&1 | grep "Sending build context" (context should be < 50MB)
</verify>
<done>.dockerignore exists with comprehensive exclusions, Docker build context is optimized</done>
</task>

<task type="auto">
  <name>Task 3: Configure Express to serve frontend static files</name>
  <files>apps/api/src/main.ts</files>
  <action>
Update apps/api/src/main.ts to serve built frontend static files via Express middleware:

1. Add import at top:
   import \* as path from 'path';

2. After existing middleware (line ~16), add static file serving BEFORE WebSocket routes:

   ```typescript
   // Serve frontend static files
   const webDistPath = path.join(__dirname, '../web');
   app.use(
     express.static(webDistPath, {
       maxAge: '1y',
       immutable: true,
       setHeaders: (res, filePath) => {
         // Don't cache HTML files for SPA routing
         if (filePath.endsWith('.html')) {
           res.setHeader('Cache-Control', 'no-cache');
         }
       },
     }),
   );
   ```

3. Add SPA fallback route AFTER all API routes and WebSocket setup (before httpServer.listen):

   ```typescript
   // SPA fallback - serve index.html for all other routes
   app.get('*', (req, res) => {
     res.sendFile(path.join(webDistPath, 'index.html'));
   });
   ```

4. Update port binding to use 0.0.0.0 (required for Cloud Run):
   Change: httpServer.listen(port, () => {
   To: httpServer.listen(port, '0.0.0.0', () => {

5. Ensure PORT environment variable is read correctly (already exists at line 22, verify it's correct):
   const port = (process.env['PORT'] as unknown as number) || 3333;

Follow research Pattern 2 (Serving Static Frontend from Express API) from 13-RESEARCH.md:122-173, but use standard express.static (not express-static-gzip yet - save compression for future optimization).

IMPORTANT: Static file serving must come BEFORE WebSocket upgrade handler setup, and SPA fallback must come AFTER all defined routes.
</action>
<verify>
npx nx build web --prod && npx nx build api --prod
node dist/apps/api/main.js (start server)
curl http://localhost:3333/ (should return HTML, not JSON)
curl http://localhost:3333/api (should return JSON welcome message)
</verify>
<done>Express serves frontend static files, SPA routing works, API routes still functional, server binds to 0.0.0.0</done>
</task>

</tasks>

<verification>
1. Docker build completes without errors
2. Built image size is reasonable (< 400MB for Alpine Node.js with app)
3. Docker build context is optimized (< 50MB)
4. Express serves both frontend static files and API/WebSocket routes
5. SPA routing fallback works correctly
6. Server binds to 0.0.0.0 for container networking
</verification>

<success_criteria>

- Dockerfile builds successfully with multi-stage pattern
- Production image excludes dev dependencies and has non-root user
- .dockerignore reduces build context to essential files only
- Express API serves both WebSocket and frontend static content
- SPA routing works (all routes serve index.html as fallback)
- Server listens on dynamic PORT environment variable and 0.0.0.0 host
  </success_criteria>

<output>
After completion, create `.planning/phases/13-deployment/13-01-SUMMARY.md`
</output>
