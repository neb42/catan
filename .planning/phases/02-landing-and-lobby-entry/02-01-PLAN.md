---
phase: 02-landing-and-lobby-entry
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/websocket/schemas/client-messages.ts
  - apps/api/src/websocket/schemas/server-messages.ts
autonomous: true

must_haves:
  truths:
    - "Client can send SET_NICKNAME message to server"
    - "Server responds with NICKNAME_ACCEPTED when nickname is unique"
    - "Server responds with NICKNAME_REJECTED when nickname is taken or invalid"
  artifacts:
    - path: "apps/api/src/websocket/schemas/client-messages.ts"
      provides: "SET_NICKNAME message schema"
      contains: "SetNicknameMessageSchema"
    - path: "apps/api/src/websocket/schemas/server-messages.ts"
      provides: "NICKNAME_ACCEPTED and NICKNAME_REJECTED message schemas"
      contains: "NicknameAcceptedMessageSchema"
  key_links:
    - from: "apps/api/src/websocket/schemas/client-messages.ts"
      to: "ClientMessageSchema discriminated union"
      via: "Add SetNicknameMessageSchema to union"
      pattern: "z\\.discriminatedUnion.*SetNicknameMessageSchema"
    - from: "apps/api/src/websocket/schemas/server-messages.ts"
      to: "ServerMessageSchema discriminated union"
      via: "Add nickname response schemas to union"
      pattern: "z\\.discriminatedUnion.*NicknameAcceptedMessageSchema"
---

<objective>
Extend Phase 1 WebSocket message schemas to support nickname validation flow.

Purpose: Enable client-server communication for nickname entry, uniqueness validation, and acceptance/rejection responses.

Output: Zod schemas for SET_NICKNAME, NICKNAME_ACCEPTED, and NICKNAME_REJECTED messages with TypeScript type inference.
</objective>

<execution_context>
@/Users/bmcalindin/workspace/catan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/workspace/catan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/bmcalindin/workspace/catan/.planning/PROJECT.md
@/Users/bmcalindin/workspace/catan/.planning/ROADMAP.md
@/Users/bmcalindin/workspace/catan/.planning/STATE.md
@/Users/bmcalindin/workspace/catan/.planning/phases/02-landing-and-lobby-entry/02-CONTEXT.md
@/Users/bmcalindin/workspace/catan/.planning/phases/02-landing-and-lobby-entry/02-RESEARCH.md

# Phase 1 established WebSocket message schema pattern
@/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-01-SUMMARY.md
@/Users/bmcalindin/workspace/catan/apps/api/src/websocket/schemas/client-messages.ts
@/Users/bmcalindin/workspace/catan/apps/api/src/websocket/schemas/server-messages.ts
</context>

<tasks>

<task type="auto">
  <name>Add SET_NICKNAME client message schema</name>
  <files>apps/api/src/websocket/schemas/client-messages.ts</files>
  <action>
Add SetNicknameMessageSchema to client-messages.ts following the established pattern from Phase 1.

Schema requirements (from CONTEXT.md and RESEARCH.md):
- Message type: 'SET_NICKNAME'
- Payload fields:
  - nickname: string, min 3 characters, max 30 characters, trimmed
- Add to ClientMessageSchema discriminated union

Follow the exact pattern used for HandshakeMessageSchema and JoinRoomMessageSchema:
1. Define schema with z.object
2. Export TypeScript type with z.infer
3. Add JSDoc comment explaining when message is sent and expected response
4. Add to discriminated union array

Why these constraints:
- 3-30 character limit matches CONTEXT.md decision (UX requirement)
- .trim() ensures whitespace-only nicknames are invalid
- Zod validation provides clear error messages for client-side validation

Reference RESEARCH.md code example (lines 469-500) for exact schema structure.
  </action>
  <verify>
Run TypeScript typecheck to ensure schema compiles without errors:
```bash
npx tsc --noEmit -p apps/api/tsconfig.app.json
```

Verify SetNicknameMessageSchema is exported and added to ClientMessageSchema discriminated union.
  </verify>
  <done>
SetNicknameMessageSchema defined with min/max/trim validation, TypeScript type exported, and added to ClientMessageSchema discriminated union. TypeScript compilation succeeds.
  </done>
</task>

<task type="auto">
  <name>Add NICKNAME_ACCEPTED and NICKNAME_REJECTED server message schemas</name>
  <files>apps/api/src/websocket/schemas/server-messages.ts</files>
  <action>
Add NicknameAcceptedMessageSchema and NicknameRejectedMessageSchema to server-messages.ts following Phase 1 server message pattern.

NICKNAME_ACCEPTED schema:
- Message type: 'NICKNAME_ACCEPTED'
- Payload fields:
  - nickname: string (echoes accepted nickname)
- Include messageId and timestamp fields (required for all server messages per Phase 1 pattern)
- JSDoc: "Sent when nickname is unique and valid. Client should navigate to lobby."

NICKNAME_REJECTED schema:
- Message type: 'NICKNAME_REJECTED'
- Payload fields:
  - message: string (human-readable error message)
  - reason: enum ['ALREADY_TAKEN', 'INVALID_FORMAT']
- Include messageId and timestamp fields
- JSDoc: "Sent when nickname is already taken or invalid."

Add both schemas to ServerMessageSchema discriminated union.

Why reason enum:
- ALREADY_TAKEN: Server-side uniqueness check failed (another user has this nickname)
- INVALID_FORMAT: Should not happen if client validation works, but handles edge cases

Follow the exact pattern used for ClientIdMessageSchema, ErrorMessageSchema, and RoomJoinedMessageSchema.

Reference RESEARCH.md code example (lines 502-547) for exact schema structure.
  </action>
  <verify>
Run TypeScript typecheck to ensure schemas compile without errors:
```bash
npx tsc --noEmit -p apps/api/tsconfig.app.json
```

Verify both schemas are exported and added to ServerMessageSchema discriminated union.
  </verify>
  <done>
NicknameAcceptedMessageSchema and NicknameRejectedMessageSchema defined with proper payload fields, messageId, and timestamp. Both schemas added to ServerMessageSchema discriminated union. TypeScript compilation succeeds.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes for API app
2. SET_NICKNAME schema validates 3-30 character strings with trim
3. NICKNAME_ACCEPTED schema includes nickname in payload
4. NICKNAME_REJECTED schema includes message and reason enum
5. All three schemas added to their respective discriminated unions
6. Schema pattern matches Phase 1 established conventions
</verification>

<success_criteria>
- Client message schema extended with SET_NICKNAME message type
- Server message schemas extended with NICKNAME_ACCEPTED and NICKNAME_REJECTED message types
- All schemas follow Phase 1 discriminated union pattern
- TypeScript types automatically inferred for type-safe message handling
- No TypeScript compilation errors
- Foundation ready for server-side nickname validation handler (Plan 02) and client-side landing page (Plan 03)
</success_criteria>

<output>
After completion, create `.planning/phases/02-landing-and-lobby-entry/02-01-SUMMARY.md` following the SUMMARY template.
</output>
