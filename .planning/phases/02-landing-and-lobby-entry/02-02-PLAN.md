---
phase: 02-landing-and-lobby-entry
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - apps/api/src/websocket/message-router.ts
  - apps/api/src/websocket/room-manager.ts
autonomous: true

must_haves:
  truths:
    - "Server validates nickname uniqueness against existing room members"
    - "Server responds with NICKNAME_ACCEPTED when nickname is unique"
    - "Server responds with NICKNAME_REJECTED when nickname is already taken"
    - "Server stores nickname for client ID after acceptance"
  artifacts:
    - path: "apps/api/src/websocket/message-router.ts"
      provides: "SET_NICKNAME message handler"
      contains: "case 'SET_NICKNAME'"
    - path: "apps/api/src/websocket/room-manager.ts"
      provides: "Nickname storage and validation methods"
      min_lines: 30
  key_links:
    - from: "apps/api/src/websocket/message-router.ts"
      to: "roomManager.setNickname"
      via: "Call setNickname method on SET_NICKNAME message"
      pattern: "roomManager\\.setNickname"
    - from: "apps/api/src/websocket/room-manager.ts"
      to: "connectionManager.sendToClient"
      via: "Send NICKNAME_ACCEPTED or NICKNAME_REJECTED response"
      pattern: "sendToClient.*NICKNAME_(ACCEPTED|REJECTED)"
---

<objective>
Implement server-side nickname validation and storage with uniqueness checking.

Purpose: Validate nickname uniqueness within the lobby and respond to clients with acceptance or rejection messages.

Output: Message router handler for SET_NICKNAME and RoomManager methods for nickname validation and storage.
</objective>

<execution_context>
@/Users/bmcalindin/workspace/catan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/workspace/catan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/bmcalindin/workspace/catan/.planning/PROJECT.md
@/Users/bmcalindin/workspace/catan/.planning/ROADMAP.md
@/Users/bmcalindin/workspace/catan/.planning/STATE.md
@/Users/bmcalindin/workspace/catan/.planning/phases/02-landing-and-lobby-entry/02-CONTEXT.md
@/Users/bmcalindin/workspace/catan/.planning/phases/02-landing-and-lobby-entry/02-RESEARCH.md

# Phase 1 established message routing and room management patterns
@/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-02-SUMMARY.md
@/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-03-SUMMARY.md
@/Users/bmcalindin/workspace/catan/apps/api/src/websocket/message-router.ts
@/Users/bmcalindin/workspace/catan/apps/api/src/websocket/room-manager.ts
@/Users/bmcalindin/workspace/catan/apps/api/src/websocket/connection-manager.ts
</context>

<tasks>

<task type="auto">
  <name>Add nickname storage to RoomManager</name>
  <files>apps/api/src/websocket/room-manager.ts</files>
  <action>
Extend RoomManager to track nicknames for each client in a room and provide validation methods.

Add to Room interface (or create if needed):
- nicknames: Map<string, string> (clientId -> nickname mapping)

Add methods to RoomManager class:

1. `setNickname(roomId: string, clientId: string, nickname: string): boolean`
   - Check if nickname already exists in room (case-insensitive comparison)
   - If unique: store in nicknames map, return true
   - If taken: return false
   - Use Array.from(room.nicknames.values()).some(n => n.toLowerCase() === nickname.toLowerCase()) for uniqueness check

2. `getNickname(roomId: string, clientId: string): string | undefined`
   - Return nickname for given clientId in room
   - Returns undefined if no nickname set

3. `isNicknameAvailable(roomId: string, nickname: string): boolean`
   - Check if nickname is available (not taken by any client in room)
   - Case-insensitive comparison
   - Returns true if available

Why case-insensitive:
- Prevents confusion between "Alice" and "alice"
- Standard practice for username/nickname validation
- Improves user experience (no "Alice" vs "alice" conflicts)

Implementation notes:
- Initialize nicknames map when room is created (in createRoom or constructor)
- Clean up nickname when client leaves room (in existing removeClient or cleanup logic)
- Room deletion already handles cleanup (Phase 1 decision: delete empty rooms immediately)
  </action>
  <verify>
Run TypeScript typecheck to ensure RoomManager compiles:
```bash
npx tsc --noEmit -p apps/api/tsconfig.app.json
```

Verify methods are exported and accessible to message router.
  </verify>
  <done>
RoomManager has nicknames Map, setNickname method with uniqueness validation, getNickname method, and isNicknameAvailable helper. TypeScript compilation succeeds.
  </done>
</task>

<task type="auto">
  <name>Add SET_NICKNAME message handler to router</name>
  <files>apps/api/src/websocket/message-router.ts</files>
  <action>
Add SET_NICKNAME case to message router switch statement following Phase 1 message routing pattern.

Handler logic:
1. Validate client is connected (clientId exists in connectionManager)
2. Get nickname from message.payload.nickname
3. Determine roomId (likely 'lobby' for v0.1 single-lobby model per PROJECT.md)
4. Call roomManager.isNicknameAvailable(roomId, nickname)
5. If available:
   - Call roomManager.setNickname(roomId, clientId, nickname)
   - Send NICKNAME_ACCEPTED response:
     ```
     connectionManager.sendToClient(clientId, {
       type: 'NICKNAME_ACCEPTED',
       payload: { nickname },
       messageId: crypto.randomUUID(),
       timestamp: Date.now()
     })
     ```
6. If taken:
   - Send NICKNAME_REJECTED response:
     ```
     connectionManager.sendToClient(clientId, {
       type: 'NICKNAME_REJECTED',
       payload: {
         message: 'This nickname is already taken. Try another!',
         reason: 'ALREADY_TAKEN'
       },
       messageId: crypto.randomUUID(),
       timestamp: Date.now()
     })
     ```

Error handling:
- If client not found: Send ERROR message (follow existing pattern from JOIN_ROOM handler)
- Zod validation errors are already handled by router (Phase 1 pattern)

Why 'lobby' as roomId:
- PROJECT.md states "Single lobby model" for v0.1
- All users join the same lobby room
- Future phases may support multiple lobbies, but v0.1 uses hardcoded 'lobby'

Use crypto.randomUUID() for messageId (Phase 1 decision from 01-03-SUMMARY.md)
  </action>
  <verify>
Run TypeScript typecheck to ensure message router compiles:
```bash
npx tsc --noEmit -p apps/api/tsconfig.app.json
```

Start API server and verify no runtime errors:
```bash
npx nx serve api
```

Test with WebSocket client or browser console (manual verification in next plan's testing).
  </verify>
  <done>
SET_NICKNAME case added to message router with uniqueness validation, NICKNAME_ACCEPTED/NICKNAME_REJECTED responses, and error handling. TypeScript compilation succeeds. API server starts without errors.
  </done>
</task>

</tasks>

<verification>
1. RoomManager tracks nicknames per room with Map<clientId, nickname>
2. Nickname uniqueness check is case-insensitive
3. setNickname method validates uniqueness before storing
4. Message router has SET_NICKNAME handler
5. NICKNAME_ACCEPTED response includes accepted nickname
6. NICKNAME_REJECTED response includes error message and ALREADY_TAKEN reason
7. No TypeScript compilation errors
8. API server starts successfully
</verification>

<success_criteria>
- Server validates nickname uniqueness within lobby room
- Unique nicknames are accepted and stored for client ID
- Duplicate nicknames (case-insensitive) are rejected with clear error message
- Message router delegates to RoomManager for validation logic
- Follows Phase 1 patterns for message handling and response structure
- Ready for client-side landing page to send SET_NICKNAME messages (Plan 03)
</success_criteria>

<output>
After completion, create `.planning/phases/02-landing-and-lobby-entry/02-02-SUMMARY.md` following the SUMMARY template.
</output>
