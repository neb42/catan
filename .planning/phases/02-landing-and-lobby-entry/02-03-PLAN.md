---
phase: 02-landing-and-lobby-entry
plan: 03
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - apps/web/src/routes/index.tsx
  - apps/web/src/routes/lobby.tsx
  - apps/web/src/components/AnimatedBackground.tsx
  - apps/web/src/components/AnimatedBackground.css
autonomous: false

must_haves:
  truths:
    - "User sees landing page with nickname input field on app load"
    - "User can type nickname and see character count update"
    - "User cannot submit empty or too-short nickname (client validation)"
    - "User sees error message when nickname is rejected by server"
    - "User navigates to lobby page after nickname is accepted"
  artifacts:
    - path: "apps/web/src/routes/index.tsx"
      provides: "Landing page with nickname form"
      min_lines: 80
    - path: "apps/web/src/routes/lobby.tsx"
      provides: "Lobby placeholder page"
      min_lines: 20
    - path: "apps/web/src/components/AnimatedBackground.tsx"
      provides: "Animated background component"
      min_lines: 30
  key_links:
    - from: "apps/web/src/routes/index.tsx"
      to: "useWebSocket().sendMessage"
      via: "Send SET_NICKNAME message on form submit"
      pattern: "sendMessage.*SET_NICKNAME"
    - from: "apps/web/src/routes/index.tsx"
      to: "navigate({ to: '/lobby' })"
      via: "Navigate to lobby on NICKNAME_ACCEPTED message"
      pattern: "navigate.*lobby"
    - from: "apps/web/src/routes/index.tsx"
      to: "AnimatedBackground component"
      via: "Render background on landing page"
      pattern: "AnimatedBackground"
---

<objective>
Build landing page with nickname entry form and lobby placeholder route.

Purpose: Provide user interface for entering nickname, client-side validation, server communication, and navigation to lobby on success.

Output: Complete landing page with form, animations, error handling, and lobby placeholder page.
</objective>

<execution_context>
@/Users/bmcalindin/workspace/catan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/workspace/catan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/bmcalindin/workspace/catan/.planning/PROJECT.md
@/Users/bmcalindin/workspace/catan/.planning/ROADMAP.md
@/Users/bmcalindin/workspace/catan/.planning/STATE.md
@/Users/bmcalindin/workspace/catan/.planning/phases/02-landing-and-lobby-entry/02-CONTEXT.md
@/Users/bmcalindin/workspace/catan/.planning/phases/02-landing-and-lobby-entry/02-RESEARCH.md

# Phase 1 established WebSocket context and routing
@/Users/bmcalindin/workspace/catan/.planning/phases/01-websocket-infrastructure/01-04-SUMMARY.md
@/Users/bmcalindin/workspace/catan/apps/web/src/lib/websocket-context.tsx
@/Users/bmcalindin/workspace/catan/apps/web/src/routes/__root.tsx
@/Users/bmcalindin/workspace/catan/apps/web/src/routes/index.tsx

# Design system and mockup references
@/Users/bmcalindin/workspace/catan/.planning/design-mockups/landing-page.html
@/Users/bmcalindin/workspace/catan/.planning/DESIGN-SYSTEM.md
</context>

<tasks>

<task type="auto">
  <name>Create AnimatedBackground component</name>
  <files>apps/web/src/components/AnimatedBackground.tsx, apps/web/src/components/AnimatedBackground.css</files>
  <action>
Create AnimatedBackground component matching the design mockup pattern from .planning/design-mockups/landing-page.html.

Component structure:
- Functional React component with no props
- Renders full-screen background layer (position: fixed, inset: 0)
- Uses CSS for all animations (no JavaScript animation loops)
- Imports AnimatedBackground.css for styles

AnimatedBackground.tsx:
```tsx
import './AnimatedBackground.css';

export function AnimatedBackground() {
  return (
    <div className="animated-background">
      <div className="gradient-mesh"></div>
      <div className="floating-shapes">
        {/* Generate 8-12 geometric shapes with varying sizes */}
      </div>
    </div>
  );
}
```

AnimatedBackground.css:
- Full-screen fixed background with z-index: 0 (behind content)
- Gradient mesh using radial gradients with CSS variables from design system
- Floating shapes use CSS animations for gentle float/rotate movements
- Animations use var(--ease-smooth) timing from DESIGN-SYSTEM.md
- @keyframes for float-up, float-down, rotate-slow animations

Reference landing-page.html mockup (lines 150-250) for exact animation structure and gradient patterns.

Design system tokens to use:
- --color-primary, --color-secondary for gradients
- --ease-smooth for animation timing
- --duration-slow for animation durations (8-15s for gentle motion)

Why CSS-only animations:
- Better performance than JavaScript loops
- Respects prefers-reduced-motion media query
- Smaller bundle size (no animation library needed)
  </action>
  <verify>
Start web dev server and visually inspect background:
```bash
npx nx serve web
```

Open http://localhost:4200 and verify:
- Gradient background visible
- Shapes animate smoothly
- No JavaScript errors in console
  </verify>
  <done>
AnimatedBackground component created with gradient mesh and floating shapes. CSS animations run smoothly. Component renders without errors.
  </done>
</task>

<task type="auto">
  <name>Build landing page route with nickname form</name>
  <files>apps/web/src/routes/index.tsx</files>
  <action>
Replace existing index.tsx route with landing page component following RESEARCH.md complete example (lines 332-465).

Component structure:
1. Controlled input with useState for nickname
2. Error state with useState for error messages
3. isSubmitting state for loading indicator
4. useWebSocket hook to access status and sendMessage
5. useNavigate hook for navigation to /lobby
6. useEffect to listen for NICKNAME_ACCEPTED and NICKNAME_REJECTED messages
7. Form submit handler with client-side validation
8. Character counter using Array.from(nickname).length (accurate emoji counting)

Form validation (client-side, before sending to server):
- Trim nickname
- Check length >= 3 characters â†’ error: "Please enter a nickname"
- Check length <= 30 characters â†’ error: "Nickname too long (max 30 characters)"
- Check status === 'connected' â†’ error: "Connection lost. Please wait..."

WebSocket message handling:
- On NICKNAME_ACCEPTED: setTimeout 300ms then navigate({ to: '/lobby' }) (transition delay)
- On NICKNAME_REJECTED: setError(message.payload.message), setIsSubmitting(false)

Form elements (matching CONTEXT.md):
- Title: "Join the Game"
- Subtitle: "Enter your nickname to get started"
- Input: autoFocus, maxLength={30}, placeholder="Your nickname"
- Character counter: "{charCount}/30" always visible
- Submit button: "Enter Lobby" (or "Joining..." when submitting)
- Helper text: "3-4 players â€¢ Choose colors â€¢ Play together"
- Connection status indicator (shown when status !== 'connected')

Error handling:
- Clear error on typing (if error exists, setError(''))
- Error message slide-in animation via CSS class 'error-message visible'
- Input shake animation via CSS class 'error' on input element
- Disable submit button when isSubmitting or status !== 'connected'

Import AnimatedBackground and render before content.

CSS classes (styles created in next task):
- .landing-container (main container with slide-up animation)
- .landing-title, .landing-subtitle (typography)
- .landing-form, .input-group (form layout)
- .landing-input, .landing-input.error (input states)
- .landing-button, .landing-button.pulse (button states)
- .character-counter (counter styling)
- .error-message, .error-message.visible (error display)
- .connection-status (status indicator)

Reference RESEARCH.md lines 332-465 for complete implementation pattern.

Why useEffect for message handling:
- Phase 1 WebSocketContext provides message handler registration via ws.addMessageHandler
- useEffect cleanup removes handler to prevent memory leaks
- Handler checks message.type to filter for relevant messages only
  </action>
  <verify>
Run TypeScript typecheck:
```bash
npx tsc --noEmit -p apps/web/tsconfig.json
```

Start web server and test in browser:
```bash
npx nx serve web
```

Verify:
- Landing page renders with form
- Character counter updates on typing
- Client validation shows errors
- WebSocket connection status visible when not connected
  </verify>
  <done>
Landing page route created with controlled form, client validation, WebSocket message handling, and navigation logic. TypeScript compilation succeeds. Page renders and form accepts input.
  </done>
</task>

<task type="auto">
  <name>Add landing page CSS with animations</name>
  <files>apps/web/src/routes/index.tsx</files>
  <action>
Add CSS to index.tsx route file (or create separate index.css if preferred) following RESEARCH.md CSS examples (lines 551-705).

Required styles:

1. Layout and typography:
   - .landing-container: centered layout, max-width 600px, slide-up animation on mount
   - .landing-title: gradient text (primary to secondary), clamp font size
   - .landing-subtitle: secondary text color, margin

2. Form elements:
   - .landing-form: vertical stack layout
   - .input-group: container for input + counter + error
   - .landing-input: large padding, rounded corners, border transitions
   - .landing-input:focus: primary border color, glow shadow, scale(1.02)
   - .landing-button: gradient background, full-width, uppercase text

3. States and animations:
   - .landing-input.error: error border color, shake animation
   - .error-message: hidden by default
   - .error-message.visible: slide-in-left animation
   - .landing-button.pulse: pulse animation when valid nickname
   - .landing-button:disabled: reduced opacity, no interactions

4. Utility:
   - .character-counter: right-aligned, small text, secondary color
   - .connection-status: fixed top-right, warning color, slide-in animation

@keyframes:
- slide-up: translateY(40px) + opacity 0 â†’ 0 + 1
- shake: translateX oscillation (-8px, 8px, 0)
- slide-in-left: translateX(-20px) + opacity 0 â†’ 0 + 1
- pulse: box-shadow pulse effect

Use CSS variables from design system:
- --color-primary, --color-secondary, --color-error, --color-warning
- --color-bg-surface, --color-text-primary, --color-text-secondary
- --space-xs, --space-sm, --space-md, --space-lg, --space-xl
- --radius-md, --radius-lg, --radius-full
- --ease-smooth, --ease-bounce
- --duration-base, --shadow-md

Reference RESEARCH.md lines 551-705 for exact animation timings and CSS structure.

Why inline in route vs separate file:
- Small amount of CSS (~100 lines)
- Route-specific styles (not shared)
- Co-location improves maintainability
- Can extract to .css file later if it grows

Alternative: Create index.css and import in component (acceptable either way).
  </action>
  <verify>
Start web server and test animations:
```bash
npx nx serve web
```

Test scenarios:
- Page loads with slide-up animation
- Input focus shows scale and glow
- Submit with empty nickname shows shake + error slide-in
- Valid nickname (3+ chars) shows button pulse
- Error message animates in on validation failure
  </verify>
  <done>
Landing page CSS added with animations for slide-up, shake, error slide-in, and button pulse. All styles use design system CSS variables. Animations work smoothly in browser.
  </done>
</task>

<task type="auto">
  <name>Create lobby placeholder route</name>
  <files>apps/web/src/routes/lobby.tsx</files>
  <action>
Create simple lobby placeholder page for Phase 2. This will be replaced with full lobby UI in Phase 3.

Component structure:
```tsx
import { createRoute } from '@tanstack/react-router';
import { Route as rootRoute } from './__root';

export const Route = createRoute({
  getParentRoute: () => rootRoute,
  path: '/lobby',
  component: LobbyPage,
});

function LobbyPage() {
  return (
    <div className="lobby-placeholder">
      <h1>Lobby</h1>
      <p>You're in! Lobby UI coming in Phase 3.</p>
    </div>
  );
}
```

Basic styles (inline or minimal):
- Centered content
- Large heading
- Placeholder text

Why placeholder:
- Phase 2 requirement ENTRY-04: "User joins lobby after entering unique nickname"
- Navigation target needed for successful nickname validation
- Phase 3 will build full lobby UI with player list, ready states, etc.
- Keeps Phase 2 focused on entry flow, not lobby features

This confirms user successfully validated nickname and can proceed to next phase.
  </action>
  <verify>
Run TypeScript typecheck:
```bash
npx tsc --noEmit -p apps/web/tsconfig.json
```

Test navigation:
- Enter valid nickname on landing page
- Verify navigation to /lobby occurs
- Verify placeholder content displays
  </verify>
  <done>
Lobby placeholder route created at /lobby path. Route registers with TanStack Router. Navigation from landing page succeeds. Placeholder content displays.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Landing page with nickname entry form, AnimatedBackground component, client-side validation, WebSocket communication, error handling, and lobby placeholder navigation.

Complete user flow:
1. User loads app â†’ sees landing page with animated background
2. User types nickname â†’ character counter updates (0-30)
3. User submits empty/short nickname â†’ sees client-side error with shake animation
4. User submits valid nickname â†’ button shows "Joining..." loading state
5. Server validates uniqueness â†’ responds with NICKNAME_ACCEPTED or NICKNAME_REJECTED
6. If accepted â†’ page transitions to lobby placeholder
7. If rejected (duplicate) â†’ error message appears with slide-in animation
  </what-built>
  <how-to-verify>
Test the complete nickname entry flow:

1. Start both servers:
```bash
# Terminal 1 - API server
npx nx serve api

# Terminal 2 - Web server
npx nx serve web
```

2. Open browser to http://localhost:4200

3. Verify landing page:
   - [ ] Animated background visible (gradient + floating shapes)
   - [ ] "Join the Game" title with gradient text
   - [ ] Nickname input field auto-focused
   - [ ] Character counter shows "0/30"
   - [ ] Submit button says "Enter Lobby"

4. Test client-side validation:
   - [ ] Type "ab" (2 chars) â†’ submit â†’ error "Please enter a nickname"
   - [ ] Input shakes on error
   - [ ] Error message slides in below input
   - [ ] Type "c" to make "abc" â†’ error clears immediately
   - [ ] Character counter updates to "3/30"

5. Test successful submission:
   - [ ] Enter valid nickname (e.g., "Alice") â†’ submit
   - [ ] Button changes to "Joining..." and disables
   - [ ] Page transitions to /lobby
   - [ ] Lobby placeholder displays "You're in!"

6. Test duplicate nickname rejection:
   - [ ] Open second browser tab/window to http://localhost:4200
   - [ ] Enter same nickname ("Alice") â†’ submit
   - [ ] Error message appears: "This nickname is already taken. Try another!"
   - [ ] Button re-enables for retry
   - [ ] Enter different nickname ("Bob") â†’ submit â†’ navigates to lobby

7. Test connection status:
   - [ ] Stop API server (Ctrl+C in Terminal 1)
   - [ ] Refresh page â†’ connection status shows "Reconnecting..."
   - [ ] Submit button disabled when not connected
   - [ ] Restart API server â†’ status changes to "Connected" (or disappears)
   - [ ] Submit button re-enables

8. Test emoji and special characters:
   - [ ] Enter nickname with emoji "Alice ðŸ˜Š" â†’ character count accurate
   - [ ] Submit â†’ accepted if unique
   - [ ] Enter 30-character nickname â†’ counter shows "30/30"
   - [ ] Try to type 31st character â†’ blocked by maxLength

Expected behavior:
- All animations smooth and visible
- Validation errors clear and actionable
- Nickname uniqueness enforced across clients
- Navigation to lobby on success
- WebSocket reconnection handling works

If any issues found, describe specifically (which step, what happened vs expected).
  </how-to-verify>
  <resume-signal>
Type "approved" if all verification steps pass, or describe specific issues found for fixing.
  </resume-signal>
</task>

</tasks>

<verification>
1. AnimatedBackground component renders with CSS animations
2. Landing page form renders with all required elements
3. Client-side validation works (length checks, connection status)
4. Character counter accurate including emoji (Array.from pattern)
5. WebSocket message handler listens for NICKNAME_ACCEPTED and NICKNAME_REJECTED
6. Navigation to /lobby occurs on acceptance
7. Error messages display on rejection with animations
8. Lobby placeholder route exists and renders
9. All CSS animations (slide-up, shake, slide-in, pulse) work
10. No TypeScript compilation errors
</verification>

<success_criteria>
- User sees landing page with nickname input field (ENTRY-01)
- User cannot proceed without entering nickname (ENTRY-02)
- User receives error message when nickname already taken (ENTRY-03)
- User joins lobby after entering unique nickname (ENTRY-04)
- All animations from design mockup implemented
- WebSocket communication follows Phase 1 patterns
- Form UX matches CONTEXT.md decisions (validation on submit, auto-clear errors, character counter, loading states)
</success_criteria>

<output>
After completion, create `.planning/phases/02-landing-and-lobby-entry/02-03-SUMMARY.md` following the SUMMARY template.
</output>
