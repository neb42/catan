---
phase: 05-building
plan: 03
type: execute
wave: 3
depends_on: ['05-01', '05-02']
files_modified:
  - apps/web/src/stores/gameStore.ts
  - apps/web/src/hooks/useBuildMode.ts
  - apps/web/src/components/BuildControls/BuildControls.tsx
  - apps/web/src/components/Game.tsx
autonomous: true

must_haves:
  truths:
    - 'User can click Road/Settlement/City button to enter build mode'
    - 'User can see building costs inline on buttons (always visible)'
    - 'User can see detailed cost breakdown in tooltips on buttons'
    - 'User can see remaining piece count on buttons'
    - 'Buttons are disabled when player cannot afford or no valid locations'
    - 'Valid locations highlight when in build mode (matching Phase 3 markers)'
    - 'Clicking valid location sends build request'
  artifacts:
    - path: 'apps/web/src/stores/gameStore.ts'
      provides: 'Build mode state slice'
      contains: 'buildMode'
    - path: 'apps/web/src/hooks/useBuildMode.ts'
      provides: 'Build mode hooks'
      exports: ['useBuildMode', 'useCanAfford', 'useValidBuildLocations']
    - path: 'apps/web/src/components/BuildControls/BuildControls.tsx'
      provides: 'Build controls UI'
      min_lines: 100
    - path: 'apps/web/src/components/Board/PlacementOverlay.tsx'
      provides: 'Build location highlighting'
      contains: 'buildMode'
  key_links:
    - from: 'apps/web/src/components/BuildControls/BuildControls.tsx'
      to: 'apps/web/src/stores/gameStore.ts'
      via: 'useBuildMode hook'
      pattern: 'useBuildMode|setBuildMode'
    - from: 'apps/web/src/components/Board/PlacementOverlay.tsx'
      to: 'apps/web/src/hooks/useBuildMode.ts'
      via: 'useValidBuildLocations hook'
      pattern: 'useValidBuildLocations'
---

<objective>
Implement frontend build mode state, controls UI, and location highlighting.

Purpose: Enable players to select what to build, see valid locations, and initiate build actions.
Output: BuildControls component with buttons, tooltips, piece counts, and integrated build overlay.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-building/05-CONTEXT.md
@.planning/phases/05-building/05-01-SUMMARY.md
@.planning/phases/05-building/05-02-SUMMARY.md

@apps/web/src/stores/gameStore.ts
@apps/web/src/hooks/usePlacementState.ts
@apps/web/src/hooks/useValidLocations.ts
@apps/web/src/components/Board/PlacementOverlay.tsx
@apps/web/src/components/ResourceHand/ResourceHand.tsx
@apps/web/src/components/Game.tsx
@libs/shared/src/constants/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add build mode state to gameStore</name>
  <files>
    apps/web/src/stores/gameStore.ts
  </files>
  <action>
Add build mode state slice to gameStore:

```typescript
interface BuildSlice {
  buildMode: 'road' | 'settlement' | 'city' | null;
  isBuildPending: boolean; // Optimistic update in progress
}
```

Add to GameStore interface and initial state:

- buildMode: null
- isBuildPending: false

Add actions:

- setBuildMode: (mode: 'road' | 'settlement' | 'city' | null) => void
- setBuildPending: (pending: boolean) => void

Add selector hooks:

- useBuildMode(): 'road' | 'settlement' | 'city' | null
- useIsBuildPending(): boolean

Add useCanAfford hook:

```typescript
export const useCanAfford = (buildingType: 'road' | 'settlement' | 'city') => {
  return useGameStore((state) => {
    const myId = state.myPlayerId;
    if (!myId) return false;
    const resources = state.playerResources[myId];
    if (!resources) return false;
    const cost = BUILDING_COSTS[buildingType];
    return Object.entries(cost).every(
      ([resource, amount]) =>
        (resources[resource as ResourceType] || 0) >= amount,
    );
  });
};
```

Import BUILDING_COSTS from @catan/shared.
</action>
<verify>
Run `npx nx build web` - should compile without errors.
</verify>
<done>
Build mode state added to gameStore.
setBuildMode and setBuildPending actions work.
useBuildMode, useIsBuildPending, useCanAfford hooks exported.
</done>
</task>

<task type="auto">
  <name>Task 2: Create useBuildMode hook and useValidBuildLocations</name>
  <files>
    apps/web/src/hooks/useBuildMode.ts
  </files>
  <action>
Create new hook file at apps/web/src/hooks/useBuildMode.ts.

1. Create useValidBuildLocations hook:
   - Takes buildMode: 'road' | 'settlement' | 'city' | null
   - Returns { validVertexIds: string[], validEdgeIds: string[] }
   - Uses board hexes to compute all vertices/edges (reuse getUniqueVertices, getUniqueEdges from @catan/shared)
   - Filters based on build mode:

   For 'settlement':
   - Check distance rule (no adjacent settlement)
   - Check connectivity (adjacent to own road)
   - Use client-side validation matching server rules

   For 'road':
   - Check not occupied
   - Check connects to own road or own settlement

   For 'city':
   - Find own settlements where isCity === false

   Memoize with useMemo to avoid recalculating every render.

2. Create usePieceCounts hook:

```typescript
export const usePieceCounts = () => {
  return useGameStore((state) => {
    const myId = state.myPlayerId;
    if (!myId) return { roads: 0, settlements: 0, cities: 0 };
    const roads = state.roads.filter((r) => r.playerId === myId).length;
    const settlements = state.settlements.filter(
      (s) => s.playerId === myId && !s.isCity,
    ).length;
    const cities = state.settlements.filter(
      (s) => s.playerId === myId && s.isCity,
    ).length;
    return { roads, settlements, cities };
  });
};
```

3. Create useRemainingPieces hook:

```typescript
export const useRemainingPieces = () => {
  const counts = usePieceCounts();
  return {
    roads: MAX_PIECES.roads - counts.roads,
    settlements: MAX_PIECES.settlements - counts.settlements,
    cities: MAX_PIECES.cities - counts.cities,
  };
};
```

Import MAX_PIECES from @catan/shared.

4. Export useCanBuild hook combining affordability, piece limits, and valid locations:

```typescript
export const useCanBuild = (type: 'road' | 'settlement' | 'city') => {
  const canAfford = useCanAfford(type);
  const remaining = useRemainingPieces();
  const { validVertexIds, validEdgeIds } = useValidBuildLocations(type);
  const isMyTurn = useIsMyTurnInMainGame();
  const turnPhase = useTurnPhase();

  const hasValidLocations =
    type === 'road' ? validEdgeIds.length > 0 : validVertexIds.length > 0;

  return {
    canBuild:
      isMyTurn &&
      turnPhase === 'main' &&
      canAfford &&
      remaining[type + 's'] > 0 &&
      hasValidLocations,
    canAfford,
    hasRemaining: remaining[type + 's'] > 0,
    hasValidLocations,
    disabledReason: !isMyTurn
      ? 'Not your turn'
      : turnPhase !== 'main'
        ? 'Roll dice first'
        : !canAfford
          ? 'Not enough resources'
          : !remaining[type + 's']
            ? 'No pieces remaining'
            : !hasValidLocations
              ? 'No valid locations'
              : null,
  };
};
```

  </action>
  <verify>
Run `npx nx build web` - should compile without errors.
  </verify>
  <done>
useValidBuildLocations returns valid vertex/edge IDs for current build mode.
usePieceCounts and useRemainingPieces calculate piece usage.
useCanBuild combines all checks and provides disabled reason.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create BuildControls component</name>
  <files>
    apps/web/src/components/BuildControls/BuildControls.tsx
  </files>
  <action>
Create new component at apps/web/src/components/BuildControls/BuildControls.tsx.

Design per CONTEXT.md decisions plus BUILD-04 requirement (costs always visible):

- Three buttons: Road, Settlement, City
- Each button shows: icon + label + inline cost icons + remaining count
- Inline cost icons visible at all times (e.g., "Road ü™µüß± (13)")
- Tooltip on hover shows detailed cost breakdown or disabled reason
- Disabled buttons have tooltip explaining why
- Clicking enabled button sets buildMode in store
- Cancel button appears when in build mode

Structure:

```tsx
import { Button, Tooltip, Group, Stack, Text } from '@mantine/core';
import { useGameStore, useBuildMode } from '../../stores/gameStore';
import { useCanBuild, useRemainingPieces } from '../../hooks/useBuildMode';
import { BUILDING_COSTS } from '@catan/shared';

// Resource icons - compact inline display
const RESOURCE_ICONS: Record<string, string> = {
  lumber: 'ü™µ',
  brick: 'üß±',
  wool: 'üêë',
  grain: 'üåæ',
  ore: 'ÔøΩite',
};

// Inline cost display (always visible on button)
const InlineCost = ({ cost }: { cost: Record<string, number> }) => (
  <span style={{ opacity: 0.8, fontSize: '0.9em' }}>
    {Object.entries(cost)
      .map(
        ([resource, amount]) => RESOURCE_ICONS[resource]?.repeat(amount) || '',
      )
      .join('')}
  </span>
);

// Detailed tooltip showing resource names and counts
const CostTooltip = ({ cost }: { cost: Record<string, number> }) => (
  <Stack gap={2}>
    {Object.entries(cost).map(([resource, amount]) => (
      <Group key={resource} gap={4}>
        <Text size="sm">
          {RESOURCE_ICONS[resource]} {resource}: {amount}
        </Text>
      </Group>
    ))}
  </Stack>
);

export function BuildControls() {
  const buildMode = useBuildMode();
  const setBuildMode = useGameStore((state) => state.setBuildMode);
  const remaining = useRemainingPieces();

  const roadCheck = useCanBuild('road');
  const settlementCheck = useCanBuild('settlement');
  const cityCheck = useCanBuild('city');

  // If in build mode, show cancel button
  if (buildMode) {
    return (
      <Button onClick={() => setBuildMode(null)} color="gray">
        Cancel {buildMode}
      </Button>
    );
  }

  return (
    <Group gap="sm">
      <Tooltip
        label={
          roadCheck.disabledReason || <CostTooltip cost={BUILDING_COSTS.road} />
        }
      >
        <Button
          onClick={() => setBuildMode('road')}
          disabled={!roadCheck.canBuild}
        >
          <Group gap={4}>
            Road <InlineCost cost={BUILDING_COSTS.road} /> ({remaining.roads})
          </Group>
        </Button>
      </Tooltip>

      <Tooltip
        label={
          settlementCheck.disabledReason || (
            <CostTooltip cost={BUILDING_COSTS.settlement} />
          )
        }
      >
        <Button
          onClick={() => setBuildMode('settlement')}
          disabled={!settlementCheck.canBuild}
        >
          <Group gap={4}>
            Settlement <InlineCost cost={BUILDING_COSTS.settlement} /> (
            {remaining.settlements})
          </Group>
        </Button>
      </Tooltip>

      <Tooltip
        label={
          cityCheck.disabledReason || <CostTooltip cost={BUILDING_COSTS.city} />
        }
      >
        <Button
          onClick={() => setBuildMode('city')}
          disabled={!cityCheck.canBuild}
        >
          <Group gap={4}>
            City <InlineCost cost={BUILDING_COSTS.city} /> ({remaining.cities})
          </Group>
        </Button>
      </Tooltip>
    </Group>
  );
}
```

Style to match the warm beige aesthetic from Phase 1.1. Use terracotta accent for active mode.
Position will be handled by Game.tsx integration (near resource hand).
</action>
<verify>
Run `npx nx build web` - should compile without errors.
</verify>
<done>
BuildControls component renders three build buttons.
Buttons show inline cost icons (always visible) + remaining piece count.
Tooltips show detailed cost breakdown (when enabled) or disabled reason.
Cancel button appears when in build mode.
</done>
</task>

</tasks>

<verification>
1. `npx nx build web` compiles successfully
2. BuildControls renders without errors
3. useCanBuild correctly reports affordability and valid locations
4. Build mode state changes when buttons clicked
</verification>

<success_criteria>

- Build mode state exists in gameStore with setBuildMode action
- useCanAfford hook correctly checks player resources against building costs
- useValidBuildLocations returns correct vertex/edge IDs based on placement rules
- BuildControls shows Road/Settlement/City buttons with inline cost icons and piece counts
- Costs are always visible on buttons via inline emoji icons
- Disabled buttons have clear tooltip explaining why disabled
- Enabled buttons have tooltip showing detailed resource cost breakdown
  </success_criteria>

<output>
After completion, create `.planning/phases/05-building/05-03-SUMMARY.md`
</output>
