---
phase: 05-building
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - libs/shared/src/constants/index.ts
  - libs/shared/src/schemas/messages.ts
  - libs/shared/src/index.ts
  - apps/api/src/game/placement-validator.ts
  - apps/api/src/game/placement-validator.spec.ts
autonomous: true

must_haves:
  truths:
    - 'Building costs are defined as constants (road: 1 wood + 1 brick, settlement: 1 wood + 1 brick + 1 sheep + 1 wheat, city: 3 ore + 2 wheat)'
    - 'WebSocket message schemas exist for build_road, build_settlement, build_city requests and responses'
    - 'Placement validators can validate main-game building rules (roads connect, settlements 2 away + adjacent to own road, cities on own settlement)'
  artifacts:
    - path: 'libs/shared/src/constants/index.ts'
      provides: 'BUILDING_COSTS constant with road, settlement, city costs'
      contains: 'BUILDING_COSTS'
    - path: 'libs/shared/src/schemas/messages.ts'
      provides: 'Build message schemas'
      contains: 'BuildRoadMessageSchema'
    - path: 'apps/api/src/game/placement-validator.ts'
      provides: 'Main-game placement validation'
      exports:
        [
          'isValidMainGameSettlement',
          'isValidMainGameRoad',
          'isValidCityUpgrade',
        ]
  key_links:
    - from: 'libs/shared/src/constants/index.ts'
      to: 'apps/api/src/game/GameManager.ts'
      via: 'BUILDING_COSTS import'
      pattern: 'BUILDING_COSTS'
    - from: 'apps/api/src/game/placement-validator.ts'
      to: 'apps/api/src/game/GameManager.ts'
      via: 'validator function imports'
      pattern: 'isValidMainGame'
---

<objective>
Create building system foundation with cost constants, WebSocket message schemas, and main-game placement validators.

Purpose: Establish the contracts and validation logic that backend build handlers and frontend UI will use.
Output: Shared constants, Zod message schemas, and placement validation functions with tests.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-building/05-CONTEXT.md

@libs/shared/src/constants/index.ts
@libs/shared/src/schemas/messages.ts
@libs/shared/src/schemas/game.ts
@apps/api/src/game/placement-validator.ts
@apps/api/src/game/geometry-utils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add building costs constants and message schemas</name>
  <files>
    libs/shared/src/constants/index.ts
    libs/shared/src/schemas/messages.ts
    libs/shared/src/index.ts
  </files>
  <action>
1. In `libs/shared/src/constants/index.ts`, add BUILDING_COSTS constant:
```typescript
export const BUILDING_COSTS = {
  road: { wood: 1, brick: 1 },
  settlement: { wood: 1, brick: 1, sheep: 1, wheat: 1 },
  city: { ore: 3, wheat: 2 },
} as const;

export type BuildingType = keyof typeof BUILDING_COSTS;

````

Also add MAX_PIECES constant for piece limits:
```typescript
export const MAX_PIECES = {
  roads: 15,
  settlements: 5,
  cities: 4,
} as const;
````

2. In `libs/shared/src/schemas/messages.ts`, add build request/response schemas:

Request schemas (client -> server):

- BuildRoadMessageSchema: { type: 'build_road', edgeId: string }
- BuildSettlementMessageSchema: { type: 'build_settlement', vertexId: string }
- BuildCityMessageSchema: { type: 'build_city', vertexId: string }

Response/broadcast schemas (server -> clients):

- RoadBuiltMessageSchema: { type: 'road_built', edgeId: string, playerId: string, resourcesSpent: ResourceCost }
- SettlementBuiltMessageSchema: { type: 'settlement_built', vertexId: string, playerId: string, resourcesSpent: ResourceCost }
- CityBuiltMessageSchema: { type: 'city_built', vertexId: string, playerId: string, resourcesSpent: ResourceCost }
- BuildFailedMessageSchema: { type: 'build_failed', reason: string }

Where ResourceCostSchema = z.record(ResourceTypeSchema, z.number()).

Add all new schemas to WebSocketMessageSchema discriminated union.
Export all new types.

3. In `libs/shared/src/index.ts`, ensure BUILDING_COSTS, MAX_PIECES, BuildingType are exported.
   </action>
   <verify>
   Run `npx nx build shared` - should compile without errors.
   Grep for "BUILDING_COSTS" and "BuildRoadMessageSchema" to confirm exports.
   </verify>
   <done>
   BUILDING_COSTS constant exists with correct costs for road/settlement/city.
   MAX_PIECES constant exists with piece limits.
   All 7 new message schemas added to WebSocketMessageSchema.
   Types exported from @catan/shared.
   </done>
   </task>

<task type="auto">
  <name>Task 2: Add main-game placement validators</name>
  <files>
    apps/api/src/game/placement-validator.ts
    apps/api/src/game/placement-validator.spec.ts
  </files>
  <action>
Extend the existing placement-validator.ts with main-game validation functions.

The existing validators are for setup phase (road must connect to just-placed settlement).
Main-game validators have different rules:

1. Add `isValidMainGameSettlement(vertexId, gameState, playerId, vertices, edges)`:
   - Vertex exists (reuse existing check)
   - Vertex not occupied (reuse existing check)
   - Distance rule: no settlement on adjacent vertex (reuse existing check)
   - NEW: Must be adjacent to player's own road (check edges touching this vertex)

2. Add `getInvalidMainGameSettlementReason(...)` returning null or error string.

3. Add `isValidMainGameRoad(edgeId, gameState, playerId, edges)`:
   - Edge exists
   - Edge not occupied
   - NEW: Must connect to player's own road OR player's own settlement
   - Check both vertices of the edge for player's settlements or roads

4. Add `getInvalidMainGameRoadReason(...)` returning null or error string.

5. Add `isValidCityUpgrade(vertexId, gameState, playerId)`:
   - Vertex has a settlement belonging to playerId
   - Settlement is not already a city (isCity === false)

6. Add `getInvalidCityUpgradeReason(...)` returning null or error string.

Helper needed: `getEdgesAtVertex(vertexId, edges)` - returns edges that have this vertex as an endpoint.

Write comprehensive tests in placement-validator.spec.ts:

- Test main-game settlement: valid (adjacent to own road), invalid (no adjacent road), invalid (adjacent to other player's road only)
- Test main-game road: valid (connects to own road), valid (connects to own settlement), invalid (no connection)
- Test city upgrade: valid (own settlement), invalid (other player's settlement), invalid (already a city)
  </action>
  <verify>
  Run `cd apps/api && npx vitest run placement-validator.spec.ts` - all tests pass.
  </verify>
  <done>
  6 new validation functions exported.
  All main-game placement rules implemented.
  Tests cover valid and invalid cases for each building type.
  </done>
  </task>

</tasks>

<verification>
1. `npx nx build shared` compiles successfully
2. `cd apps/api && npx vitest run placement-validator.spec.ts` passes
3. BUILDING_COSTS exports with correct values (grep or import test)
4. All 7 new message schemas exist in WebSocketMessageSchema
</verification>

<success_criteria>

- Building costs defined: road (1W 1B), settlement (1W 1B 1S 1Wh), city (3O 2Wh)
- Message schemas defined for all build request/response types
- Main-game validators correctly enforce: roads connect to own network, settlements 2 away AND adjacent to own road, cities upgrade own settlements only
- All new validators have passing test cases
  </success_criteria>

<output>
After completion, create `.planning/phases/05-building/05-01-SUMMARY.md`
</output>
