---
phase: 05-building
plan: 04
type: execute
wave: 3
depends_on: ['05-03']
files_modified:
  - apps/web/src/components/Board/PlacementOverlay.tsx
  - apps/web/src/components/Board/Board.tsx
  - apps/web/src/components/Game.tsx
  - apps/web/src/components/Lobby.tsx
autonomous: true

must_haves:
  truths:
    - 'Valid build locations highlight when entering build mode'
    - 'Clicking valid location in build mode sends WebSocket message'
    - 'Successful build updates local state and shows toast notification'
    - 'Failed build shows error toast and reverts optimistic update'
    - 'Other players see builds appear in real-time'
  artifacts:
    - path: 'apps/web/src/components/Board/PlacementOverlay.tsx'
      provides: 'Build mode location highlighting'
      contains: 'buildMode'
    - path: 'apps/web/src/components/Lobby.tsx'
      provides: 'Build message handlers'
      contains: 'road_built'
    - path: 'apps/web/src/components/Game.tsx'
      provides: 'BuildControls integration'
      contains: 'BuildControls'
  key_links:
    - from: 'apps/web/src/components/Board/PlacementOverlay.tsx'
      to: 'apps/web/src/stores/gameStore.ts'
      via: 'useBuildMode hook and sendMessage'
      pattern: 'build_road|build_settlement|build_city'
    - from: 'apps/web/src/components/Lobby.tsx'
      to: 'apps/web/src/stores/gameStore.ts'
      via: 'addSettlement, addRoad handlers'
      pattern: 'road_built|settlement_built|city_built'
---

<objective>
Integrate build mode with board overlay and wire up WebSocket message handlers.

Purpose: Complete the build flow from UI interaction to server validation to state sync.
Output: Working build system with real-time updates and feedback.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-building/05-CONTEXT.md
@.planning/phases/05-building/05-03-SUMMARY.md

@apps/web/src/components/Board/PlacementOverlay.tsx
@apps/web/src/components/Board/Board.tsx
@apps/web/src/components/Game.tsx
@apps/web/src/components/Lobby.tsx
@apps/web/src/stores/gameStore.ts
@apps/web/src/hooks/useBuildMode.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update PlacementOverlay for build mode</name>
  <files>
    apps/web/src/components/Board/PlacementOverlay.tsx
    apps/web/src/components/Board/Board.tsx
  </files>
  <action>
Update PlacementOverlay.tsx to support both placement phase (existing) and build mode (new):

1. Add build mode detection:

```typescript
const buildMode = useBuildMode();
const { validVertexIds, validEdgeIds } = useValidBuildLocations(buildMode);
const sendMessage = useSocket();
const setBuildMode = useGameStore((state) => state.setBuildMode);
```

2. Modify the overlay logic:

- If placementPhase is set (setup phase), use existing Phase 3 logic
- If buildMode is set (main game), use build mode logic:
  - Show VertexMarkers for validVertexIds when buildMode is 'settlement' or 'city'
  - Show EdgeMarkers for validEdgeIds when buildMode is 'road'

3. Update click handlers:
   For build mode clicks (not placement phase):

```typescript
const handleBuildClick = (locationId: string) => {
  if (!sendMessage || !buildMode) return;

  if (buildMode === 'road') {
    sendMessage({ type: 'build_road', edgeId: locationId });
  } else if (buildMode === 'settlement') {
    sendMessage({ type: 'build_settlement', vertexId: locationId });
  } else if (buildMode === 'city') {
    sendMessage({ type: 'build_city', vertexId: locationId });
  }

  // Exit build mode after sending (single placement per CONTEXT.md)
  setBuildMode(null);
};
```

4. Update VertexMarker/EdgeMarker onClick to use handleBuildClick when in build mode.

5. In Board.tsx, ensure PlacementOverlay renders during both placement phase AND build mode:

```typescript
const showOverlay = placementPhase || buildMode;
// ... render PlacementOverlay when showOverlay is truthy
```

  </action>
  <verify>
Run `npx nx build web` - should compile without errors.
  </verify>
  <done>
PlacementOverlay shows valid locations for build mode.
Clicking location in build mode sends appropriate WebSocket message.
Build mode exits after clicking (single placement).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add WebSocket handlers for build responses</name>
  <files>
    apps/web/src/components/Lobby.tsx
  </files>
  <action>
Add handlers for build response messages in Lobby.tsx (where other gameplay message handlers live):

1. Handle 'road_built':

```typescript
case 'road_built': {
  const { edgeId, playerId, resourcesSpent } = msg;
  addRoad({ edgeId, playerId });

  // Deduct resources from player
  if (resourcesSpent) {
    const resources = Object.entries(resourcesSpent).map(([type, count]) => ({
      type: type as ResourceType,
      count: -count, // Negative to deduct
    }));
    updatePlayerResources(playerId, resources);
  }

  // Show toast for local player
  if (playerId === myPlayerId) {
    notifications.show({ message: 'Road built!', color: 'green' });
  }
  break;
}
```

2. Handle 'settlement_built':

```typescript
case 'settlement_built': {
  const { vertexId, playerId, resourcesSpent } = msg;
  addSettlement({ vertexId, playerId, isCity: false });

  // Deduct resources
  if (resourcesSpent) {
    const resources = Object.entries(resourcesSpent).map(([type, count]) => ({
      type: type as ResourceType,
      count: -count,
    }));
    updatePlayerResources(playerId, resources);
  }

  if (playerId === myPlayerId) {
    notifications.show({ message: 'Settlement built!', color: 'green' });
  }
  break;
}
```

3. Handle 'city_built':

```typescript
case 'city_built': {
  const { vertexId, playerId, resourcesSpent } = msg;
  // Update existing settlement to city
  upgradeToCity(vertexId); // Need to add this action to store

  // Deduct resources
  if (resourcesSpent) {
    const resources = Object.entries(resourcesSpent).map(([type, count]) => ({
      type: type as ResourceType,
      count: -count,
    }));
    updatePlayerResources(playerId, resources);
  }

  if (playerId === myPlayerId) {
    notifications.show({ message: 'City built!', color: 'green' });
  }
  break;
}
```

4. Handle 'build_failed':

```typescript
case 'build_failed': {
  const { reason } = msg;
  notifications.show({
    message: `Build failed: ${reason}`,
    color: 'red'
  });
  break;
}
```

5. Add upgradeToCity action to gameStore.ts:

```typescript
upgradeToCity: (vertexId: string) => set((state) => ({
  settlements: state.settlements.map(s =>
    s.vertexId === vertexId ? { ...s, isCity: true } : s
  ),
})),
```

Import notifications from @mantine/notifications (already added in Phase 4).
</action>
<verify>
Run `npx nx build web` - should compile without errors.
</verify>
<done>
road_built, settlement_built, city_built handlers update local state.
Resources deducted from player on successful build.
Toast notifications show for local player builds.
build_failed shows error notification.
</done>
</task>

<task type="auto">
  <name>Task 3: Integrate BuildControls into Game view</name>
  <files>
    apps/web/src/components/Game.tsx
  </files>
  <action>
Update Game.tsx to show BuildControls during main game phase:

1. Import BuildControls:

```typescript
import { BuildControls } from './BuildControls/BuildControls';
```

2. Position BuildControls near ResourceHand (per CONTEXT.md: "Build buttons should feel integrated with the resource hand area"):

Update the main game phase UI section:

```tsx
{
  /* Main game phase UI (dice roller, turn controls, resource hand, build controls) */
}
{
  isMainGamePhase && (
    <>
      {/* Game controls panel (top-right) */}
      <div
        style={{
          position: 'absolute',
          top: 80,
          right: 16,
          zIndex: 10,
          display: 'flex',
          flexDirection: 'column',
          gap: 16,
        }}
      >
        <TurnControls />
        <DiceRoller />
      </div>

      {/* Resource hand and build controls (bottom center) */}
      <div
        style={{
          position: 'absolute',
          bottom: 24,
          left: '50%',
          transform: 'translateX(-50%)',
          zIndex: 20,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          gap: 12,
        }}
      >
        <BuildControls />
        <ResourceHand />
      </div>
    </>
  );
}
```

BuildControls sits above ResourceHand, creating a cohesive build action area.
</action>
<verify>
Run `npx nx serve web` and `npx nx serve api` - verify BuildControls appears in game view.
</verify>
<done>
BuildControls renders in main game phase.
Positioned above ResourceHand in bottom-center area.
Build mode integrates with PlacementOverlay for location highlighting.
</done>
</task>

</tasks>

<verification>
1. `npx nx build web` compiles successfully
2. `npx nx build api` compiles successfully
3. Start both servers and test:
   - Complete setup phase to reach main game
   - Roll dice to enter main phase
   - Click Road button, see valid edges highlighted
   - Click valid edge, verify road appears and resources deducted
   - Repeat for Settlement and City
</verification>

<success_criteria>

- Valid locations highlight when entering build mode
- Clicking valid location sends build request to server
- Successful builds update board and deduct resources
- Toast notifications confirm successful builds
- Failed builds show error toast
- Build mode exits after placing (single placement per click)
- Other players see builds appear in real-time
  </success_criteria>

<output>
After completion, create `.planning/phases/05-building/05-04-SUMMARY.md`
</output>
