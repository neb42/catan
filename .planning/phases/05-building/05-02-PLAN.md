---
phase: 05-building
plan: 02
type: execute
wave: 2
depends_on: ['05-01']
files_modified:
  - apps/api/src/game/GameManager.ts
  - apps/api/src/handlers/websocket.ts
autonomous: true

must_haves:
  truths:
    - 'GameManager can build roads, settlements, and cities with resource validation'
    - 'GameManager prevents building without sufficient resources'
    - 'GameManager prevents building with invalid placement'
    - 'WebSocket handlers process build requests and broadcast results to all players'
  artifacts:
    - path: 'apps/api/src/game/GameManager.ts'
      provides: 'Build methods for roads, settlements, cities'
      exports:
        [
          'buildRoad',
          'buildSettlement',
          'buildCity',
          'hasResources',
          'deductResources',
        ]
    - path: 'apps/api/src/handlers/websocket.ts'
      provides: 'Build message handlers'
      contains: 'build_road'
  key_links:
    - from: 'apps/api/src/handlers/websocket.ts'
      to: 'apps/api/src/game/GameManager.ts'
      via: 'gameManager.buildRoad()'
      pattern: 'buildRoad|buildSettlement|buildCity'
    - from: 'apps/api/src/game/GameManager.ts'
      to: 'libs/shared/src/constants/index.ts'
      via: 'BUILDING_COSTS import'
      pattern: 'BUILDING_COSTS'
---

<objective>
Implement GameManager build methods and WebSocket handlers for the building system.

Purpose: Enable the backend to process build requests, validate resources and placement, and broadcast results.
Output: Working server-side building logic with real-time sync to all clients.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-building/05-CONTEXT.md
@.planning/phases/05-building/05-01-SUMMARY.md

@apps/api/src/game/GameManager.ts
@apps/api/src/handlers/websocket.ts
@libs/shared/src/constants/index.ts
@apps/api/src/game/placement-validator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add build methods to GameManager</name>
  <files>
    apps/api/src/game/GameManager.ts
  </files>
  <action>
Import BUILDING_COSTS, MAX_PIECES from @catan/shared.
Import new validators: isValidMainGameSettlement, isValidMainGameRoad, isValidCityUpgrade, and their reason getters.

Add helper methods:

1. `hasResources(playerId: string, cost: Record<ResourceType, number>): boolean`
   - Check if player has >= each resource in cost
   - Return false if any resource insufficient

2. `deductResources(playerId: string, cost: Record<ResourceType, number>): void`
   - Subtract each resource from player's resources
   - Assumes hasResources already checked

3. `countPlayerPieces(playerId: string): { roads: number, settlements: number, cities: number }`
   - Count roads/settlements/cities owned by player from gameState

Add build methods:

4. `buildRoad(edgeId: string, playerId: string): { success: boolean, error?: string }`
   - Validate it's player's turn and phase is 'main'
   - Validate piece limit (roads < 15)
   - Validate resources (hasResources with BUILDING_COSTS.road)
   - Validate placement (isValidMainGameRoad)
   - If all valid: deduct resources, add road to gameState.roads
   - Return success or error reason

5. `buildSettlement(vertexId: string, playerId: string): { success: boolean, error?: string }`
   - Validate it's player's turn and phase is 'main'
   - Validate piece limit (settlements < 5)
   - Validate resources (hasResources with BUILDING_COSTS.settlement)
   - Validate placement (isValidMainGameSettlement)
   - If all valid: deduct resources, add settlement to gameState.settlements
   - Return success or error reason

6. `buildCity(vertexId: string, playerId: string): { success: boolean, error?: string }`
   - Validate it's player's turn and phase is 'main'
   - Validate piece limit (cities < 4)
   - Validate resources (hasResources with BUILDING_COSTS.city)
   - Validate placement (isValidCityUpgrade)
   - If all valid: deduct resources, update settlement.isCity = true
   - NOTE: Cities don't add to settlements array, they upgrade existing settlement
   - Return success or error reason

All build methods should return the spent resources for client animation: add `resourcesSpent?: Record<string, number>` to success response.
</action>
<verify>
Run `npx nx build api` - should compile without errors.
</verify>
<done>
GameManager has hasResources, deductResources, countPlayerPieces helpers.
GameManager has buildRoad, buildSettlement, buildCity methods.
All methods validate turn, phase, piece limits, resources, and placement.
Successful builds deduct resources and update game state.
</done>
</task>

<task type="auto">
  <name>Task 2: Add WebSocket handlers for build messages</name>
  <files>
    apps/api/src/handlers/websocket.ts
  </files>
  <action>
Add handlers for the three build message types:

1. Handle 'build_road':
   - Get gameManager from room
   - Call gameManager.buildRoad(message.edgeId, playerId)
   - On success: broadcast 'road_built' to all players in room with { edgeId, playerId, resourcesSpent }
   - On failure: send 'build_failed' to requester with { reason }

2. Handle 'build_settlement':
   - Call gameManager.buildSettlement(message.vertexId, playerId)
   - On success: broadcast 'settlement_built' to all players
   - On failure: send 'build_failed' to requester

3. Handle 'build_city':
   - Call gameManager.buildCity(message.vertexId, playerId)
   - On success: broadcast 'city_built' to all players
   - On failure: send 'build_failed' to requester

Follow existing handler patterns in websocket.ts (use room.getGameManager(), broadcast to room, etc.).

Ensure all broadcasts include the playerId so clients know whose resources changed.
</action>
<verify>
Run `npx nx build api` - should compile without errors.
Manual test: Start API server, connect via WebSocket, send build messages after game setup.
</verify>
<done>
WebSocket handlers exist for build_road, build_settlement, build_city.
Successful builds broadcast to all players.
Failed builds return error to requester.
</done>
</task>

</tasks>

<verification>
1. `npx nx build api` compiles successfully
2. GameManager.buildRoad/buildSettlement/buildCity exist and are callable
3. WebSocket handlers for all three build types are wired up
4. Build success broadcasts include playerId and resourcesSpent
</verification>

<success_criteria>

- GameManager validates resources before building (cannot build without enough)
- GameManager validates placement rules (roads connect, settlements 2 away + adjacent, cities on own settlements)
- GameManager enforces piece limits (15 roads, 5 settlements, 4 cities)
- WebSocket handlers process build requests and broadcast results
- Failed builds return clear error reason
  </success_criteria>

<output>
After completion, create `.planning/phases/05-building/05-02-SUMMARY.md`
</output>
