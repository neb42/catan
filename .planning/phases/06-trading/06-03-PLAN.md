---
phase: 06-trading
plan: 03
type: execute
wave: 2
depends_on: ['06-01']
files_modified:
  - apps/api/src/handlers/websocket.ts
autonomous: true

must_haves:
  truths:
    - 'Server handles propose_trade message and broadcasts trade_proposed'
    - 'Server handles respond_trade message and broadcasts trade_response'
    - 'Server handles select_trade_partner and broadcasts trade_executed'
    - 'Server handles cancel_trade and broadcasts trade_cancelled'
    - 'Server handles execute_bank_trade and broadcasts bank_trade_executed'
  artifacts:
    - path: 'apps/api/src/handlers/websocket.ts'
      provides: 'Trade message handlers'
      contains: 'propose_trade'
  key_links:
    - from: 'apps/api/src/handlers/websocket.ts'
      to: 'apps/api/src/game/GameManager.ts'
      via: 'gameManager.proposeTrade'
      pattern: "gameManager\\.proposeTrade"
---

<objective>
Add WebSocket message handlers for all trade operations to the server.

Purpose: Enable real-time trade communication between clients via the server.
Output: Complete WebSocket handling for domestic and maritime trading.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-trading/06-RESEARCH.md
@.planning/phases/06-trading/06-01-SUMMARY.md

@apps/api/src/handlers/websocket.ts
@apps/api/src/game/GameManager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add domestic trade message handlers</name>
  <files>apps/api/src/handlers/websocket.ts</files>
  <action>
Add case handlers for domestic trade messages in the WebSocket switch statement. Follow the existing pattern (validate room/player, get gameManager, call method, broadcast result).

**Add case 'propose_trade':**

```typescript
case 'propose_trade': {
  if (!currentRoomId || !playerId) {
    sendError(ws, 'Room not found');
    return;
  }
  const gameManager = roomManager.getGameManager(currentRoomId);
  if (!gameManager) {
    sendError(ws, 'Game not started');
    return;
  }

  const result = gameManager.proposeTrade(playerId, message.offering, message.requesting);
  if (!result.success) {
    sendError(ws, result.error || 'Invalid trade proposal');
    return;
  }

  roomManager.broadcastToRoom(currentRoomId, {
    type: 'trade_proposed',
    proposerId: playerId,
    offering: message.offering,
    requesting: message.requesting,
  });
  break;
}
```

**Add case 'respond_trade':**

- Call gameManager.respondToTrade(playerId, response)
- Broadcast trade_response to all players
- Include playerId and response ('accepted' or 'declined')

**Add case 'select_trade_partner':**

- Call gameManager.selectTradePartner(message.partnerId)
- On success, broadcast trade_executed with proposerId, partnerId, proposerGave, partnerGave
- On failure, sendError

**Add case 'cancel_trade':**

- Call gameManager.cancelTrade()
- Broadcast trade_cancelled to all players
  </action>
  <verify>Run `npx nx build api` to verify no TypeScript errors</verify>
  <done>All 4 domestic trade message handlers implemented</done>
  </task>

<task type="auto">
  <name>Task 2: Add maritime trade message handler</name>
  <files>apps/api/src/handlers/websocket.ts</files>
  <action>
Add case handler for bank/port trading:

**Add case 'execute_bank_trade':**

```typescript
case 'execute_bank_trade': {
  if (!currentRoomId || !playerId) {
    sendError(ws, 'Room not found');
    return;
  }
  const gameManager = roomManager.getGameManager(currentRoomId);
  if (!gameManager) {
    sendError(ws, 'Game not started');
    return;
  }

  const result = gameManager.executeBankTrade(playerId, message.giving, message.receiving);
  if (!result.success) {
    sendError(ws, result.error || 'Invalid bank trade');
    return;
  }

  roomManager.broadcastToRoom(currentRoomId, {
    type: 'bank_trade_executed',
    playerId,
    gave: result.gave,
    received: result.received,
  });
  break;
}
```

This handler:

1. Validates game is started
2. Calls GameManager.executeBankTrade which handles port access and rate calculation
3. Broadcasts result to all players so everyone sees resource changes
   </action>
   <verify>Run `npx nx build api` to verify no TypeScript errors</verify>
   <done>Bank trade handler implemented and broadcasting correctly</done>
   </task>

</tasks>

<verification>
1. `npx nx build api` completes without errors
2. All 5 trade message types handled in switch statement
3. Each handler follows existing pattern: validate -> call GameManager -> broadcast
4. Error cases send appropriate error messages to client
</verification>

<success_criteria>

- propose_trade broadcasts trade_proposed to all players
- respond_trade broadcasts trade_response to all players
- select_trade_partner broadcasts trade_executed with resource details
- cancel_trade broadcasts trade_cancelled
- execute_bank_trade broadcasts bank_trade_executed
- All handlers validate room, player, and game state before proceeding
  </success_criteria>

<output>
After completion, create `.planning/phases/06-trading/06-03-SUMMARY.md`
</output>
