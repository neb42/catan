---
phase: 06-trading
plan: 06
type: execute
wave: 3
depends_on: ['06-04']
files_modified:
  - apps/web/src/components/Trade/TradeResponseModal.tsx
  - apps/web/src/components/Trade/TradeProposerView.tsx
  - apps/web/src/components/Lobby.tsx
autonomous: true

must_haves:
  truths:
    - 'Non-proposers see blocking modal requiring Accept/Decline response'
    - 'Proposer sees real-time responses from other players'
    - 'Proposer can select partner when someone accepts'
    - 'Trade state updates in real-time via WebSocket'
  artifacts:
    - path: 'apps/web/src/components/Trade/TradeResponseModal.tsx'
      provides: 'Blocking modal for trade recipients'
      min_lines: 60
    - path: 'apps/web/src/components/Trade/TradeProposerView.tsx'
      provides: 'Proposer view with response tracking'
      min_lines: 50
    - path: 'apps/web/src/components/Lobby.tsx'
      provides: 'WebSocket handlers for trade messages'
      contains: 'trade_proposed'
  key_links:
    - from: 'apps/web/src/components/Lobby.tsx'
      to: 'apps/web/src/stores/gameStore.ts'
      via: 'setActiveTrade'
      pattern: 'setActiveTrade'
    - from: 'apps/web/src/components/Trade/TradeResponseModal.tsx'
      to: 'apps/web/src/hooks/useTradeState.ts'
      via: 'useNeedsToRespondToTrade'
      pattern: 'useNeedsToRespondToTrade'
---

<objective>
Create trade response UI and integrate WebSocket message handling for real-time trade coordination.

Purpose: Enable players to respond to trade offers and complete the trade flow with real-time updates.
Output: Complete trade response system with blocking modals and WebSocket integration.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-trading/06-RESEARCH.md
@.planning/phases/06-trading/06-04-SUMMARY.md

@apps/web/src/components/Lobby.tsx
@apps/web/src/hooks/useTradeState.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TradeResponseModal component</name>
  <files>apps/web/src/components/Trade/TradeResponseModal.tsx</files>
  <action>
Create `apps/web/src/components/Trade/TradeResponseModal.tsx` - a blocking modal for trade recipients:

```typescript
import { Modal, Button, Group, Stack, Text, Paper } from '@mantine/core';
import { ResourceType } from '@catan/shared';
import { useActiveTrade, useNeedsToRespondToTrade } from '../../hooks/useTradeState';
import { useSocket, useGameStore } from '../../stores/gameStore';

const RESOURCE_ICONS: Record<ResourceType, string> = {
  wood: 'ü™µ', brick: 'üß±', sheep: 'üêë', wheat: 'üåæ', ore: '‚õ∞Ô∏è',
};

function ResourceDisplay({ resources, label }: { resources: Record<ResourceType, number>; label: string }) {
  const nonZero = Object.entries(resources).filter(([_, count]) => count > 0);
  if (nonZero.length === 0) return null;

  return (
    <Paper p="sm" withBorder>
      <Text size="sm" fw={600} mb="xs">{label}</Text>
      <Group gap="xs">
        {nonZero.map(([resource, count]) => (
          <Text key={resource}>
            {count}x {RESOURCE_ICONS[resource as ResourceType]}
          </Text>
        ))}
      </Group>
    </Paper>
  );
}

export function TradeResponseModal() {
  const activeTrade = useActiveTrade();
  const needsToRespond = useNeedsToRespondToTrade();
  const sendMessage = useSocket();
  const room = useGameStore((state) => state.room);

  // Find proposer name
  const proposerName = room?.players.find(p => p.id === activeTrade?.proposerId)?.nickname || 'Unknown';

  if (!needsToRespond || !activeTrade) return null;

  const handleAccept = () => {
    sendMessage?.({ type: 'respond_trade', response: 'accept' });
  };

  const handleDecline = () => {
    sendMessage?.({ type: 'respond_trade', response: 'decline' });
  };

  return (
    <Modal
      opened={true}
      onClose={() => {}} // No-op - cannot close without responding
      closeOnClickOutside={false}
      closeOnEscape={false}
      withCloseButton={false}
      title={`Trade Offer from ${proposerName}`}
      centered
    >
      <Stack gap="md">
        <Text size="sm">
          {proposerName} wants to trade with you:
        </Text>

        <ResourceDisplay resources={activeTrade.offering} label="They offer:" />
        <ResourceDisplay resources={activeTrade.requesting} label="They want:" />

        <Group justify="center" mt="lg">
          <Button color="green" onClick={handleAccept}>
            Accept
          </Button>
          <Button color="red" variant="outline" onClick={handleDecline}>
            Decline
          </Button>
        </Group>
      </Stack>
    </Modal>
  );
}
```

Key features:

- `closeOnClickOutside={false}` and `closeOnEscape={false}` make it blocking
- `withCloseButton={false}` removes the X button
- Shows what proposer offers and requests
- Accept/Decline buttons send WebSocket response
  </action>
  <verify>Run `npx nx build web` to verify no TypeScript errors</verify>
  <done>TradeResponseModal is blocking and sends responses</done>
  </task>

<task type="auto">
  <name>Task 2: Create TradeProposerView component</name>
  <files>apps/web/src/components/Trade/TradeProposerView.tsx</files>
  <action>
Create `apps/web/src/components/Trade/TradeProposerView.tsx` - shows proposer the real-time responses:

```typescript
import { Button, Group, Paper, Stack, Text, Badge } from '@mantine/core';
import { useActiveTrade, useAcceptedTraders, useTradeActions } from '../../hooks/useTradeState';
import { useSocket, useGameStore } from '../../stores/gameStore';

export function TradeProposerView() {
  const activeTrade = useActiveTrade();
  const acceptedTraders = useAcceptedTraders();
  const { clearTrade } = useTradeActions();
  const sendMessage = useSocket();
  const room = useGameStore((state) => state.room);
  const myPlayerId = useGameStore((state) => state.myPlayerId);

  // Only show to proposer when there's an active trade they proposed
  if (!activeTrade || activeTrade.proposerId !== myPlayerId) return null;

  const handleCancel = () => {
    sendMessage?.({ type: 'cancel_trade' });
  };

  const handleSelectPartner = (partnerId: string) => {
    sendMessage?.({ type: 'select_trade_partner', partnerId });
  };

  // Get all non-proposer players with their response status
  const otherPlayers = room?.players
    .filter(p => p.id !== activeTrade.proposerId)
    .map(p => ({
      ...p,
      response: activeTrade.responses[p.id] || 'pending',
    })) || [];

  return (
    <Paper p="md" withBorder>
      <Stack gap="sm">
        <Text fw={600}>Trade Proposal Active</Text>
        <Text size="sm" c="dimmed">Waiting for responses...</Text>

        {/* Response status for each player */}
        <Stack gap="xs">
          {otherPlayers.map(player => (
            <Group key={player.id} justify="space-between">
              <Text size="sm">{player.nickname}</Text>
              {player.response === 'pending' && (
                <Badge color="gray">Pending</Badge>
              )}
              {player.response === 'accepted' && (
                <Group gap="xs">
                  <Badge color="green">Accepted</Badge>
                  <Button size="xs" onClick={() => handleSelectPartner(player.id)}>
                    Trade with {player.nickname}
                  </Button>
                </Group>
              )}
              {player.response === 'declined' && (
                <Badge color="red">Declined</Badge>
              )}
            </Group>
          ))}
        </Stack>

        <Button color="red" variant="outline" onClick={handleCancel}>
          Cancel Trade
        </Button>
      </Stack>
    </Paper>
  );
}
```

This component:

- Shows real-time response status from all players
- Provides "Trade with X" button for each accepting player
- Allows canceling the trade at any time
  </action>
  <verify>Run `npx nx build web` to verify no TypeScript errors</verify>
  <done>TradeProposerView shows responses and allows partner selection</done>
  </task>

<task type="auto">
  <name>Task 3: Add WebSocket handlers for trade messages in Lobby.tsx</name>
  <files>apps/web/src/components/Lobby.tsx</files>
  <action>
Add WebSocket message handlers for trade events in the Lobby.tsx message handler switch statement.

Find the existing WebSocket message handler (look for `ws.onmessage` or message handling logic) and add cases for:

**case 'trade_proposed':**

```typescript
case 'trade_proposed': {
  const { proposerId, offering, requesting } = msg;
  // Initialize all non-proposer players with 'pending' response
  const responses: Record<string, 'pending' | 'accepted' | 'declined'> = {};
  room?.players.forEach(p => {
    if (p.id !== proposerId) {
      responses[p.id] = 'pending';
    }
  });
  setActiveTrade({ proposerId, offering, requesting, responses });
  break;
}
```

**case 'trade_response':**

```typescript
case 'trade_response': {
  const { playerId, response } = msg;
  updateTradeResponse(playerId, response);
  break;
}
```

**case 'trade_executed':**

```typescript
case 'trade_executed': {
  const { proposerId, partnerId, proposerGave, partnerGave } = msg;
  // Update resources for both players
  // proposer: -proposerGave, +partnerGave
  // partner: -partnerGave, +proposerGave
  updatePlayerResourcesNegative(proposerId, proposerGave);
  updatePlayerResources(proposerId, partnerGave);
  updatePlayerResourcesNegative(partnerId, partnerGave);
  updatePlayerResources(partnerId, proposerGave);
  clearTrade();
  setTradeModalOpen(false);
  notifications.show({ message: 'Trade completed!', color: 'green' });
  break;
}
```

**case 'trade_cancelled':**

```typescript
case 'trade_cancelled': {
  clearTrade();
  setTradeModalOpen(false);
  break;
}
```

**case 'bank_trade_executed':**

```typescript
case 'bank_trade_executed': {
  const { playerId, gave, received } = msg;
  updatePlayerResourcesNegative(playerId, gave);
  updatePlayerResources(playerId, received);
  if (playerId === myPlayerId) {
    notifications.show({ message: 'Bank trade complete!', color: 'blue' });
  }
  break;
}
```

**Also add:** Helper function to subtract resources:

```typescript
const updatePlayerResourcesNegative = (
  playerId: string,
  resources: Record<ResourceType, number>,
) => {
  // Convert to negative counts and call existing updatePlayerResources
  const negativeResources = Object.entries(resources)
    .filter(([_, count]) => count > 0)
    .map(([type, count]) => ({ type: type as ResourceType, count: -count }));
  // Use existing pattern from resource distribution
};
```

Import notifications from @mantine/notifications. Import trade actions from useTradeState.
</action>
<verify>Run `npx nx build web` to verify no TypeScript errors</verify>
<done>All trade WebSocket handlers integrated into Lobby.tsx</done>
</task>

</tasks>

<verification>
1. `npx nx build web` completes without errors
2. TradeResponseModal appears for non-proposers when trade proposed
3. TradeResponseModal is truly blocking (can't dismiss without action)
4. TradeProposerView shows real-time responses
5. Partner selection triggers trade execution
6. Resources update correctly for both players after trade
7. Trade state clears after completion/cancellation
</verification>

<success_criteria>

- trade_proposed creates blocking modal for recipients
- Recipients can only Accept or Decline
- Proposer sees real-time response updates
- Proposer can select from accepting players
- Trade execution updates both players' resources
- Trade cancellation clears all trade state
- Bank trade updates player resources correctly
- Notifications shown on trade completion
  </success_criteria>

<output>
After completion, create `.planning/phases/06-trading/06-06-SUMMARY.md`
</output>
