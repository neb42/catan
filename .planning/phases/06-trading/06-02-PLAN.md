---
phase: 06-trading
plan: 02
type: execute
wave: 2
depends_on: ['06-01']
files_modified:
  - apps/api/src/game/trade-validator.ts
  - apps/api/src/game/port-access.ts
  - apps/api/src/game/GameManager.ts
autonomous: true

must_haves:
  truths:
    - 'GameManager can propose, respond to, and execute domestic trades'
    - 'GameManager can execute bank trades with correct rate calculation'
    - 'Port access is calculated from player settlement positions'
    - 'Trade validation rejects invalid trades with clear error messages'
  artifacts:
    - path: 'apps/api/src/game/trade-validator.ts'
      provides: 'Trade validation functions'
      exports: ['validateProposeTrade', 'validateBankTrade']
    - path: 'apps/api/src/game/port-access.ts'
      provides: 'Port access calculation'
      exports: ['getPlayerPortAccess', 'getBestTradeRate']
    - path: 'apps/api/src/game/GameManager.ts'
      provides: 'Trade methods on GameManager'
      contains: 'proposeTrade'
  key_links:
    - from: 'apps/api/src/game/GameManager.ts'
      to: 'apps/api/src/game/trade-validator.ts'
      via: 'import'
      pattern: 'import.*trade-validator'
    - from: 'apps/api/src/game/GameManager.ts'
      to: 'apps/api/src/game/port-access.ts'
      via: 'import'
      pattern: 'import.*port-access'
---

<objective>
Implement backend trade logic including validation, port access calculation, and GameManager trade methods.

Purpose: Enable the server to manage trade proposals, track responses, execute trades, and handle maritime trading with correct port rates.
Output: Complete backend trade system ready for WebSocket handler integration.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-trading/06-RESEARCH.md
@.planning/phases/06-trading/06-01-SUMMARY.md

@apps/api/src/game/GameManager.ts
@libs/shared/src/schemas/board.ts
@libs/shared/src/utils/hexGeometry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create port access calculation module</name>
  <files>apps/api/src/game/port-access.ts</files>
  <action>
Create a new file `apps/api/src/game/port-access.ts` that calculates which ports a player has access to based on their settlements/cities.

**Implementation:**

1. Create `PortAccess` interface:

```typescript
interface PortAccess {
  hasGeneric3to1: boolean;
  specificPorts: ResourceType[]; // 2:1 ports player has access to
}
```

2. Create `getPortVertexIds(hexQ, hexR, edge, hexes)` function:
   - Port is on edge of a hex (edge 0-5)
   - Edge connects two adjacent vertices (corners i and i+1)
   - Use existing `getVertexFromCorner` pattern from hexGeometry.ts
   - Return the two vertex IDs that touch this port

3. Create `getPlayerPortAccess(playerId, settlements, board)` function:
   - Get all settlements/cities owned by player
   - For each port in board.ports, check if player has settlement on either vertex
   - Build and return PortAccess object

4. Create `getBestTradeRate(resource, portAccess)` function:
   - If resource in specificPorts: return 2
   - If hasGeneric3to1: return 3
   - Otherwise: return 4

**Key insight:** Vertex IDs use the format from hexGeometry.ts (rounded coordinates like "8.7,5"). Match port vertices to settlement vertexIds exactly.
</action>
<verify>Run `npx nx build api` to verify no TypeScript errors</verify>
<done>Port access module exports getPlayerPortAccess and getBestTradeRate functions</done>
</task>

<task type="auto">
  <name>Task 2: Create trade validation module</name>
  <files>apps/api/src/game/trade-validator.ts</files>
  <action>
Create `apps/api/src/game/trade-validator.ts` with validation functions for trade proposals:

**Functions to implement:**

1. `validateProposeTrade(proposerId, offering, requesting, playerResources, currentPlayerId)`:
   - Check proposer is current turn player
   - Check offering has at least one resource (sum > 0)
   - Check requesting has at least one resource (sum > 0)
   - Check proposer has enough resources for offering
   - Return `{ valid: true }` or `{ valid: false, error: string }`

2. `validateTradeResponse(responderId, proposerId, responses)`:
   - Check responder is not the proposer
   - Check responder hasn't already responded
   - Return `{ valid: true }` or `{ valid: false, error: string }`

3. `validatePartnerSelection(proposerId, partnerId, responses, partnerResources, requesting)`:
   - Check partner has accepted (responses[partnerId] === 'accepted')
   - Check partner has enough resources for what proposer is requesting
   - Return `{ valid: true }` or `{ valid: false, error: string }`

4. `validateBankTrade(playerId, giving, receiving, playerResources, portAccess)`:
   - Check only one resource type being given
   - Check only one resource type being received
   - Calculate rate using getBestTradeRate
   - Check amounts match rate (giving.amount === rate \* receiving.amount)
   - Check player has enough resources
   - Return `{ valid: true }` or `{ valid: false, error: string }`

Use `ResourceType` from shared types. Import `getBestTradeRate` from port-access.ts.
</action>
<verify>Run `npx nx build api` to verify no TypeScript errors</verify>
<done>Trade validation module exports all validation functions</done>
</task>

<task type="auto">
  <name>Task 3: Add trade methods to GameManager</name>
  <files>apps/api/src/game/GameManager.ts</files>
  <action>
Add trade management to GameManager class:

**New private state:**

```typescript
private activeTrade: ActiveTrade | null = null;
```

**New public methods:**

1. `proposeTrade(proposerId, offering, requesting)`:
   - Validate using validateProposeTrade
   - Set activeTrade with proposerId, offering, requesting
   - Initialize responses as empty object (will be filled as players respond)
   - Return `{ success: true }` or `{ success: false, error: string }`

2. `respondToTrade(responderId, response)`:
   - Check activeTrade exists
   - Validate using validateTradeResponse
   - Update activeTrade.responses[responderId] = response
   - Return `{ success: true, allResponded: boolean }` (allResponded = all non-proposer players have responded)

3. `selectTradePartner(partnerId)`:
   - Check activeTrade exists
   - Validate using validatePartnerSelection
   - Execute trade: deduct offering from proposer, add requesting to proposer; vice versa for partner
   - Clear activeTrade
   - Return `{ success: true, proposerGave, partnerGave }` or `{ success: false, error }`

4. `cancelTrade()`:
   - Clear activeTrade
   - Return `{ success: true }`

5. `executeBankTrade(playerId, giving, receiving)`:
   - Calculate port access for player using getPlayerPortAccess
   - Validate using validateBankTrade
   - Execute trade: deduct giving from player, add receiving to player
   - Return `{ success: true, gave, received }` or `{ success: false, error }`

6. `getActiveTrade()`: Returns activeTrade

7. `hasResources(playerId, resources)`: Helper to check if player has enough resources (already may exist, add if not)

**Also add:** In endTurn/advanceTurn logic, clear activeTrade if exists (auto-cancel on turn end).

Import from trade-validator.ts and port-access.ts.
</action>
<verify>Run `npx nx build api` to verify no TypeScript errors</verify>
<done>GameManager has all trade methods implemented and working</done>
</task>

</tasks>

<verification>
1. `npx nx build api` completes without errors
2. Port access calculation correctly identifies which ports a player can use
3. Trade validation rejects invalid proposals with clear errors
4. GameManager trade methods handle full trade lifecycle
</verification>

<success_criteria>

- Port access calculates 2:1, 3:1, and 4:1 rates correctly
- Trade proposal validation prevents invalid trades (empty offers, insufficient resources)
- Trade response tracking works for multiple players
- Partner selection validates acceptance and resources
- Bank trade validates rate and resources
- Active trade is cleared on turn end
  </success_criteria>

<output>
After completion, create `.planning/phases/06-trading/06-02-SUMMARY.md`
</output>
