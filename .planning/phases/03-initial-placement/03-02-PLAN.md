---
phase: 03-initial-placement
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - libs/shared/src/utils/snakeDraft.ts
  - libs/shared/src/utils/snakeDraft.spec.ts
  - libs/shared/src/schemas/messages.ts
  - libs/shared/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Snake draft order calculated correctly (1-2-3-4-4-3-2-1)"
    - "Turn number maps to correct player index and phase"
    - "WebSocket messages defined for placement actions"
  artifacts:
    - path: "libs/shared/src/utils/snakeDraft.ts"
      provides: "Snake draft turn order calculation"
      exports: ["DraftPosition", "calculateDraftPosition", "getNextDraftPosition", "isSetupComplete"]
    - path: "libs/shared/src/schemas/messages.ts"
      provides: "Placement-related WebSocket message schemas"
      contains: "PlaceSettlementMessageSchema"
  key_links:
    - from: "libs/shared/src/utils/snakeDraft.ts"
      to: "libs/shared/src/schemas/game.ts"
      via: "DraftPosition matches PlacementState structure"
      pattern: "DraftPosition"
---

<objective>
Implement snake draft turn order calculation and add placement WebSocket message schemas.

Purpose: Enable tracking of which player should place next and what they should place (settlement or road), plus define message contracts for client-server placement communication.

Output: snakeDraft.ts utilities with comprehensive tests, updated messages.ts with placement schemas.
</objective>

<execution_context>
@/Users/bmcalindin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-initial-placement/03-CONTEXT.md
@.planning/phases/03-initial-placement/03-RESEARCH.md
@libs/shared/src/schemas/messages.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create snake draft utilities</name>
  <files>libs/shared/src/utils/snakeDraft.ts, libs/shared/src/utils/snakeDraft.spec.ts</files>
  <action>
Create `libs/shared/src/utils/snakeDraft.ts`:

1. **DraftPosition interface:**
```typescript
export interface DraftPosition {
  round: 1 | 2;           // Round 1: forward (1-4), Round 2: reverse (4-1)
  playerIndex: number;    // 0-based index in player array
  phase: 'settlement' | 'road';  // What to place
}
```

2. **calculateDraftPosition(turnNumber, playerCount):**
   - turnNumber: 0-based (0-15 for 4 players, 0-11 for 3 players)
   - playerCount: 3 or 4
   - Returns DraftPosition

   Logic for 4 players:
   - Turns 0-7 are Round 1 (forward): players 0,0,1,1,2,2,3,3 (each does settlement then road)
   - Turns 8-15 are Round 2 (reverse): players 3,3,2,2,1,1,0,0

   General formula:
   - positionsPerRound = playerCount * 2
   - Round 1 (turnNumber < positionsPerRound):
     - playerIndex = Math.floor(turnNumber / 2)
     - phase = turnNumber % 2 === 0 ? 'settlement' : 'road'
   - Round 2 (turnNumber >= positionsPerRound):
     - roundTwoTurn = turnNumber - positionsPerRound
     - playerIndex = playerCount - 1 - Math.floor(roundTwoTurn / 2)
     - phase = roundTwoTurn % 2 === 0 ? 'settlement' : 'road'

3. **getNextDraftPosition(current, playerCount):**
   - Returns next DraftPosition or null if setup complete
   - If phase is 'settlement', return same player with 'road'
   - If phase is 'road':
     - Round 1: next player (+1) or start Round 2 at last player
     - Round 2: previous player (-1) or null if playerIndex reaches 0

4. **isSetupComplete(turnNumber, playerCount):**
   - Returns true if turnNumber >= playerCount * 4 (each player places 2 settlements + 2 roads)

5. **getTotalSetupTurns(playerCount):**
   - Returns playerCount * 4

Create test file `snakeDraft.spec.ts` with comprehensive tests:

```typescript
describe('calculateDraftPosition', () => {
  describe('4 players', () => {
    // Round 1: Forward order (1→2→3→4)
    it('turn 0: player 0, settlement', () => {
      expect(calculateDraftPosition(0, 4)).toEqual({ round: 1, playerIndex: 0, phase: 'settlement' });
    });
    it('turn 1: player 0, road', () => {
      expect(calculateDraftPosition(1, 4)).toEqual({ round: 1, playerIndex: 0, phase: 'road' });
    });
    it('turn 6: player 3, settlement', () => {
      expect(calculateDraftPosition(6, 4)).toEqual({ round: 1, playerIndex: 3, phase: 'settlement' });
    });
    it('turn 7: player 3, road', () => {
      expect(calculateDraftPosition(7, 4)).toEqual({ round: 1, playerIndex: 3, phase: 'road' });
    });

    // Round 2: Reverse order (4→3→2→1)
    it('turn 8: player 3, settlement (round 2 starts)', () => {
      expect(calculateDraftPosition(8, 4)).toEqual({ round: 2, playerIndex: 3, phase: 'settlement' });
    });
    it('turn 14: player 0, settlement', () => {
      expect(calculateDraftPosition(14, 4)).toEqual({ round: 2, playerIndex: 0, phase: 'settlement' });
    });
    it('turn 15: player 0, road (last turn)', () => {
      expect(calculateDraftPosition(15, 4)).toEqual({ round: 2, playerIndex: 0, phase: 'road' });
    });
  });

  describe('3 players', () => {
    it('turn 5: player 2, road', () => {
      expect(calculateDraftPosition(5, 3)).toEqual({ round: 1, playerIndex: 2, phase: 'road' });
    });
    it('turn 6: player 2, settlement (round 2)', () => {
      expect(calculateDraftPosition(6, 3)).toEqual({ round: 2, playerIndex: 2, phase: 'settlement' });
    });
    it('turn 11: player 0, road (last turn)', () => {
      expect(calculateDraftPosition(11, 3)).toEqual({ round: 2, playerIndex: 0, phase: 'road' });
    });
  });
});

describe('isSetupComplete', () => {
  it('returns false during setup', () => {
    expect(isSetupComplete(15, 4)).toBe(false);
  });
  it('returns true after setup', () => {
    expect(isSetupComplete(16, 4)).toBe(true);
  });
});
```
  </action>
  <verify>Run `npx nx test shared --testPathPattern=snakeDraft` - all tests pass</verify>
  <done>Snake draft utilities correctly calculate turn order for 3-4 players</done>
</task>

<task type="auto">
  <name>Task 2: Add placement WebSocket message schemas</name>
  <files>libs/shared/src/schemas/messages.ts, libs/shared/src/index.ts</files>
  <action>
Update `libs/shared/src/schemas/messages.ts` to add placement-related messages:

1. **PlaceSettlementMessageSchema (client → server):**
```typescript
export const PlaceSettlementMessageSchema = z.object({
  type: z.literal('place_settlement'),
  vertexId: z.string(),
});
```

2. **PlaceRoadMessageSchema (client → server):**
```typescript
export const PlaceRoadMessageSchema = z.object({
  type: z.literal('place_road'),
  edgeId: z.string(),
});
```

3. **SettlementPlacedMessageSchema (server → clients):**
```typescript
export const SettlementPlacedMessageSchema = z.object({
  type: z.literal('settlement_placed'),
  vertexId: z.string(),
  playerId: z.string(),
  isSecondSettlement: z.boolean(),  // true = grants resources
  resourcesGranted: z.array(z.object({
    type: z.enum(['wood', 'brick', 'sheep', 'wheat', 'ore']),
    count: z.number(),
  })).optional(),  // Only present if isSecondSettlement
});
```

4. **RoadPlacedMessageSchema (server → clients):**
```typescript
export const RoadPlacedMessageSchema = z.object({
  type: z.literal('road_placed'),
  edgeId: z.string(),
  playerId: z.string(),
});
```

5. **PlacementTurnMessageSchema (server → clients):**
```typescript
export const PlacementTurnMessageSchema = z.object({
  type: z.literal('placement_turn'),
  currentPlayerIndex: z.number(),
  currentPlayerId: z.string(),
  phase: z.enum(['settlement', 'road']),
  round: z.union([z.literal(1), z.literal(2)]),
  turnNumber: z.number(),
});
```

6. **SetupCompleteMessageSchema (server → clients):**
```typescript
export const SetupCompleteMessageSchema = z.object({
  type: z.literal('setup_complete'),
  nextPlayerId: z.string(),  // First player for normal gameplay
});
```

7. **InvalidPlacementMessageSchema (server → client):**
```typescript
export const InvalidPlacementMessageSchema = z.object({
  type: z.literal('invalid_placement'),
  reason: z.string(),  // e.g., "Too close to existing settlement"
});
```

Add all new schemas to the WebSocketMessageSchema discriminated union.

Export all new types.

Update `libs/shared/src/index.ts` to export:
- All from './utils/snakeDraft'
  </action>
  <verify>Run `npx nx build shared` - builds without TypeScript errors</verify>
  <done>Placement message schemas defined and exported, WebSocket union updated</done>
</task>

</tasks>

<verification>
1. `npx nx test shared --testPathPattern=snakeDraft` passes with all turn order tests
2. `npx nx build shared` succeeds
3. Importing `{ calculateDraftPosition, PlaceSettlementMessageSchema }` from '@catan/shared' works
</verification>

<success_criteria>
- Turn 0-15 maps to correct players for 4-player game
- Turn 0-11 maps to correct players for 3-player game
- Round transitions correctly at midpoint
- All placement messages have proper types
</success_criteria>

<output>
After completion, create `.planning/phases/03-initial-placement/03-02-SUMMARY.md`
</output>
