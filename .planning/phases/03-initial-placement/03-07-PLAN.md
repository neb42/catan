---
phase: 03-initial-placement
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/src/components/Lobby.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - 'Client updates placement state when server broadcasts placement_turn'
    - 'Client renders placed settlement when server broadcasts settlement_placed'
    - 'Client renders placed road when server broadcasts road_placed'
  artifacts:
    - path: 'apps/web/src/components/Lobby.tsx'
      provides: 'WebSocket message handlers for placement messages'
      contains: "case 'placement_turn':"
  key_links:
    - from: 'Lobby.tsx handleMessage'
      to: 'gameStore.setPlacementTurn'
      via: "case 'placement_turn'"
      pattern: "setPlacementTurn\\("
    - from: 'Lobby.tsx handleMessage'
      to: 'gameStore.addSettlement'
      via: "case 'settlement_placed'"
      pattern: "addSettlement\\("
    - from: 'Lobby.tsx handleMessage'
      to: 'gameStore.addRoad'
      via: "case 'road_placed'"
      pattern: "addRoad\\("
---

<objective>
Wire WebSocket placement messages to gameStore actions

Purpose: Close the critical gap where server broadcasts placement updates but client ignores them, leaving UI static during initial placement phase.

Output: Working message handlers that sync placement state between server and client.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-initial-placement/03-VERIFICATION.md
@.planning/phases/03-initial-placement/03-04-SUMMARY.md
@apps/web/src/components/Lobby.tsx
@apps/web/src/stores/gameStore.ts
@libs/shared/src/schemas/messages.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add placement message handlers to Lobby.tsx</name>
  <files>apps/web/src/components/Lobby.tsx</files>
  <action>
Add three new cases to the `handleMessage` switch statement in Lobby.tsx:

1. **Handler for 'placement_turn':**

   ```typescript
   case 'placement_turn': {
     useGameStore.getState().setPlacementTurn({
       currentPlayerIndex: message.currentPlayerIndex,
       currentPlayerId: message.currentPlayerId,
       phase: message.phase,
       round: message.round,
       turnNumber: message.turnNumber,
     });
     break;
   }
   ```

2. **Handler for 'settlement_placed':**

   ```typescript
   case 'settlement_placed': {
     useGameStore.getState().addSettlement({
       vertexId: message.vertexId,
       playerId: message.playerId,
     });
     break;
   }
   ```

3. **Handler for 'road_placed':**
   ```typescript
   case 'road_placed': {
     useGameStore.getState().addRoad({
       edgeId: message.edgeId,
       playerId: message.playerId,
     });
     break;
   }
   ```

Place these cases BEFORE the `default:` case, logically grouped with or after the `game_started` case since they're all gameplay messages.

**Pattern to follow:** The existing handlers (like `game_started`) use `useGameStore.getState()` to access store actions. Continue this pattern.

**Do NOT modify:** Any existing cases or other logic in the file.
</action>
<verify>

1. `npx nx build web` - Build succeeds without TypeScript errors
2. Grep check: `grep -n "case 'placement_turn'" apps/web/src/components/Lobby.tsx` returns a match
3. Grep check: `grep -n "case 'settlement_placed'" apps/web/src/components/Lobby.tsx` returns a match
4. Grep check: `grep -n "case 'road_placed'" apps/web/src/components/Lobby.tsx` returns a match
   </verify>
   <done>
   Lobby.tsx has handlers for all three placement messages. When server broadcasts:

- `placement_turn` → gameStore.setPlacementTurn() is called → UI updates to show new turn
- `settlement_placed` → gameStore.addSettlement() is called → settlement renders on board
- `road_placed` → gameStore.addRoad() is called → road renders on board
  </done>
  </task>

</tasks>

<verification>
1. Build verification: `npx nx build web` succeeds
2. Code inspection: All three message types have handlers in Lobby.tsx switch statement
3. Store integration: Handlers call the correct gameStore actions with proper payloads

**Manual E2E test (optional but recommended):**

1. Start server: `npx nx serve api`
2. Start client: `npx nx serve web`
3. Open two browser tabs, create/join a room with 3+ players
4. Mark all ready, wait for game start
5. Verify: PlacementBanner shows whose turn it is
6. Verify: After placing settlement, UI updates to show road phase
7. Verify: After placing road, UI updates to show next player's turn
   </verification>

<success_criteria>

- [ ] Build passes: `npx nx build web`
- [ ] Handler for `placement_turn` exists and calls `setPlacementTurn`
- [ ] Handler for `settlement_placed` exists and calls `addSettlement`
- [ ] Handler for `road_placed` exists and calls `addRoad`
- [ ] No TypeScript errors
- [ ] No runtime errors in browser console
      </success_criteria>

<output>
After completion, create `.planning/phases/03-initial-placement/03-07-SUMMARY.md`
</output>
