---
phase: 03-initial-placement
plan: 04
type: execute
wave: 2
depends_on: ['03-01', '03-02']
files_modified:
  - apps/web/src/stores/gameStore.ts
  - apps/web/src/hooks/usePlacementState.ts
  - apps/web/src/hooks/useValidLocations.ts
  - apps/web/src/utils/hexGeometry.ts
autonomous: true

must_haves:
  truths:
    - 'Client tracks placement state (current player, phase, valid locations)'
    - 'Valid settlement locations calculated and update on state changes'
    - 'Valid road locations calculated based on just-placed settlement'
    - 'Placement state syncs with server messages'
  artifacts:
    - path: 'apps/web/src/stores/gameStore.ts'
      provides: 'Extended game store with placement slice'
      exports: ['usePlacementPhase', 'useCurrentPlayer', 'usePlacementActions']
    - path: 'apps/web/src/hooks/useValidLocations.ts'
      provides: 'Valid placement location calculation'
      exports: ['useValidSettlementLocations', 'useValidRoadLocations']
    - path: 'apps/web/src/hooks/usePlacementState.ts'
      provides: 'Placement workflow state selector'
      exports: ['usePlacementState']
  key_links:
    - from: 'apps/web/src/hooks/useValidLocations.ts'
      to: '@catan/shared hexGeometry'
      via: 'Uses getUniqueVertices, getUniqueEdges'
      pattern: 'getUniqueVertices|getUniqueEdges'
    - from: 'apps/web/src/stores/gameStore.ts'
      to: 'WebSocket messages'
      via: 'Handles placement_turn, settlement_placed, road_placed'
      pattern: 'placement_turn|settlement_placed'
---

<objective>
Extend client-side state management for initial placement phase with valid location calculation.

Purpose: Client needs to track placement state (who's placing, what they're placing, where they can place) to render interactive UI. Valid locations calculated client-side for immediate feedback while server remains authoritative.

Output: Extended gameStore with placement slice, usePlacementState hook, useValidLocations hooks.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-initial-placement/03-CONTEXT.md
@.planning/phases/03-initial-placement/03-RESEARCH.md
@libs/shared/src/schemas/game.ts
@libs/shared/src/utils/hexGeometry.ts
@apps/web/src/stores/gameStore.ts
@apps/web/src/hooks/useWebSocket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend gameStore with placement state</name>
  <files>apps/web/src/stores/gameStore.ts</files>
  <action>
Update `apps/web/src/stores/gameStore.ts` to add placement state:

```typescript
import { create } from 'zustand';
import type {
  WebSocketMessage,
  BoardState,
  Settlement,
  Road,
  GamePhase,
} from '@catan/shared';

// Placement state slice
interface PlacementSlice {
  currentPlayerIndex: number | null;
  currentPlayerId: string | null;
  placementPhase: 'settlement' | 'road' | null;
  draftRound: 1 | 2 | null;
  turnNumber: number;

  // Placed pieces
  settlements: Settlement[];
  roads: Road[];

  // Selection state (for preview)
  selectedLocationId: string | null;

  // Last placed (for road connection)
  lastPlacedSettlementId: string | null;
}

interface GameStore extends PlacementSlice {
  board: BoardState | null;
  gameStarted: boolean;
  myPlayerId: string | null;
  lastError: string | null;
  sendMessage: ((message: WebSocketMessage) => void) | null;

  // Actions
  setBoard: (board: BoardState) => void;
  setGameStarted: (started: boolean) => void;
  setMyPlayerId: (playerId: string | null) => void;
  setLastError: (message: string | null) => void;
  setSendMessage: (
    handler: ((message: WebSocketMessage) => void) | null,
  ) => void;

  // Placement actions
  setPlacementTurn: (turn: {
    currentPlayerIndex: number;
    currentPlayerId: string;
    phase: 'settlement' | 'road';
    round: 1 | 2;
    turnNumber: number;
  }) => void;
  addSettlement: (settlement: Settlement) => void;
  addRoad: (road: Road) => void;
  setSelectedLocation: (id: string | null) => void;
  setLastPlacedSettlement: (id: string | null) => void;
  clearPlacementState: () => void;
}

export const useGameStore = create<GameStore>((set) => ({
  // Existing state
  board: null,
  gameStarted: false,
  myPlayerId: null,
  lastError: null,
  sendMessage: null,

  // Placement state
  currentPlayerIndex: null,
  currentPlayerId: null,
  placementPhase: null,
  draftRound: null,
  turnNumber: 0,
  settlements: [],
  roads: [],
  selectedLocationId: null,
  lastPlacedSettlementId: null,

  // Existing actions
  setBoard: (board) => set({ board }),
  setGameStarted: (started) => set({ gameStarted: started }),
  setMyPlayerId: (playerId) => set({ myPlayerId: playerId }),
  setLastError: (message) => set({ lastError: message }),
  setSendMessage: (handler) => set({ sendMessage: handler }),

  // Placement actions
  setPlacementTurn: (turn) =>
    set({
      currentPlayerIndex: turn.currentPlayerIndex,
      currentPlayerId: turn.currentPlayerId,
      placementPhase: turn.phase,
      draftRound: turn.round,
      turnNumber: turn.turnNumber,
    }),

  addSettlement: (settlement) =>
    set((state) => ({
      settlements: [...state.settlements, settlement],
      lastPlacedSettlementId: settlement.vertexId,
    })),

  addRoad: (road) =>
    set((state) => ({
      roads: [...state.roads, road],
    })),

  setSelectedLocation: (id) => set({ selectedLocationId: id }),

  setLastPlacedSettlement: (id) => set({ lastPlacedSettlementId: id }),

  clearPlacementState: () =>
    set({
      currentPlayerIndex: null,
      currentPlayerId: null,
      placementPhase: null,
      draftRound: null,
      selectedLocationId: null,
    }),
}));

// CUSTOM HOOKS - prevent selector anti-pattern

export const usePlacementPhase = () =>
  useGameStore((state) => state.placementPhase);

export const useCurrentPlayer = () =>
  useGameStore((state) => ({
    index: state.currentPlayerIndex,
    id: state.currentPlayerId,
  }));

export const useIsMyTurn = () =>
  useGameStore((state) => state.currentPlayerId === state.myPlayerId);

export const useSelectedLocation = () =>
  useGameStore((state) => state.selectedLocationId);

export const usePlacementActions = () =>
  useGameStore((state) => ({
    setSelected: state.setSelectedLocation,
    addSettlement: state.addSettlement,
    addRoad: state.addRoad,
  }));

export const useSettlements = () => useGameStore((state) => state.settlements);

export const useRoads = () => useGameStore((state) => state.roads);
```

  </action>
  <verify>Run `npx nx build web` - builds without TypeScript errors</verify>
  <done>Game store extended with placement state and custom selector hooks</done>
</task>

<task type="auto">
  <name>Task 2: Create placement state and valid location hooks</name>
  <files>apps/web/src/hooks/usePlacementState.ts, apps/web/src/hooks/useValidLocations.ts</files>
  <action>
Create `apps/web/src/hooks/usePlacementState.ts`:

```typescript
import {
  useGameStore,
  useIsMyTurn,
  usePlacementPhase,
  useCurrentPlayer,
} from '../stores/gameStore';

export interface PlacementState {
  isMyTurn: boolean;
  phase: 'settlement' | 'road' | null;
  currentPlayerIndex: number | null;
  currentPlayerId: string | null;
  draftRound: 1 | 2 | null;
  turnNumber: number;
  canPlace: boolean;
}

export function usePlacementState(): PlacementState {
  const isMyTurn = useIsMyTurn();
  const phase = usePlacementPhase();
  const { index, id } = useCurrentPlayer();
  const draftRound = useGameStore((state) => state.draftRound);
  const turnNumber = useGameStore((state) => state.turnNumber);

  return {
    isMyTurn,
    phase,
    currentPlayerIndex: index,
    currentPlayerId: id,
    draftRound,
    turnNumber,
    canPlace: isMyTurn && phase !== null,
  };
}

export function useDraftOrder(playerCount: number): Array<{
  turnNumber: number;
  playerIndex: number;
  phase: 'settlement' | 'road';
  round: 1 | 2;
  isCurrent: boolean;
}> {
  const currentTurn = useGameStore((state) => state.turnNumber);

  // Calculate full snake draft order for display
  const totalTurns = playerCount * 4; // 2 settlements + 2 roads per player
  const order: Array<{
    turnNumber: number;
    playerIndex: number;
    phase: 'settlement' | 'road';
    round: 1 | 2;
    isCurrent: boolean;
  }> = [];

  for (let t = 0; t < totalTurns; t++) {
    const positionsPerRound = playerCount * 2;

    if (t < positionsPerRound) {
      // Round 1: forward
      order.push({
        turnNumber: t,
        playerIndex: Math.floor(t / 2),
        phase: t % 2 === 0 ? 'settlement' : 'road',
        round: 1,
        isCurrent: t === currentTurn,
      });
    } else {
      // Round 2: reverse
      const roundTwoTurn = t - positionsPerRound;
      order.push({
        turnNumber: t,
        playerIndex: playerCount - 1 - Math.floor(roundTwoTurn / 2),
        phase: roundTwoTurn % 2 === 0 ? 'settlement' : 'road',
        round: 2,
        isCurrent: t === currentTurn,
      });
    }
  }

  return order;
}
```

Create `apps/web/src/hooks/useValidLocations.ts`:

```typescript
import { useMemo } from 'react';
import { getUniqueVertices, getUniqueEdges, Vertex, Edge } from '@catan/shared';
import { useGameStore, useSettlements, useRoads } from '../stores/gameStore';

const EDGE_DISTANCE = 12; // Approximate edge length for hex size 10

function getAdjacentVertexIds(
  vertex: Vertex,
  allVertices: Vertex[],
  edges: Edge[],
): string[] {
  // Two vertices are adjacent if they share an edge
  return edges
    .filter((edge) => {
      const startMatch =
        Math.abs(edge.start.x - vertex.x) < 0.5 &&
        Math.abs(edge.start.y - vertex.y) < 0.5;
      const endMatch =
        Math.abs(edge.end.x - vertex.x) < 0.5 &&
        Math.abs(edge.end.y - vertex.y) < 0.5;
      return startMatch || endMatch;
    })
    .map((edge) => {
      // Return the other endpoint
      const startMatch =
        Math.abs(edge.start.x - vertex.x) < 0.5 &&
        Math.abs(edge.start.y - vertex.y) < 0.5;
      if (startMatch) {
        const roundedX = Math.round(edge.end.x * 10) / 10;
        const roundedY = Math.round(edge.end.y * 10) / 10;
        return `${roundedX},${roundedY}`;
      } else {
        const roundedX = Math.round(edge.start.x * 10) / 10;
        const roundedY = Math.round(edge.start.y * 10) / 10;
        return `${roundedX},${roundedY}`;
      }
    });
}

export function useValidSettlementLocations(): Array<{
  vertex: Vertex;
  isValid: boolean;
  invalidReason?: string;
}> {
  const board = useGameStore((state) => state.board);
  const settlements = useSettlements();

  return useMemo(() => {
    if (!board) return [];

    const vertices = getUniqueVertices(board.hexes);
    const edges = getUniqueEdges(board.hexes);
    const occupiedIds = new Set(settlements.map((s) => s.vertexId));

    return vertices.map((vertex) => {
      // Check if occupied
      if (occupiedIds.has(vertex.id)) {
        return { vertex, isValid: false, invalidReason: 'Already occupied' };
      }

      // Check distance rule - no adjacent settlements
      const adjacentIds = getAdjacentVertexIds(vertex, vertices, edges);
      const hasAdjacentSettlement = adjacentIds.some((id) =>
        occupiedIds.has(id),
      );

      if (hasAdjacentSettlement) {
        return {
          vertex,
          isValid: false,
          invalidReason: 'Too close to existing settlement',
        };
      }

      return { vertex, isValid: true };
    });
  }, [board, settlements]);
}

export function useValidRoadLocations(): Array<{
  edge: Edge;
  isValid: boolean;
  invalidReason?: string;
}> {
  const board = useGameStore((state) => state.board);
  const roads = useRoads();
  const lastPlacedSettlementId = useGameStore(
    (state) => state.lastPlacedSettlementId,
  );

  return useMemo(() => {
    if (!board || !lastPlacedSettlementId) return [];

    const vertices = getUniqueVertices(board.hexes);
    const edges = getUniqueEdges(board.hexes);
    const occupiedEdgeIds = new Set(roads.map((r) => r.edgeId));

    // Find the settlement vertex
    const settlementVertex = vertices.find(
      (v) => v.id === lastPlacedSettlementId,
    );
    if (!settlementVertex) return [];

    return edges.map((edge) => {
      // Check if occupied
      if (occupiedEdgeIds.has(edge.id)) {
        return { edge, isValid: false, invalidReason: 'Already occupied' };
      }

      // Check if connects to settlement
      const startConnects =
        Math.abs(edge.start.x - settlementVertex.x) < 0.5 &&
        Math.abs(edge.start.y - settlementVertex.y) < 0.5;
      const endConnects =
        Math.abs(edge.end.x - settlementVertex.x) < 0.5 &&
        Math.abs(edge.end.y - settlementVertex.y) < 0.5;

      if (!startConnects && !endConnects) {
        return {
          edge,
          isValid: false,
          invalidReason: 'Must connect to your settlement',
        };
      }

      return { edge, isValid: true };
    });
  }, [board, roads, lastPlacedSettlementId]);
}

export function useAllVertices(): Vertex[] {
  const board = useGameStore((state) => state.board);
  return useMemo(() => {
    if (!board) return [];
    return getUniqueVertices(board.hexes);
  }, [board]);
}

export function useAllEdges(): Edge[] {
  const board = useGameStore((state) => state.board);
  return useMemo(() => {
    if (!board) return [];
    return getUniqueEdges(board.hexes);
  }, [board]);
}
```

  </action>
  <verify>Run `npx nx build web` - builds without TypeScript errors</verify>
  <done>Placement state and valid location hooks calculate correctly and memoize results</done>
</task>

</tasks>

<verification>
1. `npx nx build web` succeeds
2. Custom hooks export correctly from stores/gameStore.ts
3. useValidSettlementLocations returns valid/invalid with reasons
4. useValidRoadLocations filters to edges connecting to last settlement
</verification>

<success_criteria>

- Game store tracks settlements, roads, current turn, placement phase
- Custom selector hooks prevent re-render anti-pattern
- Valid settlement locations exclude occupied and adjacent vertices
- Valid road locations only include edges connecting to just-placed settlement
- useDraftOrder calculates full snake draft for UI display
  </success_criteria>

<output>
After completion, create `.planning/phases/03-initial-placement/03-04-SUMMARY.md`
</output>
