---
phase: 03-initial-placement
plan: 03
type: execute
wave: 2
depends_on: ['03-01', '03-02']
files_modified:
  - apps/api/src/game/placement-validator.ts
  - apps/api/src/game/placement-validator.spec.ts
  - apps/api/src/game/GameManager.ts
  - apps/api/src/handlers/websocket.ts
autonomous: true

must_haves:
  truths:
    - 'Server validates settlement placement (distance rule, no occupied vertices)'
    - 'Server validates road placement (must connect to just-placed settlement)'
    - 'Server tracks game state with settlements, roads, and placement turn'
    - 'Server broadcasts placement results to all clients'
  artifacts:
    - path: 'apps/api/src/game/placement-validator.ts'
      provides: 'Authoritative placement validation logic'
      exports:
        [
          'isValidSettlementPlacement',
          'isValidRoadPlacement',
          'getInvalidReason',
        ]
    - path: 'apps/api/src/game/GameManager.ts'
      provides: 'Game state management during setup phase'
      exports: ['GameManager']
  key_links:
    - from: 'apps/api/src/handlers/websocket.ts'
      to: 'apps/api/src/game/GameManager.ts'
      via: 'placement message handlers'
      pattern: 'place_settlement|place_road'
    - from: 'apps/api/src/game/GameManager.ts'
      to: 'apps/api/src/game/placement-validator.ts'
      via: 'validation calls'
      pattern: 'isValidSettlementPlacement|isValidRoadPlacement'
---

<objective>
Implement server-side placement validation and game state management for initial placement phase.

Purpose: Server is authoritative for game state. All placement actions validated server-side before broadcasting to clients. This ensures fair play and consistent state across all connected clients.

Output: placement-validator.ts with tests, GameManager.ts for state management, updated websocket.ts with placement handlers.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-initial-placement/03-CONTEXT.md
@.planning/phases/03-initial-placement/03-RESEARCH.md
@libs/shared/src/schemas/game.ts
@libs/shared/src/schemas/messages.ts
@libs/shared/src/utils/hexGeometry.ts
@libs/shared/src/utils/snakeDraft.ts
@apps/api/src/handlers/websocket.ts
@apps/api/src/managers/RoomManager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create placement validation logic</name>
  <files>apps/api/src/game/placement-validator.ts, apps/api/src/game/placement-validator.spec.ts</files>
  <action>
Create `apps/api/src/game/placement-validator.ts` with authoritative validation:

1. **isValidSettlementPlacement(vertexId, gameState, vertices):**
   - Check vertex exists in valid vertex list
   - Check vertex not already occupied (gameState.settlements)
   - Check distance rule: no settlements on adjacent vertices
   - Adjacent vertices = vertices that share an edge (within ~edge distance of each other AND share at least one adjacent hex)
   - Return boolean

2. **isValidRoadPlacement(edgeId, gameState, playerId, justPlacedSettlementId, edges):**
   - Check edge exists in valid edge list
   - Check edge not already occupied (gameState.roads)
   - During setup: must connect to the settlement just placed
   - Edge connects to vertex if edge endpoints match vertex coordinates
   - Return boolean

3. **getInvalidSettlementReason(vertexId, gameState, vertices):**
   - Returns null if valid
   - Returns human-readable string: "Vertex already occupied", "Too close to existing settlement", "Invalid vertex"

4. **getInvalidRoadReason(edgeId, gameState, playerId, justPlacedSettlementId, edges):**
   - Returns null if valid
   - Returns human-readable string: "Edge already occupied", "Must connect to your settlement", "Invalid edge"

**Helper function getAdjacentVertexIds(vertexId, vertices, edges):**

- Vertices are adjacent if connected by an edge
- Use edge endpoints to determine adjacency
- Return string[] of adjacent vertex IDs

Create test file `placement-validator.spec.ts`:

```typescript
describe('isValidSettlementPlacement', () => {
  it('returns true for empty vertex with no adjacent settlements', () => { ... });
  it('returns false for occupied vertex', () => { ... });
  it('returns false for vertex adjacent to existing settlement', () => { ... });
});

describe('isValidRoadPlacement', () => {
  it('returns true for edge connecting to just-placed settlement', () => { ... });
  it('returns false for occupied edge', () => { ... });
  it('returns false for edge not connected to settlement', () => { ... });
});

describe('getInvalidSettlementReason', () => {
  it('returns null for valid placement', () => { ... });
  it('returns "Too close to existing settlement" for adjacent vertex', () => { ... });
});
```

  </action>
  <verify>Run `npx nx test api --testPathPattern=placement-validator` - all tests pass</verify>
  <done>Placement validation correctly enforces Catan settlement and road rules</done>
</task>

<task type="auto">
  <name>Task 2: Create GameManager and placement handlers</name>
  <files>apps/api/src/game/GameManager.ts, apps/api/src/handlers/websocket.ts</files>
  <action>
Create `apps/api/src/game/GameManager.ts`:

```typescript
import { GameState, Settlement, Road, PlacementState, BoardState } from '@catan/shared';
import { calculateDraftPosition, isSetupComplete } from '@catan/shared';
import { getUniqueVertices, getUniqueEdges, Vertex, Edge } from '@catan/shared';

export class GameManager {
  private gameState: GameState;
  private vertices: Vertex[];
  private edges: Edge[];
  private playerIds: string[];
  private turnNumber: number = 0;
  private lastPlacedSettlementId: string | null = null;

  constructor(board: BoardState, playerIds: string[]) {
    this.playerIds = playerIds;
    this.vertices = getUniqueVertices(board.hexes);
    this.edges = getUniqueEdges(board.hexes);

    const initialDraft = calculateDraftPosition(0, playerIds.length);

    this.gameState = {
      board,
      settlements: [],
      roads: [],
      placement: {
        currentPlayerIndex: initialDraft.playerIndex,
        draftRound: initialDraft.round,
        phase: initialDraft.phase === 'settlement' ? 'setup_settlement1' : 'setup_road1',
        turnNumber: 0,
      },
      playerResources: Object.fromEntries(
        playerIds.map(id => [id, { wood: 0, brick: 0, sheep: 0, wheat: 0, ore: 0 }])
      ),
    };
  }

  getCurrentPlayerId(): string { ... }
  getPlacementPhase(): 'settlement' | 'road' | null { ... }

  placeSettlement(vertexId: string, playerId: string): {
    success: boolean;
    error?: string;
    resourcesGranted?: Array<{ type: string; count: number }>;
    isSecondSettlement: boolean;
  } { ... }

  placeRoad(edgeId: string, playerId: string): {
    success: boolean;
    error?: string;
    setupComplete: boolean;
  } { ... }

  getState(): GameState { ... }
}
```

**placeSettlement implementation:**

1. Validate current player and phase
2. Call isValidSettlementPlacement
3. If valid: add settlement, update lastPlacedSettlementId
4. Check if this is second settlement (round 2) - grant resources from adjacent hexes
5. Advance to road phase (same player)
6. Return result

**placeRoad implementation:**

1. Validate current player and phase
2. Call isValidRoadPlacement with lastPlacedSettlementId
3. If valid: add road, advance turn via calculateDraftPosition
4. Check if isSetupComplete - if so, clear placement state
5. Return result including setupComplete flag

**Update websocket.ts:**

Add case handlers for 'place_settlement' and 'place_road' messages:

```typescript
case 'place_settlement': {
  if (!currentRoomId || !playerId) { sendError(ws, 'Not in room'); return; }

  const room = roomManager.getRoom(currentRoomId);
  if (!room?.gameManager) { sendError(ws, 'Game not started'); return; }

  const result = room.gameManager.placeSettlement(message.vertexId, playerId);

  if (!result.success) {
    sendMessage(ws, { type: 'invalid_placement', reason: result.error });
    return;
  }

  roomManager.broadcastToRoom(currentRoomId, {
    type: 'settlement_placed',
    vertexId: message.vertexId,
    playerId,
    isSecondSettlement: result.isSecondSettlement,
    resourcesGranted: result.resourcesGranted,
  });

  // Broadcast next turn
  const state = room.gameManager.getState();
  if (state.placement) {
    roomManager.broadcastToRoom(currentRoomId, {
      type: 'placement_turn',
      currentPlayerIndex: state.placement.currentPlayerIndex,
      currentPlayerId: room.gameManager.getCurrentPlayerId(),
      phase: room.gameManager.getPlacementPhase()!,
      round: state.placement.draftRound,
      turnNumber: state.placement.turnNumber,
    });
  }
  break;
}

case 'place_road': {
  // Similar pattern - validate, place, broadcast, check setup_complete
  ...
}
```

**Update RoomManager or ManagedRoom to hold gameManager:**

- Add `gameManager: GameManager | null` to ManagedRoom
- Initialize GameManager when game starts (after countdown)
  </action>
  <verify>Run `npx nx build api` - builds without errors. Manual test: start game, check placement messages handled</verify>
  <done>Server handles placement messages, validates, updates state, broadcasts results</done>
  </task>

</tasks>

<verification>
1. `npx nx test api --testPathPattern=placement-validator` passes
2. `npx nx build api` succeeds
3. Placement validation rejects invalid placements with correct error messages
4. GameManager tracks settlements, roads, and advances turn correctly
</verification>

<success_criteria>

- Settlement distance rule enforced (2-vertex spacing)
- Road must connect to just-placed settlement during setup
- Turn advances correctly following snake draft order
- Second settlement triggers resource calculation
- Setup complete when all 16 turns (4 players) finish
  </success_criteria>

<output>
After completion, create `.planning/phases/03-initial-placement/03-03-SUMMARY.md`
</output>
