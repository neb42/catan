---
phase: 03-initial-placement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - libs/shared/src/utils/hexGeometry.ts
  - libs/shared/src/utils/hexGeometry.spec.ts
  - libs/shared/src/schemas/game.ts
  - libs/shared/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Vertex coordinates can be calculated from hex positions"
    - "Edge coordinates can be calculated from hex corners"
    - "Unique vertices are merged correctly (no duplicates at shared corners)"
    - "Unique edges are merged correctly (no duplicates at shared edges)"
  artifacts:
    - path: "libs/shared/src/utils/hexGeometry.ts"
      provides: "Vertex and edge coordinate derivation from hex grid"
      exports: ["Vertex", "Edge", "getUniqueVertices", "getUniqueEdges", "getVertexFromCorner"]
    - path: "libs/shared/src/schemas/game.ts"
      provides: "Game state schemas for settlements, roads, and placement phase"
      exports: ["SettlementSchema", "RoadSchema", "GamePhaseSchema", "PlacementStateSchema", "GameStateSchema"]
  key_links:
    - from: "libs/shared/src/utils/hexGeometry.ts"
      to: "libs/shared/src/utils/coordinates.ts"
      via: "Uses hexToPixel for coordinate conversion"
      pattern: "hexToPixel"
---

<objective>
Create hex geometry utilities for vertex/edge coordinate calculation and define game state schemas.

Purpose: Foundation for rendering clickable settlement (vertex) and road (edge) locations, plus shared types for tracking game state during initial placement.

Output: hexGeometry.ts utilities with tests, game.ts schemas with exports.
</objective>

<execution_context>
@/Users/bmcalindin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bmcalindin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-initial-placement/03-CONTEXT.md
@.planning/phases/03-initial-placement/03-RESEARCH.md
@libs/shared/src/utils/coordinates.ts
@libs/shared/src/schemas/board.ts
@libs/shared/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hex geometry utilities</name>
  <files>libs/shared/src/utils/hexGeometry.ts, libs/shared/src/utils/hexGeometry.spec.ts</files>
  <action>
Create `libs/shared/src/utils/hexGeometry.ts` with:

1. **Vertex interface and derivation:**
```typescript
export interface Vertex {
  id: string;           // Unique identifier (rounded coordinate key)
  x: number;           // SVG x coordinate
  y: number;           // SVG y coordinate
  adjacentHexes: string[];  // Hex IDs that share this vertex (q,r format)
}
```

2. **Edge interface and derivation:**
```typescript
export interface Edge {
  id: string;           // Unique identifier (sorted endpoint key)
  start: { x: number; y: number };
  end: { x: number; y: number };
  midpoint: { x: number; y: number };
  adjacentHexes: string[];  // Hex IDs that share this edge
}
```

3. **getVertexFromCorner function:**
   - Takes hex (q, r) and corner index (0-5)
   - Uses hexToPixel from coordinates.ts to get hex center
   - Calculates corner position using pointy-top hex math:
     - Corner i angle = 30 + (i * 60) degrees for pointy-top
     - x = centerX + size * cos(angle)
     - y = centerY + size * sin(angle)
   - Returns Vertex with rounded coordinates for ID

4. **getUniqueVertices function:**
   - Takes array of hex coordinates (from BoardState.hexes)
   - Iterates all hexes, calculates all 6 corners
   - Uses Map with rounded coordinate keys (EPSILON=0.1) to deduplicate
   - Adjacent hexes tracked for each vertex
   - Returns Vertex[] (should be ~54 for 19 hexes, not 114)

5. **getUniqueEdges function:**
   - Takes array of hex coordinates
   - For each hex, creates 6 edges connecting consecutive corners
   - Normalizes edge IDs (smaller coordinate first)
   - Uses Map to deduplicate shared edges
   - Returns Edge[] with start, end, midpoint, adjacentHexes

**Critical:** Use EPSILON=0.1 for coordinate rounding to handle floating-point precision. Size should match react-hexgrid Layout: { x: 10, y: 10 }.

Create test file `hexGeometry.spec.ts`:
- Test getUniqueVertices returns ~54 vertices for 19 hexes (not 114 duplicates)
- Test adjacent vertex sharing (center hex should have 6 adjacent hexes per corner)
- Test edge deduplication (shared edges have 2 adjacent hexes)
  </action>
  <verify>Run `npx nx test shared --testPathPattern=hexGeometry` - all tests pass</verify>
  <done>Vertex and edge utilities correctly deduplicate shared coordinates and track adjacency</done>
</task>

<task type="auto">
  <name>Task 2: Create game state schemas</name>
  <files>libs/shared/src/schemas/game.ts, libs/shared/src/index.ts</files>
  <action>
Create `libs/shared/src/schemas/game.ts` with Zod schemas:

1. **ResourceTypeSchema:**
```typescript
export const ResourceTypeSchema = z.enum(['wood', 'brick', 'sheep', 'wheat', 'ore']);
```

2. **SettlementSchema:**
```typescript
export const SettlementSchema = z.object({
  vertexId: z.string(),   // Unique vertex ID from hexGeometry
  playerId: z.string(),   // Owner player ID
  isCity: z.boolean(),    // false for settlement, true for city (future)
});
```

3. **RoadSchema:**
```typescript
export const RoadSchema = z.object({
  edgeId: z.string(),     // Unique edge ID from hexGeometry
  playerId: z.string(),   // Owner player ID
});
```

4. **GamePhaseSchema:**
```typescript
export const GamePhaseSchema = z.enum([
  'setup_settlement1',  // First settlement placement
  'setup_road1',        // First road placement
  'setup_settlement2',  // Second settlement (resources granted)
  'setup_road2',        // Second road placement
  'playing',            // Normal gameplay (future phases)
]);
```

5. **PlacementStateSchema:**
```typescript
export const PlacementStateSchema = z.object({
  currentPlayerIndex: z.number(),   // 0-based index in player array
  draftRound: z.union([z.literal(1), z.literal(2)]),  // Round 1 or 2
  phase: GamePhaseSchema,
  turnNumber: z.number(),           // 0-15 for 4 players
});
```

6. **PlayerResourcesSchema:**
```typescript
export const PlayerResourcesSchema = z.record(
  ResourceTypeSchema,
  z.number()
).default({ wood: 0, brick: 0, sheep: 0, wheat: 0, ore: 0 });
```

7. **GameStateSchema:**
```typescript
export const GameStateSchema = z.object({
  board: BoardStateSchema,
  settlements: z.array(SettlementSchema),
  roads: z.array(RoadSchema),
  placement: PlacementStateSchema.nullable(),  // null when not in setup
  playerResources: z.record(z.string(), PlayerResourcesSchema),  // playerId -> resources
});
```

Export all types: Settlement, Road, GamePhase, PlacementState, PlayerResources, GameState, ResourceType.

Update `libs/shared/src/index.ts`:
- Export all from './schemas/game'
- Export all from './utils/hexGeometry'
  </action>
  <verify>Run `npx nx build shared` - builds without TypeScript errors</verify>
  <done>Game state schemas defined with proper types for settlements, roads, placement phase, and resources</done>
</task>

</tasks>

<verification>
1. `npx nx test shared --testPathPattern=hexGeometry` passes
2. `npx nx build shared` succeeds
3. Importing `{ Vertex, Edge, GameState, SettlementSchema }` from '@catan/shared' works
</verification>

<success_criteria>
- Vertex deduplication produces ~54 vertices from 19 hexes
- Edge deduplication produces correct shared edge count
- All game state schemas validate correctly
- Exports available from @catan/shared
</success_criteria>

<output>
After completion, create `.planning/phases/03-initial-placement/03-01-SUMMARY.md`
</output>
