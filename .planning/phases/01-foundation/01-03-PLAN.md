---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - apps/web/src/services/websocket.ts
  - apps/web/src/hooks/useWebSocket.ts
  - apps/web/src/components/Lobby.tsx
  - apps/web/src/components/CreateRoom.tsx
  - apps/web/src/components/JoinRoom.tsx
  - apps/web/src/components/PlayerList.tsx
  - apps/web/src/app/app.tsx
autonomous: true

must_haves:
  truths:
    - "User can click Create Room and see shareable room ID"
    - "User can enter room ID and nickname to join"
    - "User sees real-time player list updates when others join"
    - "User can select player color from available options"
    - "User can toggle ready status before game starts"
    - "User sees countdown timer when all players are ready"
    - "User sees error messages for invalid operations"
    - "User sees reconnecting state during network issues"
  artifacts:
    - path: "apps/web/src/services/websocket.ts"
      provides: "WebSocket client with reconnection"
      exports: ["WebSocketClient"]
    - path: "apps/web/src/hooks/useWebSocket.ts"
      provides: "React hook for WebSocket state"
      exports: ["useWebSocket"]
    - path: "apps/web/src/components/Lobby.tsx"
      provides: "Main lobby container"
      min_lines: 50
    - path: "apps/web/src/components/CreateRoom.tsx"
      provides: "Create room form"
      min_lines: 30
    - path: "apps/web/src/components/JoinRoom.tsx"
      provides: "Join room form"
      min_lines: 40
    - path: "apps/web/src/components/PlayerList.tsx"
      provides: "Real-time player list"
      min_lines: 30
  key_links:
    - from: "apps/web/src/hooks/useWebSocket.ts"
      to: "apps/web/src/services/websocket.ts"
      via: "WebSocketClient instantiation"
      pattern: "new WebSocketClient"
    - from: "apps/web/src/components/Lobby.tsx"
      to: "apps/web/src/hooks/useWebSocket.ts"
      via: "useWebSocket hook"
      pattern: "useWebSocket\\("
    - from: "apps/web/src/hooks/useWebSocket.ts"
      to: "@catan/shared"
      via: "message validation"
      pattern: "WebSocketMessageSchema"
---

<objective>
Build lobby UI with WebSocket client for creating/joining rooms and displaying real-time player updates.

Purpose: Users can create game rooms with shareable IDs, join existing rooms by entering IDs, set nicknames, and see live lobby updates as players join/leave.

Output: Functional lobby interface with WebSocket reconnection, error handling, and real-time synchronization.
</objective>

<execution_context>
@./.github/get-shit-done/workflows/execute-plan.md
@./.github/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/codebase/STACK.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Create WebSocket client service with exponential backoff reconnection</name>
  <files>
    apps/web/src/services/websocket.ts
    apps/web/src/hooks/useWebSocket.ts
  </files>
  <action>
Create two files following RESEARCH.md patterns:

**apps/web/src/services/websocket.ts:**
- Implement WebSocketClient class following RESEARCH.md Pattern 5 (Client-Side Reconnection)
- Constructor takes url (ws://localhost:3333/ws)
- Private properties: ws, reconnectAttempts, reconnectDelay (start 1000ms), maxReconnectAttempts (Infinity per CONTEXT.md)
- connect() method: Create WebSocket, set up onopen (reset reconnect counters), onclose (schedule reconnect), onmessage (callback), onerror (log)
- scheduleReconnect() method: Exponential backoff with max 30s delay
- sendMessage(message) method: Check readyState === OPEN before sending JSON.stringify(message)
- disconnect() method: Close WebSocket, clear reconnect timers
- Export class

**apps/web/src/hooks/useWebSocket.ts:**
- Implement React hook following RESEARCH.md "React Hook for WebSocket with Reconnection"
- Accept { url, onMessage } options
- Use useRef for WebSocketClient instance
- Use useState for isConnected
- useEffect: Create client, connect, set up callbacks, cleanup on unmount
- Return { isConnected, sendMessage }
- Parse and validate messages with WebSocketMessageSchema from @catan/shared (catch and log validation errors)

Avoid socket.io patterns - use native WebSocket API.
  </action>
  <verify>
Run `npx nx serve web` and open DevTools console.
Verify WebSocket connection opens to ws://localhost:3333/ws.
Stop API server, verify "reconnecting" logs appear with increasing delays.
Restart API server, verify reconnection succeeds.
  </verify>
  <done>
WebSocketClient class handles connection/disconnection/reconnection with exponential backoff, useWebSocket hook provides React-friendly API, messages validated with Zod, reconnection works after network interruption.
  </done>
</task>

<task type="auto">
  <name>Build lobby components (CreateRoom, JoinRoom, PlayerList)</name>
  <files>
    apps/web/src/components/CreateRoom.tsx
    apps/web/src/components/JoinRoom.tsx
    apps/web/src/components/PlayerList.tsx
  </files>
  <action>
Create three components using Mantine UI (already in stack per STACK.md):

**CreateRoom.tsx:**
- Import TextInput, Button from @mantine/core
- State: nickname (string), error (string | null)
- Form: Nickname input (2-30 chars per CONTEXT.md), Create Room button
- On submit: Validate nickname length, send create_room message via sendMessage({ type: 'create_room', nickname })
- Disable button if not connected or nickname invalid
- Display error if present
- Export default component

**JoinRoom.tsx:**
- State: roomId (string), nickname (string), error (string | null)
- Form: Room ID input (6 chars, uppercase), Nickname input (2-30 chars), Join Room button
- On submit: Validate inputs, send join_room message via sendMessage({ type: 'join_room', roomId: roomId.toUpperCase(), nickname })
- Convert room ID to uppercase automatically
- Display error if present ("Room not found", "Room is full", "Nickname taken")
- Export default component

**PlayerList.tsx:**
- Props: players (Player[] from @catan/shared), currentPlayerId (string), onColorChange ((color: string) => void), onReadyToggle (() => void)
- Render list of players with nickname, color indicator (colored dot/badge), ready status (✓ or ✗)
- For current player: Show color selector (ColorSwatch or Select from Mantine with PLAYER_COLORS from @catan/shared)
- For current player: Show "Ready" toggle button (Button with variant based on ready state)
- For other players: Show static color indicator and ready status
- Use Mantine List, Badge, Stack, ColorSwatch, Button components
- Show "No players yet" if empty
- Export default component

Use Mantine's @mantine/form for form validation if helpful, otherwise controlled components are fine.
  </action>
  <verify>
Run `npx nx serve web` and verify:
- CreateRoom component renders with nickname input and button
- JoinRoom component renders with room ID and nickname inputs
- PlayerList component renders with proper styling
- No TypeScript errors in browser console
- Mantine components display correctly
  </verify>
  <done>
All three components exist, use Mantine UI, handle form state, validate inputs per CONTEXT.md rules, display errors, export properly.
  </done>
</task>

<task type="auto">
  <name>Create Lobby container with WebSocket integration and routing</name>
  <files>
    apps/web/src/components/Lobby.tsx
    apps/web/src/app/app.tsx
  </files>
  <action>
**Lobby.tsx:**
- Import useWebSocket, CreateRoom, JoinRoom, PlayerList
- Import useState for local state (roomState, currentView, countdown)
- Use useWebSocket hook with ws://localhost:3333/ws
- Implement onMessage handler:
  - room_created: Store room ID, switch to player list view, show "Copy room ID" button (navigator.clipboard.writeText)
  - player_joined: Update local room state with new player
  - player_left: Remove player from local room state
  - player_ready: Update player ready status in local room state, check if all ready to start countdown
  - color_changed: Update player color in local room state (LOBBY-04)
  - game_starting: Start countdown timer (LOBBY-06)
  - room_state: Replace local room state with full state from server
  - error: Display error message using Mantine Notification or Alert
- State management: Track current room (Room from @catan/shared or null), current view ('create' | 'join' | 'lobby'), countdown (number | null), currentPlayerId (string)
- Countdown logic: When game_starting message received, set countdown state to 5 seconds, use setInterval to decrement every second, show countdown overlay/modal
- Color change handler: sendMessage({ type: 'change_color', playerId, color })
- Ready toggle handler: sendMessage({ type: 'toggle_ready', playerId })
- Render conditionally:
  - If no room: Show CreateRoom and JoinRoom components side-by-side
  - If in room: Show room ID (with copy button), PlayerList (with color/ready callbacks), connection status indicator
  - If countdown active: Show countdown overlay with "Game starting in X seconds..." message
- Display "Reconnecting..." banner if !isConnected
- Export default component

**app.tsx:**
- Replace default NX welcome screen with Lobby component
- Keep Mantine providers if present (MantineProvider, theme setup)
- Clean layout, centered container

Use Zustand from STACK.md for state management if state becomes complex, otherwise useState is fine for this phase.
  </action>
  <verify>
Run `npx nx serve web` and `npx nx serve api` simultaneously.
Test full flow:
1. Enter nickname, click Create Room → Should see room ID and "Copy room ID" button
2. Copy room ID → Should copy to clipboard
3. Open second browser tab/window, enter room ID + nickname, click Join → Should see both players in PlayerList
4. Close one tab → Other tab should show player_left update
5. Stop API server → Should see "Reconnecting..." banner
6. Restart API server → Banner should disappear (but room lost - expected per grace period)
  </verify>
  <done>
Lobby component integrates all pieces, handles all WebSocket message types, displays room state, updates in real-time, shows connection status, app.tsx renders Lobby, full create/join flow works end-to-end.
  </done>
</task>

</tasks>

<verification>
1. User can create room by entering nickname
2. Room ID (6 chars, uppercase) displayed after creation
3. "Copy room ID" button copies ID to clipboard
4. User can join room by entering room ID + nickname
5. Invalid room ID shows "Room not found" error
6. Full room (4 players) shows "Room is full" error
7. Duplicate nickname shows "Nickname taken" error
8. PlayerList updates in real-time when players join/leave
9. Connection status visible ("Reconnecting..." when disconnected)
10. WebSocket reconnects automatically after network interruption
11. All message types (room_created, player_joined, player_left, room_state, error) handled correctly
</verification>

<success_criteria>
- [ ] apps/web/src/services/websocket.ts implements WebSocketClient with reconnection
- [ ] apps/web/src/hooks/useWebSocket.ts provides React-friendly API
- [ ] CreateRoom, JoinRoom, PlayerList components exist and render correctly
- [ ] Lobby.tsx integrates WebSocket and displays room state
- [ ] app.tsx renders Lobby component
- [ ] `npx nx serve web` starts without errors
- [ ] Can create room and see room ID
- [ ] Can join room from second browser tab
- [ ] Player list updates in real-time
- [ ] Error messages display for invalid operations
- [ ] Reconnection works after API restart
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md` documenting lobby UI, WebSocket client implementation, component structure, and UX flow.
</output>
