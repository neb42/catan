---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - apps/api/src/main.ts
  - apps/api/src/managers/RoomManager.ts
  - apps/api/src/handlers/websocket.ts
  - apps/api/src/utils/room-id.ts
autonomous: true

must_haves:
  truths:
    - "Client can connect to WebSocket at ws://localhost:3333/ws"
    - "Server broadcasts messages to all players in a room"
    - "Rooms are created with unique 6-character IDs"
    - "Rooms auto-delete after 3-minute grace period when empty"
    - "Duplicate nicknames in same room are rejected"
  artifacts:
    - path: "apps/api/src/main.ts"
      provides: "Express server with WebSocket upgrade"
      min_lines: 40
    - path: "apps/api/src/managers/RoomManager.ts"
      provides: "Room lifecycle management"
      exports: ["RoomManager"]
    - path: "apps/api/src/handlers/websocket.ts"
      provides: "WebSocket message routing"
      exports: ["handleWebSocketConnection"]
    - path: "apps/api/src/utils/room-id.ts"
      provides: "Room ID generation"
      exports: ["generateRoomId"]
  key_links:
    - from: "apps/api/src/main.ts"
      to: "apps/api/src/handlers/websocket.ts"
      via: "WebSocket connection handler"
      pattern: "handleWebSocketConnection"
    - from: "apps/api/src/handlers/websocket.ts"
      to: "apps/api/src/managers/RoomManager.ts"
      via: "room operations"
      pattern: "roomManager\\.(createRoom|addPlayer|removePlayer)"
    - from: "apps/api/src/managers/RoomManager.ts"
      to: "@catan/shared"
      via: "schema validation"
      pattern: "(Room|Player|WebSocketMessage)Schema"
---

<objective>
Implement WebSocket server with room management, including connection handling, room lifecycle, and message broadcasting.

Purpose: Establishes backend infrastructure for real-time multiplayer. Clients can create rooms, join with nicknames, and receive live updates when players join/leave.

Output: Running WebSocket server on port 3333 with room manager handling create, join, leave, and grace period cleanup.
</objective>

<execution_context>
@./.github/get-shit-done/workflows/execute-plan.md
@./.github/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/codebase/STACK.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Set up Express server with WebSocket upgrade handler</name>
  <files>apps/api/src/main.ts</files>
  <action>
Update main.ts to integrate WebSocket server following RESEARCH.md Pattern 1 (Express + ws Integration):

1. Import WebSocketServer from 'ws' and createServer from 'http'
2. Wrap Express app with http.createServer()
3. Create WebSocketServer with { noServer: true }
4. Add 'upgrade' event listener on http server:
   - Parse URL pathname from request.url
   - If pathname === '/ws', call wss.handleUpgrade()
   - Else, destroy socket
5. Import and call handleWebSocketConnection() on 'connection' event
6. Add heartbeat detection using RESEARCH.md Pattern 2 (30-second ping interval)
7. Listen on port 3333 (or from environment variable)

Keep existing Express routes if any. WebSocket runs on same port as HTTP API.

Avoid socket.io patterns - use native ws library as specified in RESEARCH.md.
  </action>
  <verify>
Run `npx nx serve api` and verify:
- Server starts without errors
- Log shows "WebSocket server listening on port 3333" or similar
- Can connect to ws://localhost:3333/ws using websocat or browser console: `new WebSocket('ws://localhost:3333/ws')`
  </verify>
  <done>
Express server integrates WebSocket via upgrade event, WebSocketServer configured, heartbeat detection active, server accepts connections at /ws endpoint.
  </done>
</task>

<task type="auto">
  <name>Implement RoomManager with grace period cleanup</name>
  <files>
    apps/api/src/managers/RoomManager.ts
    apps/api/src/utils/room-id.ts
  </files>
  <action>
Create two files following RESEARCH.md patterns:

**apps/api/src/utils/room-id.ts:**
- Implement generateRoomId() using RESEARCH.md Pattern 6 (Custom Alphabet)
- Use crypto.getRandomValues() with ROOM_ID_ALPHABET from @catan/shared
- Return 6-character uppercase alphanumeric string

**apps/api/src/managers/RoomManager.ts:**
- Implement class following RESEARCH.md "Room Manager with Grace Period Cleanup"
- Private Map<string, Room> where Room = { id, players: Map<playerId, Player>, disconnectTimer }
- Methods:
  - createRoom(roomId): Create room, return room object
  - addPlayer(roomId, player): Validate room exists, size < 4, nickname unique in room, clear disconnectTimer if set, add player
  - removePlayer(roomId, playerId): Delete player, start 3-minute grace period timer if room becomes empty
  - getRoom(roomId): Return room or undefined
  - broadcastToRoom(roomId, message, excludeId?): Send JSON message to all players in room via ws.send(), check readyState === OPEN
  - isNicknameTaken(roomId, nickname): Check if nickname exists in room's player map

Grace period: Use GRACE_PERIOD_MS from @catan/shared, setTimeout to delete room, clearTimeout on addPlayer.

Import Player, Room types from @catan/shared. Store WebSocket in player object as { id, nickname, color, ready, ws }.
  </action>
  <verify>
Run `npx nx build api` to verify TypeScript compilation.
Manually test RoomManager:
```typescript
const rm = new RoomManager();
const room = rm.createRoom('ABC123');
console.log(room.players.size === 0); // Should be true
```
  </verify>
  <done>
RoomManager class exists with all methods, grace period logic implemented using setTimeout/clearTimeout, room ID generation uses crypto.getRandomValues(), nickname uniqueness validated.
  </done>
</task>

<task type="auto">
  <name>Create WebSocket message handler with room operations</name>
  <files>apps/api/src/handlers/websocket.ts</files>
  <action>
Create websocket.ts handler file implementing message routing:

1. Export handleWebSocketConnection(ws: WebSocket, roomManager: RoomManager)
2. Track player ID and current room ID for this connection
3. On 'message' event:
   - Parse JSON and validate with WebSocketMessageSchema from @catan/shared
   - Use discriminated union to handle message types:
     - **create_room**: Generate room ID using generateRoomId(), check not exists, create room, add player with ws connection, send room_created message, broadcast room_state to room
     - **join_room**: Validate room exists (else send error: "Room not found"), check room.players.size < 4 (else "Room is full"), check nickname not taken (else "Nickname taken"), add player to room, broadcast player_joined to existing players, send room_state to joining player
     - **toggle_ready**: Update player.ready in room, broadcast player_ready to room, check if all players ready (3-4 players), if yes broadcast game_starting with countdown: 5
     - **change_color**: Validate color available (not taken by others), update player.color, broadcast color_changed to room
   - Catch validation errors and send error message back to client
4. On 'close' event:
   - Remove player from room using roomManager.removePlayer()
   - Broadcast player_left to remaining players
5. On 'error' event: Log error, clean up connection

Use RoomManager methods for all room operations. All messages must be validated with Zod before processing.

For ready check: Room is ready to start if players.size >= 3 AND players.size <= 4 AND all players have ready === true.

Follow RESEARCH.md anti-pattern warning: "Don't trust client data" - always parse with schemas.
  </action>
  <verify>
Run `npx nx serve api` and test with websocat:
```bash
websocat ws://localhost:3333/ws
{"type":"create_room","nickname":"Alice"}
# Should receive room_created with roomId
```

Verify error handling:
```bash
websocat ws://localhost:3333/ws
{"type":"join_room","roomId":"INVALID","nickname":"Bob"}
# Should receive {"type":"error","message":"Room not found"}
```
  </verify>
  <done>
WebSocket handler routes all message types (create_room, join_room, player_ready), validates with Zod, uses RoomManager for operations, broadcasts updates to rooms, handles errors gracefully.
  </done>
</task>

</tasks>

<verification>
1. WebSocket server accepts connections at ws://localhost:3333/ws
2. Can create room and receive room_created message with valid 6-char ID
3. Can join existing room and receive room_state
4. Duplicate nickname in same room returns "Nickname taken" error
5. Invalid room ID returns "Room not found" error
6. Full room (4 players) returns "Room is full" error
7. Player disconnect broadcasts player_left to remaining players
8. Empty room is deleted after 3-minute grace period
9. Heartbeat ping/pong keeps connections alive
</verification>

<success_criteria>
- [ ] apps/api/src/main.ts integrates WebSocket via upgrade event
- [ ] apps/api/src/managers/RoomManager.ts implements all methods with grace period
- [ ] apps/api/src/utils/room-id.ts generates 6-char uppercase alphanumeric IDs
- [ ] apps/api/src/handlers/websocket.ts handles create_room, join_room, toggle_ready, change_color messages
- [ ] `npx nx serve api` starts server without errors
- [ ] WebSocket connection to ws://localhost:3333/ws succeeds
- [ ] create_room message returns room_created with room ID
- [ ] join_room message with valid ID returns room_state
- [ ] toggle_ready triggers game_starting when all players (3-4) are ready
- [ ] change_color updates player color and broadcasts to room
- [ ] All error cases return proper error messages
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md` documenting WebSocket server setup, RoomManager API, message protocol, and testing results.
</output>
